<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴锴的博客</title>
  
  <subtitle>Life? Don&#39;t talk to me about life!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wukai.me/"/>
  <updated>2022-02-27T10:58:32.953Z</updated>
  <id>http://www.wukai.me/</id>
  
  <author>
    <name>noiron</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Nodejs 遍历文件夹</title>
    <link href="http://www.wukai.me/2022/02/27/nodejs-traverse-folder/"/>
    <id>http://www.wukai.me/2022/02/27/nodejs-traverse-folder/</id>
    <published>2022-02-27T10:41:52.000Z</published>
    <updated>2022-02-27T10:58:32.953Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一个管理 markdown 文件的工具 <a href="https://github.com/noiron/knowledge-center">knowledge-center</a>，需要读取指定文件夹内所有 markdown 文件。因此需要用 Node.js 来实现遍历一个文件夹内所有文件的功能。</p><p>Node.js 中提供了这些有用的 API：</p><ul><li><code>fs.readdir</code>：异步读取文件夹</li><li><code>fs.readdirSync</code>：同步读取文件夹</li><li><code>fs.statSync</code>：同步获取文件属性</li></ul><span id="more"></span><h2 id="获取的文件列表为数组格式"><a href="#获取的文件列表为数组格式" class="headerlink" title="获取的文件列表为数组格式"></a>获取的文件列表为数组格式</h2><p>对于遍历的结果，我们可以选择按列表或文件树来展示。先从最简单的情况看起，用同步方式处理，返回结果是一个列表。</p><script src="https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js?file=traverseFolderList.js"></script><p>先使用 <code>fs.readdirSync</code> 获取文件列表，然后遍历文件列表，使用 <code>fs.statSync</code> 获取列表中文件的状态，如果是文件，则添加到文件列表中，如果是文件夹，则递归调用 <code>traverseFolderList</code> 函数，直到获取到所有文件。</p><h2 id="获取的文件列表为对象格式"><a href="#获取的文件列表为对象格式" class="headerlink" title="获取的文件列表为对象格式"></a>获取的文件列表为对象格式</h2><p>如果我们想展示文件夹目录结构，那么列表格式的就不太方便了。假设有如下的文件夹结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./1</span><br><span class="line">├── 2</span><br><span class="line">│   ├── test2.txt</span><br><span class="line">│   └── test2_1.txt</span><br><span class="line">└── 3</span><br><span class="line">    ├── 4</span><br><span class="line">    │   └── test4.txt</span><br><span class="line">    └── test3.txt</span><br></pre></td></tr></table></figure><p>希望获取到的对象结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">root</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;./1&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;folder&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>],</span><br><span class="line">    <span class="attr">isRoot</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">2</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;folder&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [<span class="string">&#x27;2/test2.txt&#x27;</span>, <span class="string">&#x27;2/test2_1.txt&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">3</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;3&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;folder&#x27;</span>, <span class="attr">children</span>: [<span class="string">&#x27;3/4&#x27;</span>, <span class="string">&#x27;3/test3.txt&#x27;</span>] &#125;,</span><br><span class="line">  <span class="string">&#x27;2/test2.txt&#x27;</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;2/test2.txt&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;file&#x27;</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;2/test2_1.txt&#x27;</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;2/test2_1.txt&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;file&#x27;</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;3/4/test4.txt&#x27;</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;3/4/test4.txt&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;folder&#x27;</span>, <span class="attr">children</span>: [] &#125;,</span><br><span class="line">  <span class="string">&#x27;3/4&#x27;</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;3/4&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;folder&#x27;</span>, <span class="attr">children</span>: [<span class="string">&#x27;3/4/test4.txt&#x27;</span>] &#125;,</span><br><span class="line">  <span class="string">&#x27;3/test3.txt&#x27;</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;3/test3.txt&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;file&#x27;</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个对象以文件/文件夹相对于根目录的相对路径为 key，每个节点包含了这些属性：</p><ul><li><code>type</code>：用于区分文件或文件夹类型</li><li><code>path</code>：相对路径</li><li><code>children</code>：如果是文件夹类型，则其中是子文件的相对路径</li></ul><script src="https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js?file=traverseFolderObj.js"></script><h2 id="异步方式"><a href="#异步方式" class="headerlink" title="异步方式"></a>异步方式</h2><p>在上面的实现中，都是使用了同步的方式来处理，即 <code>fs.readdirSync</code> 方法，可以使用异步方式来处理吗？</p><p>可以选择 <code>fs.readdir</code> 来异步读取文件夹, 但是回调函数的调用方式不太方便。在 Node 10+ 中可以从 <code>fs.promises</code> 中引入 <code>readdir</code> 方法，这样就可以使用方便的 <code>async/await</code> 语法来进行异步处理，同时避免了  的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readdir &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).promises; </span><br></pre></td></tr></table></figure><p>将上面的 <code>traverseFolderList</code> 方法重写为异步格式：</p><script src="https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js?file=asyncTraverseFolderList.js"></script><h2 id="比较同步和异步两种方案"><a href="#比较同步和异步两种方案" class="headerlink" title="比较同步和异步两种方案"></a>比较同步和异步两种方案</h2><p><code>traverseFolderList</code> 和 <code>asyncTraverseFolderList</code> 返回的结果都是列表格式，我们可以写一个测试脚本来比较下二者的运行时间：</p><script src="https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js?file=index.js"></script><p>分别用两个函数遍历了同一个文件夹十次后，统计结果如下，异步方式比同步方式快了约18%。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步 - 平均耗时：1217.1ms</span><br><span class="line">异步 - 平均耗时：1025.7ms</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://stackoverflow.com/a/45130990">https://stackoverflow.com/a/45130990</a></p><p>fs.promises 和 promisify api<br><a href="https://nodejs.org/dist/latest-v10.x/docs/api/fs.html#fs_fs_promises_api">https://nodejs.org/dist/latest-v10.x/docs/api/fs.html#fs_fs_promises_api</a><br><a href="https://javascript.info/promisify">https://javascript.info/promisify</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写一个管理 markdown 文件的工具 &lt;a href=&quot;https://github.com/noiron/knowledge-center&quot;&gt;knowledge-center&lt;/a&gt;，需要读取指定文件夹内所有 markdown 文件。因此需要用 Node.js 来实现遍历一个文件夹内所有文件的功能。&lt;/p&gt;
&lt;p&gt;Node.js 中提供了这些有用的 API：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fs.readdir&lt;/code&gt;：异步读取文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.readdirSync&lt;/code&gt;：同步读取文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.statSync&lt;/code&gt;：同步获取文件属性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="nodejs" scheme="http://www.wukai.me/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>如何解数独</title>
    <link href="http://www.wukai.me/2022/02/16/sudoku/"/>
    <id>http://www.wukai.me/2022/02/16/sudoku/</id>
    <published>2022-02-15T16:00:00.000Z</published>
    <updated>2022-02-27T04:19:27.767Z</updated>
    
    <content type="html"><![CDATA[<p>数独游戏的规则很简单，在9x9的矩阵中，每行、每列、每个九宫格中都需要填入1~9共九个数字，且不重复。</p><p>Peter Norvig 的这篇文章 <a href="https://norvig.com/sudoku.html">Solving Every Sudoku Puzzle</a> 详细介绍了一种解数独的方法。文中的代码基于 Python2 实现，我将其改写成了 JavaScript 的版本，项目可见 <a href="https://github.com/noiron/sudoku">noiron/sudoku</a>。</p><p>这篇文章中记录了我的理解而非原文的翻译，如果需要更详情的解释，可以查看原文。</p><span id="more"></span><h2 id="数据的表示"><a href="#数据的表示" class="headerlink" title="数据的表示"></a>数据的表示</h2><p>首先需要考虑的是如何表示数据，数独的行使用 A-I 的字母表示，列使用 1-9 的数字表示。代码中用到了以下的术语/变量：</p><ul><li><code>square</code> 所有81个格子的标记 <code>[&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, ... , &#39;I7&#39;, &#39;I8&#39;, &#39;I9&#39;]</code></li><li><code>unit</code> 一个格子所在的行、列或九宫格</li><li><code>unitList</code> 包含9行、9列、9个九宫格，共27个 unit</li><li><code>peers</code> 格子所在三个 unit 中的其他格子，共20个</li><li><code>grid</code> 使用文本格式来表示数独的初始状态，1~9 代表数字，0或.代表此处未填入</li><li><code>values</code> 一个以 square 为 key 的 map，给出每个格子的可能值，eg. <code>&#123;&#39;A1&#39;:&#39;12349&#39;, &#39;A2&#39;:&#39;8&#39;, ...&#125;</code></li></ul><p>对于数独的初始状态使用文本格式来表示，如下所示的三种格式代表的是同一个数独：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......</span><br><span class="line"></span><br><span class="line">400000805</span><br><span class="line">030000000</span><br><span class="line">000700000</span><br><span class="line">020000060</span><br><span class="line">000080400</span><br><span class="line">000010000</span><br><span class="line">000603070</span><br><span class="line">500200000</span><br><span class="line">104000000</span><br><span class="line"></span><br><span class="line">4 . . |. . . |8 . 5 </span><br><span class="line">. 3 . |. . . |. . . </span><br><span class="line">. . . |7 . . |. . . </span><br><span class="line">------+------+------</span><br><span class="line">. 2 . |. . . |. 6 . </span><br><span class="line">. . . |. 8 . |4 . . </span><br><span class="line">. . . |. 1 . |. . . </span><br><span class="line">------+------+------</span><br><span class="line">. . . |6 . 3 |. 7 . </span><br><span class="line">5 . . |2 . . |. . . </span><br><span class="line">1 . 4 |. . . |. . . </span><br></pre></td></tr></table></figure><p>这部分的 JS 代码实现可以看代码：<a href="https://github.com/noiron/sudoku/blob/master/base.js">data.js</a></p><p>开始时，每个格子都可以是 1~9 的任何数字，然后从初始状态开始给每个格子填入相应的数字。解数独的过程就是在减少每个格子可以填入的数字，直到所有格子都能且只能填入1个数字。这里需要用到两种方法：<strong>约束传播（Constraint Propagation）</strong>和<strong>搜索（Search）</strong>。</p><h2 id="约束传播（Constraint-Propagation）"><a href="#约束传播（Constraint-Propagation）" class="headerlink" title="约束传播（Constraint Propagation）"></a>约束传播（Constraint Propagation）</h2><p>在处理数独的初始状态时用了 <code>parseGrid()</code> 函数，其中调用了 <code>assign(values, square, digit)</code> 方法，即将 digit 填入 square。</p><p>解数独有两个重要策略：</p><ol><li>如果一个格子只有唯一的可选数字，则从它的 peers 中删除这个数字</li><li>如果一个 unit 中只有一个格子可以填入某一个数字，则将这个数字填入这个格子</li></ol><p>这里需要使用 <code>assign()</code> 和 <code>eliminate()</code> 两个函数，代码见：<a href="https://github.com/noiron/sudoku/blob/master/solve.js">solve.js</a></p><p>经过这个过程后一些简单的数独就可以得出解了，但对复杂的数独并非如此。所以需要使用<strong>搜索（Search）</strong> 来进一步处理。</p><h2 id="搜索（Search）"><a href="#搜索（Search）" class="headerlink" title="搜索（Search）"></a>搜索（Search）</h2><p>这里的搜索指的是系统地尝试所有的可能性，直到找到解。对于数独来说就是对于每个未确定的格子，尝试填入一个可能的数字，然后继续搜索。如果出现了矛盾，就换一个数字。这是一个递归的过程，即深度优先搜索（depth-first search）。</p><p><code>search()</code> 函数的具体代码见：<a href="https://github.com/noiron/sudoku/blob/master/solve.js">solve.js</a></p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>整体的流程图如下：</p><pre class="mermaid" style="text-align: center;">            flowchart TB            %% init(初始化)开始 --> gridValues("gridValues()\n将字符串表示转换为map");gridValues --> assign("assign()"\n给特定格子分配一个数字);assign --> canAssign{分配过程\n没有矛盾?};canAssign -- 无法分配 ----> 无解canAssign-- 可以分配 --> eliminate("eliminate()\n进行约束传播");eliminate --> onlyOne{发现某个格子只有\n唯一的可能性}onlyOne -- 是的 --> assignonlyOne -- 否 --> search("search()\n依次尝试可能的数字\nDFS递归处理");search --> found{每个格子都能\n分配唯一的数字?}found -- 不行 --> 无解 --> 结束found -- 可以 --> 找到答案 --> 结束          </pre><p>至此就完成了数独的解法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数独游戏的规则很简单，在9x9的矩阵中，每行、每列、每个九宫格中都需要填入1~9共九个数字，且不重复。&lt;/p&gt;
&lt;p&gt;Peter Norvig 的这篇文章 &lt;a href=&quot;https://norvig.com/sudoku.html&quot;&gt;Solving Every Sudoku Puzzle&lt;/a&gt; 详细介绍了一种解数独的方法。文中的代码基于 Python2 实现，我将其改写成了 JavaScript 的版本，项目可见 &lt;a href=&quot;https://github.com/noiron/sudoku&quot;&gt;noiron/sudoku&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这篇文章中记录了我的理解而非原文的翻译，如果需要更详情的解释，可以查看原文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://www.wukai.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="sudoku" scheme="http://www.wukai.me/tags/sudoku/"/>
    
  </entry>
  
  <entry>
    <title>一个 styled-components 的问题（props or css variables）</title>
    <link href="http://www.wukai.me/2021/12/22/styled-components-props-or-css-variables/"/>
    <id>http://www.wukai.me/2021/12/22/styled-components-props-or-css-variables/</id>
    <published>2021-12-21T16:00:00.000Z</published>
    <updated>2022-02-16T13:57:16.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题的起因"><a href="#问题的起因" class="headerlink" title="问题的起因"></a>问题的起因</h2><p>最近需要实现这么一个功能，通过拖动来改变窗口左侧的文件列表栏的宽度。我选择了用 <code>styled-components</code> 来实现这个功能，并写了如下的样式组件，其中将边栏当前的宽度 <code>width</code> 作为属性传入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StyledFileList = styled.div&lt;&#123; <span class="attr">width</span>: <span class="built_in">number</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  position: absolute;</span></span><br><span class="line"><span class="string">  top: 0;</span></span><br><span class="line"><span class="string">  left: 0;</span></span><br><span class="line"><span class="string">  width: <span class="subst">$&#123;props =&gt; props.width + <span class="string">&#x27;px&#x27;</span>&#125;</span>;</span></span><br><span class="line"><span class="string">  height: 100%;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>但是当我快速拖动边栏时，<code>width</code> 变化得非常频繁，在控制台中展示了如下的 Warning。</p><p><img src="/asset/images/2021-12-22-sc-console.png" alt="控制台warning"></p><span id="more"></span><p>大意是仅为这一个组件就生成了超过 200 个 class。利用开发者工具的查找元素，改变 <code>width</code> 时可以观察到元素上的 class 名称一直在变化。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">width</span>=<span class="string">&quot;270&quot;</span> <span class="attr">class</span>=<span class="string">&quot;sc-bdvvtL ckAtiw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">width</span>=<span class="string">&quot;271&quot;</span> <span class="attr">class</span>=<span class="string">&quot;sc-bdvvtL bBcytR&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以确定 <code>styled-components</code> 给每一个不同的 <code>width</code> 属性都生成了一个 class。如果在 html 中搜索相应的 class 名称（如上面的代码中是 <code>ckAtiw</code> 和 <code>bBcytR</code>），可以在 <code>&lt;head&gt;</code> 的 <code>&lt;style&gt;</code> 标签中找到它们对应的样式内容，稍加比较就可以发现除了 <code>width</code> 以外的部分都是相同的。</p><p><code>styled-components</code>处理样式的过程是这样的：属性改变 -&gt; 重新生成样式 -&gt; 插入到 <code>&lt;head&gt;</code> 中，这个过程如果重复很多次，会产生大量的 CSS 内容冗余，很有可能造成性能问题。而我们可以通过使用 CSS 变量来解决这个问题。</p><h2 id="使用-CSS-变量"><a href="#使用-CSS-变量" class="headerlink" title="使用 CSS 变量"></a>使用 CSS 变量</h2><p>我是在这篇文章 <a href="https://www.joshwcomeau.com/css/styled-components/#css-variables"><em>The styled-components Happy Path</em></a> 中学到了在 <code>styled-components</code> 中使用 CSS 变量（CSS variable）的技巧。</p><h3 id="什么是-CSS-变量"><a href="#什么是-CSS-变量" class="headerlink" title="什么是 CSS 变量"></a>什么是 CSS 变量</h3><p>CSS 变量是以 <code>--</code> 开头的属性名称，它们的值可以是任何类型的值，使用 <code>var(--your-variable-name)</code> 来应用样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--your-awesome-<span class="attribute">color</span>: darkcyan;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--your-awesome-color);</span><br><span class="line"></span><br><span class="line">--this-<span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="built_in">var</span>(--this-padding);</span><br></pre></td></tr></table></figure><p style="  --your-awesome-color: darkcyan;  color: var(--your-awesome-color);  --this-padding: 20px;  padding-left: var(--this-padding);"><br>  这一行文字就是应用了上面的 CSS，你可以在控制台中修改样式并观察变化。<br></p><h3 id="改写原代码"><a href="#改写原代码" class="headerlink" title="改写原代码"></a>改写原代码</h3><p>对于之前的边栏组件，我们可以换一个写法来解决，不再使用 <code>props</code> 来传入宽度，而是使用 CSS 变量，组件代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;StyledFileList</span><br><span class="line">  <span class="comment">// 这里定义了 --width 这个 CSS 变量，width 是一个 number</span></span><br><span class="line">  style=&#123;&#123; <span class="string">&#x27;--width&#x27;</span>: width + <span class="string">&#x27;px&#x27;</span>&#125; <span class="keyword">as</span> CSSProperties&#125;</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StyledFileList = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  position: absolute;</span></span><br><span class="line"><span class="string">  top: 0;</span></span><br><span class="line"><span class="string">  left: 0;</span></span><br><span class="line"><span class="string">  // 这里应用了 CSS 变量</span></span><br><span class="line"><span class="string">  width: var(--width);</span></span><br><span class="line"><span class="string">  height: 100%;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时再改变左侧边栏的宽度，可发现元素的 class 名称是固定的，只有 style 在变化。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sc-bdvvtL jGeOyv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--width:210px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sc-bdvvtL jGeOyv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--width:250px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/asset/images/2021-12-22-sc-style.png" alt="CSS变量样式"></p><p>如果检查 <code>&lt;head&gt;</code> 中的内容，会看到在 <code>&lt;style&gt;</code> 标签中相应的样式内容也只出现了一次，从而解决了样式冗余的问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.joshwcomeau.com/css/styled-components/#css-variables">The styled-components Happy Path</a><br><a href="https://www.joshwcomeau.com/react/demystifying-styled-components/">Demystifying styled-components</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题的起因&quot;&gt;&lt;a href=&quot;#问题的起因&quot; class=&quot;headerlink&quot; title=&quot;问题的起因&quot;&gt;&lt;/a&gt;问题的起因&lt;/h2&gt;&lt;p&gt;最近需要实现这么一个功能，通过拖动来改变窗口左侧的文件列表栏的宽度。我选择了用 &lt;code&gt;styled-components&lt;/code&gt; 来实现这个功能，并写了如下的样式组件，其中将边栏当前的宽度 &lt;code&gt;width&lt;/code&gt; 作为属性传入。&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; StyledFileList = styled.div&amp;lt;&amp;#123; &lt;span class=&quot;attr&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt; &amp;#125;&amp;gt;&lt;span class=&quot;string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  position: absolute;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  top: 0;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  left: 0;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  width: &lt;span class=&quot;subst&quot;&gt;$&amp;#123;props =&amp;gt; props.width + &lt;span class=&quot;string&quot;&gt;&amp;#x27;px&amp;#x27;&lt;/span&gt;&amp;#125;&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  height: 100%;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是当我快速拖动边栏时，&lt;code&gt;width&lt;/code&gt; 变化得非常频繁，在控制台中展示了如下的 Warning。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/asset/images/2021-12-22-sc-console.png&quot; alt=&quot;控制台warning&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://www.wukai.me/tags/css/"/>
    
      <category term="styled-components" scheme="http://www.wukai.me/tags/styled-components/"/>
    
      <category term="react" scheme="http://www.wukai.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Puppeteer 的使用记录</title>
    <link href="http://www.wukai.me/2021/05/22/puppeteer-notes/"/>
    <id>http://www.wukai.me/2021/05/22/puppeteer-notes/</id>
    <published>2021-05-21T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.547Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Headless Browser</strong> 指的是没有图形用户界面（GUI）而是由程序控制的浏览器。<strong>Puppeteer</strong> 就是由 Google 推出的一种 headless browser。从 <a href="https://github.com/puppeteer/puppeteer">Puppeteer 的官方文档</a>中可以看到它能做的事有很多：</p><blockquote><ul><li>Generate screenshots and PDFs of pages.</li><li>Crawl a SPA (Single-Page Application) and generate pre-rendered content (i.e. “SSR” (Server-Side Rendering)).</li><li>Automate form submission, UI testing, keyboard input, etc.<br>…</li></ul></blockquote><p>几乎所有能手动在 Chrome 进行的操作现在都可以用 Puppeteer 来完成。</p><p>我之前在工作中就用到了 Puppeteer 做了一些页面爬取的工作，这里把使用到或者玩过的一些功能做了下总结和记录。这篇文章并不是一个全面的 Puppeteer 的使用教程，毕竟 Puppeteer 的大部分 API 我也没有使用过🙂。</p><span id="more"></span><h2 id="Puppeteer-的安装"><a href="#Puppeteer-的安装" class="headerlink" title="Puppeteer 的安装"></a>Puppeteer 的安装</h2><p>Puppeteer 的使用就是如同一个普通的 npm package 一样，使用 <code>npm init</code> 新建一个项目后，使用 <code>npm install puppeteer</code> 即可。如果安装过程中卡在了下载 Chromium 的过程中，可以考虑使用 <code>puppeteer-core</code> 来代替，具体可见</p><p><a href="https://github.com/puppeteer/puppeteer/blob/main/docs/api.md#puppeteer-vs-puppeteer-core">puppeteer-vs-puppeteer-core</a></p><h2 id="打开页面"><a href="#打开页面" class="headerlink" title="打开页面"></a>打开页面</h2><p>先由最基础的打开页面功能开始，新建一个 <code>index.js</code> 文件，写入下方的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.close();</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>现在运行 <code>node index.js</code>，如果成功运行，你将会看到什么也没有发生😕。这是因为，Puppeteer 默认是在 <code>headless</code> 模式下运行的，为了能看到确实打开了页面，可以在打开浏览器时加入参数 <code>&#123; headless: false &#125;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这里将 headless 设置了为 false，表示打开图形界面</span></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.close();</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>一个典型的流程如下：打开浏览器 -&gt; 打开新页面 -&gt; 去往指定页面 -&gt; 关闭页面（可省略） -&gt; 关闭浏览器。</p><h3 id="Timeout-问题的解决"><a href="#Timeout-问题的解决" class="headerlink" title="Timeout 问题的解决"></a>Timeout 问题的解决</h3><p>运行上面的代码，可能会出现 <code>TimeoutError</code> 的出错提示，这是因为访问指定页面的速度较慢导致了超时。你可以将 <code>pageUrl</code> 换成任意国内地址重试。</p><p>默认情况下 Puppeteer 的超时时间为 30s，如果在 30s 之内没能打开页面，会有 timeout 的出错提示。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnhandledPromiseRejectionWarning: TimeoutError: Navigation timeout of 30000 ms exceeded</span><br></pre></td></tr></table></figure></p><p>可以通过如下设置解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"><span class="comment">// 将超时时间改为了 60s，如果参数为0，则代表不做限制</span></span><br><span class="line">page.setDefaultNavigationTimeout(<span class="number">60000</span>);</span><br><span class="line"><span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="操作页面"><a href="#操作页面" class="headerlink" title="操作页面"></a>操作页面</h2><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p>Puppeteer 提供了 <code>screenshot</code> API，可以将页面截图保存下来。运行下面的代码将会在 js 文件所在的路径下保存一张名为 <code>screenshot.png</code> 的图片文件。这里有一点需要注意，在之前的代码中，我们没有设置窗口的大小，Puppeteer 默认打开的是 <code>800*600</code>尺寸的窗口，截图的大小也为 <code>800*600</code>（即使是在 <code>headless</code> 模式下也是如此）。可以通过 <code>setViewport</code> 来改变窗口的大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="comment">// 设置窗口的大小，可以注释下方的一行查看截图的区别</span></span><br><span class="line">  <span class="keyword">await</span> page.setViewport(&#123; <span class="attr">width</span>: <span class="number">1000</span>, <span class="attr">height</span>: <span class="number">500</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;screenshot.png&#x27;</span>),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.close();</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="生成-PDF"><a href="#生成-PDF" class="headerlink" title="生成 PDF"></a>生成 PDF</h3><p>同样也可以将页面保存成一个 PDF 文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.pdf(&#123; </span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;page-pdf.pdf&#x27;</span>), </span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;A4&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.close();</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>注意一点，保存为 PDF 的时候，必须在 <code>headless</code> 模式下进行。</p><h2 id="模拟设备"><a href="#模拟设备" class="headerlink" title="模拟设备"></a>模拟设备</h2><p>平时我们浏览的网站可能针对不同的设备会有不同的展示效果，区分移动端和PC端、Android 或 iOS 等。Puppeteer 就提供了模拟设备的功能。</p><h3 id="使用已有的设备列表"><a href="#使用已有的设备列表" class="headerlink" title="使用已有的设备列表"></a>使用已有的设备列表</h3><p>可以使用 <code>page.emulate(options)</code> 来模拟设备，可以在这个文件中看到支持的设备列表：<a href="https://github.com/puppeteer/puppeteer/blob/main/src/common/DeviceDescriptors.ts">puppeteer/DeviceDescriptors.ts at main · puppeteer/puppeteer · GitHub</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"><span class="comment">// 这里将模拟一台 iPhone XR 设备</span></span><br><span class="line"><span class="keyword">const</span> iPhone = puppeteer.devices[<span class="string">&#x27;iPhone XR&#x27;</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.emulate(iPhone);</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="添加自定义的-UserAgent"><a href="#添加自定义的-UserAgent" class="headerlink" title="添加自定义的 UserAgent"></a>添加自定义的 UserAgent</h3><p>也可以添加自己的 UserAgent 的方式来模拟列表中没有的设备。下面的代码中以 iPad Pro 为例，说明如何设置 UserAgent（其实 iPad Pro 是存在于上面的设备列表中的，这里只是举了个例子）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.setViewport(&#123; <span class="attr">width</span>: <span class="number">1024</span>, <span class="attr">height</span>: <span class="number">1366</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.setUserAgent(</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="监听-response"><a href="#监听-response" class="headerlink" title="监听 response"></a>监听 response</h2><p>考虑一下这样的场景，如何获取到页面上的所有的图片。当然我们可以拿到整个页面，然后使用 <code>document.querySelector()</code> 筛选出所有的 <code>img</code> 标签。这样会有一点小问题，如果图片是以 CSS  的 <code>background-image</code> 形式引入的，查找 <code>img</code> 标签是无法找到的。如果图片地址是由 js 动态改变的，可能也会缺失部分图片。</p><p>另一种可选的方式是通过监听 <code>response</code> 的方式来处理。可以认为在 Chrome 开发工具的 Network Tab 下能看到的每一个 response 都可以在这里拿到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">  page.on(<span class="string">&#x27;response&#x27;</span>, <span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> request = response.request();</span><br><span class="line">    <span class="keyword">const</span> resourceType = request.resourceType();</span><br><span class="line">    <span class="keyword">const</span> contentType = response.headers()[<span class="string">&#x27;content-type&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceType === <span class="string">&#x27;image&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> url = response.url();</span><br><span class="line">      <span class="built_in">console</span>.log(contentType, url);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>通过 <code>response.headers</code> 可以获取响应的 header 信息。如果有需要也可将响应保存成本地的文件。</p><hr><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Headless Browser&lt;/strong&gt; 指的是没有图形用户界面（GUI）而是由程序控制的浏览器。&lt;strong&gt;Puppeteer&lt;/strong&gt; 就是由 Google 推出的一种 headless browser。从 &lt;a href=&quot;https://github.com/puppeteer/puppeteer&quot;&gt;Puppeteer 的官方文档&lt;/a&gt;中可以看到它能做的事有很多：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Generate screenshots and PDFs of pages.&lt;/li&gt;
&lt;li&gt;Crawl a SPA (Single-Page Application) and generate pre-rendered content (i.e. “SSR” (Server-Side Rendering)).&lt;/li&gt;
&lt;li&gt;Automate form submission, UI testing, keyboard input, etc.&lt;br&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;几乎所有能手动在 Chrome 进行的操作现在都可以用 Puppeteer 来完成。&lt;/p&gt;
&lt;p&gt;我之前在工作中就用到了 Puppeteer 做了一些页面爬取的工作，这里把使用到或者玩过的一些功能做了下总结和记录。这篇文章并不是一个全面的 Puppeteer 的使用教程，毕竟 Puppeteer 的大部分 API 我也没有使用过🙂。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://www.wukai.me/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="node.js" scheme="http://www.wukai.me/tags/node-js/"/>
    
      <category term="puppeteer" scheme="http://www.wukai.me/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>2019年总结</title>
    <link href="http://www.wukai.me/2020/01/24/2019-annual-summary/"/>
    <id>http://www.wukai.me/2020/01/24/2019-annual-summary/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>很多年前在学校的时候，中二期的我和朋友讨论过如果穿越到古代想去哪个朝代。我说去三国吧，和刘关张结义，一统天下，岂不美哉。朋友指出，这三人都比你年纪大，你去了只能做小弟。额，这点倒没想到，于是穿越计划无疾而终。去年又翻了下《三国演义》，在第一章桃园三结义中看到了这句“及刘焉发榜招军时，玄德年已二十八岁矣”，哦，看来我再也不用担心穿越到三国时期的年龄问题了。刘备二十八岁时就已经开始匡扶汉室了，而我二十八岁时还在写代码 ╮(╯_╰)╭。</p><span id="more"></span><h2 id="看过的书"><a href="#看过的书" class="headerlink" title="看过的书"></a>看过的书</h2><p>19年仍然看了大约二十本的新书，数量上和以前差不多。</p><p>小说类：</p><ul><li>Flowers for Algernon</li><li>鞑靼人沙漠</li><li>上帝的图书馆</li><li>日本合众国</li><li>了不起的盖茨比</li><li>挪威的森林</li><li>环界（1-4)</li></ul><p>非虚构类：</p><ul><li>程序员修炼之道</li><li>黑客与画家</li><li>影响力</li><li>未来简史</li><li>经度 </li><li>阅读是一座随身携带的避难所</li><li>那些科学家们彻夜忧虑的问题</li><li>量子物理史话</li><li>怪诞行为学1：可预测的非理性</li></ul><h2 id="玩过的游戏"><a href="#玩过的游戏" class="headerlink" title="玩过的游戏"></a>玩过的游戏</h2><p>19年初买了任天堂的 Switch，于是从 Steam 那里省下的金钱和时间又花在了 Switch 的游戏上。下面每个游戏都花了十几小时到上百小时不等。</p><ul><li>塞尔达传说</li><li>神界：原罪2</li><li>暗黑破坏神3</li><li>Guns Gore and Cannoli 2</li><li>Dead Cells</li><li>Bastion</li><li>…</li></ul><h2 id="新技能"><a href="#新技能" class="headerlink" title="新技能"></a>新技能</h2><p>下半年买了《三十天学会绘画》，没能像书名里写的那样在三十天里看完，用了大约半年终于在12月看完了这本书。按照书里的教程画了一遍之后，很明显，还没有学会绘画。于是又买了本《素描的诀窍》，准备在2020年继续画下去。</p><hr><p>虽然我知道自己定了新年计划，也是不会去完成的。但希望自己在2020年多看点计算机类的书籍，多写点博客做点记录。2019年的年度总结没赶上元旦完成，今天就祝所有人春节平安快乐吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多年前在学校的时候，中二期的我和朋友讨论过如果穿越到古代想去哪个朝代。我说去三国吧，和刘关张结义，一统天下，岂不美哉。朋友指出，这三人都比你年纪大，你去了只能做小弟。额，这点倒没想到，于是穿越计划无疾而终。去年又翻了下《三国演义》，在第一章桃园三结义中看到了这句“及刘焉发榜招军时，玄德年已二十八岁矣”，哦，看来我再也不用担心穿越到三国时期的年龄问题了。刘备二十八岁时就已经开始匡扶汉室了，而我二十八岁时还在写代码 ╮(╯_╰)╭。&lt;/p&gt;
    
    </summary>
    
    
      <category term="年度总结" scheme="http://www.wukai.me/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>从插入图片功能的实现来介绍 Draft.js 富文本编辑器</title>
    <link href="http://www.wukai.me/2019/07/21/draftjs-editor-tutorial-1/"/>
    <id>http://www.wukai.me/2019/07/21/draftjs-editor-tutorial-1/</id>
    <published>2019-07-20T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>在前段时间的工作中，我遇到了一个在桌面端和移动端进行图文混排编辑的需求。虽然如果只需要编辑纯文本和图片，不一定要使用富文本编辑器来实现。但是为了以后方便扩展，比如文本会有样式要求，我还是用 Draft.js 实现了一个功能较基础的富文本编辑器。</p><p>我将代码开源在了<a href="https://github.com/noiron/draft-editor">这个项目 draft-editor</a> 中，也可以<a href="http://www.wukai.me/draft-editor/">在这里在线预览</a>。本文中我将介绍一下一些关于 Draft.js 的基础知识，并由此扩展到如何在 Draft.js 编辑器中插入图片功能的实现。</p><span id="more"></span><h2 id="从一个基本的编辑器开始"><a href="#从一个基本的编辑器开始" class="headerlink" title="从一个基本的编辑器开始"></a>从一个基本的编辑器开始</h2><p>Draft.js 是 Facebook 推出的用于 React 的富文本编辑器框架，初始化一个最基本的 Draft.js 的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> ‘react’;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> ‘react-dom’;</span><br><span class="line"><span class="keyword">import</span> &#123;Editor, EditorState&#125; <span class="keyword">from</span> ‘draft-js’;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEditor</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">editorState</span>: EditorState.createEmpty()&#125;;</span><br><span class="line">    <span class="built_in">this</span>.onChange = <span class="function">(<span class="params">editorState</span>) =&gt;</span> <span class="built_in">this</span>.setState(&#123;editorState&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Editor</span> <span class="attr">editorState</span>=<span class="string">&#123;this.state.editorState&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.onChange&#125;</span> /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以<a href="https://codesandbox.io/s/basic-draft-editor-gzver">在这里查看</a>。这里给 <code>Editor</code> 传入一个 <code>editorState</code> 属性，并绑定一个 <code>onChange</code>事件，当发生编辑操作时，返回一个新的 <code>editorState</code>。这样我们就得到了一个可以进行基本的文本操作的编辑器了。</p><h2 id="Immutable-js-数据结构"><a href="#Immutable-js-数据结构" class="headerlink" title="Immutable.js 数据结构"></a>Immutable.js 数据结构</h2><p>在说明什么是 <code>EditorState</code> 及 Draft.js 对于数据的存储方式之前，需要简略介绍一下 <strong>Immutables.js</strong>。</p><p>Draft.js 是利用 <a href="https://github.com/immutable-js/immutable-js">Immutable.js</a>来保存数据的，正如其名，这是一种不可变的数据结构。对于一个 Immutable 的对象，你无法修改它本身，若想修改其值，只会返回一个新的修改后的对象。将这一点应用在编辑器上，用户的每一次修改都会生成一个最新的状态快照，就很容易实现撤销功能了。</p><p>在 Draft.js 的使用过程中，可能会遇到下面这些数据结构。</p><p><strong><code>Map</code></strong> 类似于 js 中的对象，用 <code>.set()</code> 和 <code>.get()</code> 方法进行写和读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Immutable = require(‘immutable’);</span><br><span class="line">const framework = Immutable.Map(&#123; name: &#x27;React&#x27;, age: 6 &#125;);</span><br><span class="line">const newFramework = client.set(&#x27;name&#x27;, &#x27;Vue&#x27;);</span><br><span class="line">console.log(framework.get(&#x27;name&#x27;));</span><br></pre></td></tr></table></figure><p><strong><code>OrderedMap</code></strong> 混合了 <code>object</code> 和 <code>array</code> 的特点。通过使用 <code>orderedMap.get(‘key’)</code> 和<br><code>orderedMap.set(‘key’, newValue)</code> 这两个方法，可以将它当成一个普通的 <code>object</code> 来使用。但和 <code>Map</code> 的不同点在于其中的 key 是按照被加入时的顺序排序的。</p><p><strong><code>Record</code></strong> 也类似于 <code>Map</code>，但有一些不同之处。</p><ul><li>一个 <code>record</code> 一旦被初始化，就不能再添加新的 key 了</li><li>你可以给一个 <code>record</code> 实例添加默认值</li></ul><p>还有一点，immutable 的对象，提供了 <code>toJS()</code>方法，可将其转成普通的 js 对象，这一方法在想查看其内部内容时非常有用。</p><blockquote><p>Immutable.js 参考文章：<a href="https://blog.jscrambler.com/immutable-data-immutable-js/">Immutable Data with Immutable.js | Jscrambler Blog</a></p></blockquote><h2 id="Draft-是如何存储数据的"><a href="#Draft-是如何存储数据的" class="headerlink" title="Draft 是如何存储数据的"></a>Draft 是如何存储数据的</h2><h3 id="什么是-EditorState"><a href="#什么是-EditorState" class="headerlink" title="什么是 EditorState"></a>什么是 EditorState</h3><p>在创建基本的编辑器的时候，我们用到了 <code>EditorState</code>。  <code>EditorState</code> 是编辑器最顶层的状态对象，它是一个 Immutable Record  对象，保存了编辑器中全部的状态信息，包括文本状态、选中状态等。</p><p>调用  <code>editorState.toJS()</code> 可将 immutable record 转换成一个普通的 object，打印出来如下：<br><img src="/asset/images/2019-07-21-draft-editor-01.png" alt=""></p><p>简单地来看下其中的部分内容：</p><ul><li><code>currentContent</code> 是一个 <code>ContentState</code> 对象，存放的是当前编辑器中的内容</li><li><code>selection</code> 中是当前选中的状态</li><li><code>redoStack</code> 和 <code>undoStack</code> 就是撤销/重做栈，它是一个数组，存放的是 <code>ContentState</code> 类型的编辑器状态</li><li><code>decorator</code> 会寻找特定的模式，并用特定的组件渲染出来</li></ul><h3 id="什么是-ContentState"><a href="#什么是-ContentState" class="headerlink" title="什么是 ContentState"></a>什么是 ContentState</h3><p>既然编辑器中的内容是存储在一个 <code>ContentState</code> 对象中，那么这个 <code>ContentState</code> 又是什么？</p><p><code>ContentState</code> 也是一个 Immutable Record 对象，其中保存了编辑器里的全部内容和渲染前后的两个选中状态。可以通过 <code>EditorState.getCurrentContent()</code> 来获取当前的 <code>ContentState</code>，同样调用 <code>.toJS()</code> 后将它打印出来看下：<br><img src="/asset/images/2019-07-21-draft-editor-02.png" alt=""></p><p><code>blockMap</code> 和 <code>entityMap</code> 里放置的就是编辑器中的 <code>block</code> 和 <code>entity</code>，它们是构建 Draft 编辑器的砖瓦。</p><h3 id="什么是-ContentBlock-和-Entity"><a href="#什么是-ContentBlock-和-Entity" class="headerlink" title="什么是 ContentBlock 和 Entity"></a>什么是 ContentBlock 和 Entity</h3><p>一个 <code>ContentBlock</code> 表示一个编辑器内容中的一个独立的 block，即视觉上独立的一块。 </p><p>以下图的编辑器作为一个例子，图中的四个红框标出的部分都是 block。在平时阅读文章时，内容是以段落为单位的，在编辑器中每个段落就是一个 block，如第一个和最后一个红框中的文字内容。第二个红框中是一张图片，它也是一个 block，但显示方式不同于普通的 block，为了自定义它的显示方式还需要额外做一些工作，后面会加以详细说明。</p><p>还有一点需要稍作说明，第三个红框中虽然是空白，但它也是一个 block，只不过其中的文本为空而已。<br><img src="/asset/images/2019-07-21-draft-editor-03.png" alt=""></p><p>此时，输出一下 <code>convertToRaw(currentContent)</code> ，看看其中的内容。注意这里的输出结构与上面的 <code>currentContent.toJS()</code> 略有所区别，这里只有 <code>blocks</code> 和 <code>entityMap</code> 这两项。<br><img src="/asset/images/2019-07-21-draft-editor-04.png" alt=""><br>可以看到 <code>blocks</code> 这个数组中依次存放了各个 <code>block</code> 的信息，每一个 <code>block</code> 都是一个 <code>contentBlock</code> 对象。</p><p>每个 <code>contentBlock</code> 都有如下的几个属性值：</p><ul><li><code>key</code>: 标识出这是哪一个 block</li><li><code>type</code>: 这是何种类型的 block</li><li><code>text</code>: 其中的文字</li><li>……</li></ul><p>Draft.js 中  <code>block</code> 的 <code>type</code> 有 unstyled，paragraph，header-one，atomic …… 等值，在 Draft.js 的文档中 <code>atomic</code> 类型对应的是 <code>&lt;figure /&gt;</code> 元素，我们也选取了它来实现插入图片的功能。</p><p> 图中的这些 block 的除了第三个 key = “1u22q” 的 block 的 type 值是 <code>atomic</code> 外，其余的值都是 <code>“unstyled”</code>。再仔细看下这个 <code>atomic</code> 类型的 block：<br><img src="/asset/images/2019-07-21-draft-editor-05.png" alt=""></p><p>除了 <code>key</code>，<code>text</code>，<code>type</code> 等值之外，在 <code>entityRanges</code> 这一项中保存它保存了使用到的 <code>entity</code> 的信息：offset 和 length 确定了 <code>entity</code> 在 block 中的范围，而 key 则能让我们去取出对应的 <code>entity</code>。</p><p>回到上面的打印出的 <code>contentState</code>的内容，除了  <code>blocks</code> 数组外还有一个 <code>entityMap</code>对象。它是以 <code>entity</code> 的 <code>key</code> 作为键值的对象，里面保存了图片、链接等种类的 <code>entity</code> 信息，从中就可获得 <code>blocks</code> 所需要的 <code>entity</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entityMap: &#123;</span><br><span class="line"><span class="number">0</span>: &#123; <span class="attr">type</span>: <span class="string">&quot;image&quot;</span>, <span class="attr">mutability</span>: <span class="string">&quot;IMUTABLE&quot;</span>, <span class="attr">data</span>: &#123;&#125; &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>以上介绍了 Draft.js 是如何对编辑器中的数据进行存储的，接下来会从代码实现的角度来说明插入图片是如何实现的。</p><h2 id="插入图片的实现"><a href="#插入图片的实现" class="headerlink" title="插入图片的实现"></a>插入图片的实现</h2><h3 id="如何插入图片"><a href="#如何插入图片" class="headerlink" title="如何插入图片"></a>如何插入图片</h3><p>插入图片有着这样的流程：首先为图片创建一个 <code>entity</code>，然后创建一个带有这个 <code>entity</code> 的新 <code>EditorState</code>，然后更新即可。以下是关键部分的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AtomicBlockUtils &#125; <span class="keyword">from</span> <span class="string">&#x27;draft.js&#x27;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> editorState = <span class="built_in">this</span>.state.editorState;</span><br><span class="line"><span class="keyword">const</span> contentState = editorState.getCurrentContent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `contentState.createEntity` 创建一个 `entity`，指定其 `type` 为 `image`</span></span><br><span class="line"><span class="keyword">const</span> contentStateWithEntity = contentState.createEntity(</span><br><span class="line">  ‘image’,</span><br><span class="line">  ‘IMMUTABLE’,</span><br><span class="line">  &#123; src &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取新创建的 `entity` 的 key</span></span><br><span class="line"><span class="keyword">const</span> entityKey = contentStateWithEntity.getLastCreatedEntityKey();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 `EditorState.set()`  来建立一个带有这个 `entity` 的新的 EditorState </span></span><br><span class="line"><span class="keyword">const</span> newEditorState = EditorState.set(</span><br><span class="line">  editorState,</span><br><span class="line">  &#123; <span class="attr">currentContent</span>: contentStateWithEntity &#125;,</span><br><span class="line">  ‘create-entity’</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用`AtomicBlockUtils.insertAtomicBlock` 来插入一个新的 `block`</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  <span class="attr">editorState</span>: AtomicBlockUtils.insertAtomicBlock(newEditorState, entityKey, ‘ ‘)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="如何使用-blockRendererFn-来渲染图片"><a href="#如何使用-blockRendererFn-来渲染图片" class="headerlink" title="如何使用 blockRendererFn 来渲染图片"></a>如何使用 blockRendererFn 来渲染图片</h3><p>上面我们已经见到了，一张图片是作为一个 <code>atomic</code> 类型的 block 插入的。Draft.js 提供了<code>blockRendererFn</code> 让我们可以自定义 <code>ContentBlock</code> 的渲染方式，给它传入一个函数后，由该函数来判断这个 block 的 <code>type</code> 是什么，然后决定如何渲染。</p><p>以下的这段代码来自 <a href="https://draftjs.org/docs/advanced-topics-block-components">Draft.js 的官方文档</a>，展示了如何处理一个  type 为 <code>atomic</code> 的 <code>ContentBlock</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBlockRenderer</span>(<span class="params">contentBlock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = contentBlock.getType();</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;atomic&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">component</span>: MediaComponent,</span><br><span class="line">      <span class="attr">editable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then...</span></span><br><span class="line"><span class="keyword">import</span> &#123;Editor&#125; <span class="keyword">from</span> <span class="string">&#x27;draft-js&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorWithMedia</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Editor</span> <span class="attr">...</span> <span class="attr">blockRendererFn</span>=<span class="string">&#123;myBlockRenderer&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里传递了一个 <code>props</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">component: MediaComponent,</span><br><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>结果等同于 <code>&lt;MediaComponent foo=&#39;bar&#39; /&gt;</code>，可以利用这里的 <code>props</code> 传入所需要的其他数据。</p><p>这里我们就可以定义一个自己的 <code>MediaComponent</code> 来决定展现方式。因为不管是图片还是视频等其它的媒体类型，它们的 <code>type</code> 都是 <code>atomic</code>。在 <code>MediaComponent</code> 里就需要通过 <code>entity</code> 的 <code>type</code> 来确定其种类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> entity = props.contentState.getEntity(props.block.getEntityAt(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">const</span> &#123; src &#125; = entity.getData();<span class="comment">// 取出图片的地址</span></span><br><span class="line"><span class="keyword">const</span> type = entity.getType();  <span class="comment">// 判断 entity 的 type 的</span></span><br></pre></td></tr></table></figure><p>当 <code>entity</code> 的 <code>type</code> 是我们自定义的 <code>image</code> 时就可以返回 <code>&lt;Image /&gt;</code> 组件了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Image src=&#123;src&#125; /&gt; <span class="comment">// 自定义的图片组件 &lt;Image /&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/noiron/draft-editor/blob/master/src/components/entities/mediaBlockRenderer.js">完整代码可见此文件</a></p><h3 id="如何删除一张图片"><a href="#如何删除一张图片" class="headerlink" title="如何删除一张图片"></a>如何删除一张图片</h3><p>既然已经插入了图片，那么如何删除它呢？当然我们可以按键盘上的 Backspace 键来删除。也可以在图片的右上角加入一个 “X” 的图标，点击后删除该图片，实现方式如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">deleteImage = <span class="function">(<span class="params">block</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> editorState = <span class="built_in">this</span>.state.editorState;</span><br><span class="line">  <span class="keyword">const</span> contentState = editorState.getCurrentContent();</span><br><span class="line">  <span class="keyword">const</span> key = block.getKey();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> selection = editorState.getSelection();</span><br><span class="line">  <span class="keyword">const</span> selectionOfAtomicBlock = selection.merge(&#123;</span><br><span class="line">    <span class="attr">anchorKey</span>: key,</span><br><span class="line">    <span class="attr">anchorOffset</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">focusKey</span>: key,</span><br><span class="line">    <span class="attr">focusOffset</span>: block.getLength(),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写 entity 数据，将其从 block 中移除，防止这个 entity 还被其它的 block 引用</span></span><br><span class="line">  <span class="keyword">const</span> contentStateWithoutEntity = Modifier.applyEntity(contentState, selectionOfAtomicBlock, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> editorStateWithoutEntity = EditorState.push(editorState, contentStateWithoutEntity, ‘apply-entity’);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除 block</span></span><br><span class="line">  <span class="keyword">const</span> contentStateWithoutBlock = Modifier.removeRange(contentStateWithoutEntity, selectionOfAtomicBlock, ‘backward’);</span><br><span class="line">  <span class="keyword">const</span> newEditorState =  EditorState.push(editorStateWithoutEntity, contentStateWithoutBlock, ‘remove-range’,);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.onChange(newEditorState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，对图片的相关操作就完成了。</p><h2 id="总结与其他"><a href="#总结与其他" class="headerlink" title="总结与其他"></a>总结与其他</h2><p>在本文中，介绍了 Draft.js 的基本功能，它是如何进行数据的存储的，及 <code>EditorState</code>、<code>ContentState</code>、<code>ContentBlock</code>、<code>Entity</code> 等对象间的关系。并以此为基础说明了如何在编辑器中对图片进行操作。</p><p>当然关于 Draft.js 还有很多内容没有在本文中提及，如修改行内文本的样式，利用 <code>decorators</code> 来插入与渲染链接等等。这些就需要读者探索下 Draft.js 的官方文档和其他人的分享并亲自尝试下了。</p><h2 id="参考文章及资源"><a href="#参考文章及资源" class="headerlink" title="参考文章及资源"></a>参考文章及资源</h2><blockquote><p><a href="https://github.com/noiron/draft-editor">本文所基于的编辑器项目：draft-editor</a></p></blockquote><blockquote><p><a href="https://medium.com/@rajaraodv/how-draft-js-represents-rich-text-data-eeabb5f25cf2#.q7vpkxmog">How Draft.js Represents Rich Text Data</a><br><a href="https://medium.com/@siobhanpmahoney/building-a-rich-text-editor-with-react-and-draft-js-part-2-4-persisting-data-to-server-cd68e81c820">Building a Rich Text Editor with React and Draft.js, Part 2.4: Embedding Images</a><br><a href="https://zhuanlan.zhihu.com/p/24951621">Draft.js 在知乎的实践</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前段时间的工作中，我遇到了一个在桌面端和移动端进行图文混排编辑的需求。虽然如果只需要编辑纯文本和图片，不一定要使用富文本编辑器来实现。但是为了以后方便扩展，比如文本会有样式要求，我还是用 Draft.js 实现了一个功能较基础的富文本编辑器。&lt;/p&gt;
&lt;p&gt;我将代码开源在了&lt;a href=&quot;https://github.com/noiron/draft-editor&quot;&gt;这个项目 draft-editor&lt;/a&gt; 中，也可以&lt;a href=&quot;http://www.wukai.me/draft-editor/&quot;&gt;在这里在线预览&lt;/a&gt;。本文中我将介绍一下一些关于 Draft.js 的基础知识，并由此扩展到如何在 Draft.js 编辑器中插入图片功能的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编辑器" scheme="http://www.wukai.me/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="draft.js" scheme="http://www.wukai.me/tags/draft-js/"/>
    
  </entry>
  
  <entry>
    <title>2018年总结</title>
    <link href="http://www.wukai.me/2019/01/01/2018-annual-summary/"/>
    <id>http://www.wukai.me/2019/01/01/2018-annual-summary/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>到了2018年快要结束的时候，才发现这一年什么也没做啊😂，上一篇博客还是3月份写的。感觉做这个总结就是在提醒自己荒废了一年，虽然不想这么做，但还是来写点什么吧。</p><span id="more"></span><p>今年做的最重要的事应该是换了份工作吧，也换了座城市，4月份从南京来到了上海。</p><p>来到了更大的公司，见识了不同的工作流程，比起以前只有几个开发的小公司正规了不少。工作比以前更忙了些，也尝试了一些新的技术，大部分还是浅尝辄止。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>今年在一个工作项目中第一次使用了 React Native 开发，了解了RN的一点皮毛，体会了下多端融合开发。</p><p>今年的开发中碰到了不少移动端的兼容性问题，要考虑页面在各种手机、APP、各种版本的 webview 中打开的情况，有了一些零散的经验。</p><p>似乎没有正经地看什么技术书籍。</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>看的新书没有多少，倒是在空闲时又翻了翻以前看过的书作为消遣。</p><h3 id="小说类"><a href="#小说类" class="headerlink" title="小说类"></a>小说类</h3><ul><li>搏击俱乐部</li><li>基督山伯爵（小学时看过简写本，今年才看完全本）</li><li>占星术杀人魔法</li><li>哈利的十五次人生 </li><li>它</li><li>死了七次的男人</li><li>射雕英雄传（国庆节假期时重温了一遍，没想到没多久金庸就去世了）</li></ul><h3 id="自然科学类"><a href="#自然科学类" class="headerlink" title="自然科学类"></a>自然科学类</h3><p>看了两本科普的小册子，还有《费曼物理学讲义》只看了十章</p><ul><li>七堂极简物理课</li><li>宇宙的最后三分钟</li></ul><h3 id="人文类"><a href="#人文类" class="headerlink" title="人文类"></a>人文类</h3><ul><li>他改变了中国（曰_曰）</li><li>南明史 上</li></ul><h3 id="英语原著类"><a href="#英语原著类" class="headerlink" title="英语原著类"></a>英语原著类</h3><ul><li>Harry Potter and the Order of the Phoenix（把17年剩的半本看完了）</li><li>The Old Man and the Sea</li></ul><p>哦，还有把45卷的《哆啦A梦》漫画作为睡前读物看完了（上一次看哆啦A梦漫画的时候是十几年前名字还叫做机器猫小叮当）。</p><h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><p>今年可以算是没怎么运动过吧，一共跑了20次，102.5公里。如果给自己找个借口，就是周围的环境太差，没有跑步的想法。还是承认自己太懒算了。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p>去电影院看了10部电影，4部国产，6部国外。仍然看了很多连名字也记不起的影视剧。</p><hr><p>反思2018年，应该是花了太多的时间在网上看各种段子和无聊图吧，导致脑子里装满了各种烂梗，挤占了留给技术的地方╮(╯_╰)╭。</p><p>2019年应该多花点时间在看书上，包括技术书和其他类型的书。</p><p>再见，2018。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到了2018年快要结束的时候，才发现这一年什么也没做啊😂，上一篇博客还是3月份写的。感觉做这个总结就是在提醒自己荒废了一年，虽然不想这么做，但还是来写点什么吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="年度总结" scheme="http://www.wukai.me/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Minimax 和 Alpha-beta 剪枝算法简介，及以此实现的井字棋游戏（Tic-tac-toe）</title>
    <link href="http://www.wukai.me/2018/03/04/minimax-alpha-beta-pruning-and-tic-tac-toe/"/>
    <id>http://www.wukai.me/2018/03/04/minimax-alpha-beta-pruning-and-tic-tac-toe/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间用 React 写了个<a href="https://github.com/noiron/react-2048">2048 游戏</a>来练练手，准备用来回顾下 React 相关的各种技术，以及试验一下新技术。在写这个2048的过程中，我考虑是否可以在其中加入一个 AI 算法来自动进行游戏，于是我找到了这篇文章：<a href="http://blog.codinglabs.org/articles/2048-ai-analysis.html">2048-AI程序算法分析</a>，文中介绍了 minimax 算法和 alpha-beta 剪枝算法。于是我决定先学习下这两种算法，并以此写了这个 tic-tac-toe 游戏：<a href="https://tic-tac-toe-js-app.herokuapp.com/">tic-tac-toe-js</a>（<a href="https://github.com/noiron/tic-tac-toe-js">代码见此处</a>）。本文将说明如何用 JavaScript 来简单地实现算法，并将其运用到 tic-tac-toe 游戏中。</p><span id="more"></span><h2 id="Minimax-算法简介"><a href="#Minimax-算法简介" class="headerlink" title="Minimax 算法简介"></a>Minimax 算法简介</h2><p>我觉得要解释 minimax 算法的原理，需要用示意图来解释更清晰，以下的几篇文章都对原理说的足够清楚。</p><blockquote><ol><li><a href="http://blog.codinglabs.org/articles/2048-ai-analysis.html">2048-AI程序算法分析</a></li><li><a href="https://www.neverstopbuilding.com/blog/2013/12/13/tic-tac-toe-understanding-the-minimax-algorithm13/">Tic Tac Toe: Understanding the Minimax Algorithm</a></li><li><a href="http://www.flyingmachinestudios.com/programming/minimax/">An Exhaustive Explanation of Minimax, a Staple AI Algorithm</a></li></ol></blockquote><p>其中后面的两篇文章都是以 tic-tac-toe 游戏为例，并用 Ruby 实现。</p><p>以棋类游戏为例来说明 minimax 算法，每一个棋盘的状态都会对应一个分数。双方将会轮流下棋。轮到我方下子时，我会选择分数最高的状态；而对方会选择对我最不利的状态。可以这么认为，每次我都需要从对手给我选择的最差（min）局面中选出最好（max）的一个，这就是这个算法名称 <strong>minimax</strong> 的意义。</p><p><img src="/asset/images/2018-03-04-data-tree.png" alt="minimax tree"><br>（图片来自于 <a href="http://web.cs.ucla.edu/~rosen/161/notes/alphabeta.html）">http://web.cs.ucla.edu/~rosen/161/notes/alphabeta.html）</a></p><p>我们接下来会解决这样一个问题，如上图所示，正方形的节点对应于我的决策，圆形的节点是对手的决策。双方轮流选择一个分支，我的目标是让最后选出的数字尽可能大，对方的目标是让这个数字尽可能小。</p><h2 id="Minimax-算法的实现"><a href="#Minimax-算法的实现" class="headerlink" title="Minimax 算法的实现"></a>Minimax 算法的实现</h2><p>为了简单起见，对于这个特定的问题，我用了一个嵌套的数组来表示状态树。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataTree = [</span><br><span class="line">    [</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">3</span>, <span class="number">17</span>], [<span class="number">2</span>, <span class="number">12</span>]</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">15</span>], [<span class="number">25</span>, <span class="number">0</span>]</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">3</span>]</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">2</span>, <span class="number">14</span>]</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>图中的节点分为两种类型：</p><ol><li><strong>Max 节点</strong>：图中的正方形节点，对应于我的回合，它会选取所有子节点中的最大值作为自身的值</li><li><strong>Min 节点</strong>：图中的圆形节点，对应于对手的回合，它会选取所有子节点中的最小值作为自身的值</li></ol><p>先定义一个 <code>Node</code> 类，<code>constructor</code> 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">data, type, depth</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">    <span class="built_in">this</span>.type = type; <span class="comment">// 区分此节点的种类是 max 或 min</span></span><br><span class="line">    <span class="built_in">this</span>.depth = depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根节点的 <code>depth</code> 为0，以下的每一层 <code>depth</code> 依次加一。最底层的节点 <code>depth</code> 为4，其 <code>data</code> 是写在图中的数字，其它层节点的 <code>data</code> 均是一个数组。</p><p>接下来考虑如何给每个节点打分，可能会出现这样的几种情况：</p><ol><li>最底层的节点，直接返回本身的数字</li><li>中间层的 max 节点，返回子节点中的最大分数</li><li>中间层的 min 节点，返回子节点中的最小分数</li></ol><p>为方便描述，我们按照由上到下、由左到右的顺序给图中节点进行标号。节点1是 max 节点，从节点2和节点3中选择较大值；而对于节点2来说，需要从节点4，5中选取较小值。很显然，我们这里要用递归的方法来实现，当搜索到最底层的节点时，递归过程开始返回。</p><p><img src="/asset/images/2018-03-04-data-tree-mark.png" alt="minimax tree mark"></p><p>以下是打分函数 <code>score</code> 的具体代码： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">score</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 到达了最大深度后，此时的 data 是数组最内层的数字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.depth &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 max 节点，返回的是子节点中的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.type === <span class="string">&#x27;max&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxScore = -<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> d = <span class="built_in">this</span>.data[i];</span><br><span class="line">            <span class="comment">// 生成新的节点，子节点的 type 会和父节点不同</span></span><br><span class="line">            <span class="keyword">const</span> childNode = <span class="keyword">new</span> Node(d, changeType(<span class="built_in">this</span>.type), <span class="built_in">this</span>.depth + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归获取其分数</span></span><br><span class="line">            <span class="keyword">const</span> childScore = childNode.score();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (childScore &gt; maxScore) &#123;</span><br><span class="line">                maxScore = childScore;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxScore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 min 节点，返回的是子节点中的最小值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.type === <span class="string">&#x27;min&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 与上方代码相似，省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/noiron/tic-tac-toe-js/blob/master/algorithms/minimax.js">完整的 minimax 算法代码</a> </p></blockquote><h2 id="Alpha-beta-剪枝算法简介"><a href="#Alpha-beta-剪枝算法简介" class="headerlink" title="Alpha-beta 剪枝算法简介"></a>Alpha-beta 剪枝算法简介</h2><p>Alpha-beta 剪枝算法可以认为是 minimax 算法的一种改进，在实际的问题中，需要搜索的状态数量将会非常庞大，利用 alpha-beta 剪枝算法可以去除一些不必要的搜索。</p><p>关于 alpha-beta 算法的具体解释可以看这篇文章 <a href="http://web.cs.ucla.edu/~rosen/161/notes/alphabeta.html">Minimax with Alpha Beta Pruning</a>。我们在前文中考虑的那张图就来自这篇文章，之后我们会用 alpha-beta 剪枝算法来改进之前的解决方案。</p><p>剪枝算法中主要有这么些概念：</p><p>每一个节点都会由 alpha 和 beta 两个值来确定一个范围 [alpha, beta]，alpha 值代表的是下界，beta 代表的是上界。每搜索一个子节点，都会按规则对范围进行修正。</p><p>Max 节点可以修改 alpha 值，min 节点修改 beta 值。</p><p>如果出现了 beta &lt;= alpha 的情况，则不用搜索更多的子树了，未搜索的这部分子树将被忽略，这个操作就被称作<strong>剪枝（pruning）</strong>。</p><p>接下来我会尽量说明为什么剪枝这个操作是合理的，省略了一部分节点为什么不会对结果产生影响。用原图中以4号节点（第三层的第一个节点）为根节点的子树来举例，方便描述这里将他们用 A - G 的字母来重新标记。</p><p><img src="/asset/images/2018-03-04-subtree.png" alt="子树"></p><p>从 B 节点看起，B 是 min 节点，需要在 D 和 E 中寻找较小值，因此 B 取值为3，同时 B 的 beta 值也设置为 3。假设 B 还有更多值大于3的子节点，但因为已经出现了 D 这个最小值，所以不会对 B 产生影响，即这里的 beta = 3 确定了一个上界。</p><p>A 是 max 节点，需要在 B 和 C 中找到较大值，因为子树 B 已经搜索完毕，B 的值确定为 3，所以 A 的值至少为 3，这样确定了 A 的下界 alpha = 3。在搜索 C 子树之前，我们<strong>希望 C 的值大于3</strong>，这样才会对 A 的下界 alpha 产生影响。于是 C 从 A 这里获得了下界 alpha = 3 这个限制条件。</p><p>C 是 min 节点，要从 F 和 G 里找出较小值。F 的值为2，所以 C 的值一定小于等于 2，更新 C 的上界 beta = 2。此时 C 的 alpha = 3, beta = 2，这是一个空区间，也就是说即使继续考虑 C 的其它子节点， 也<strong>不可能让 C 的值大于 3</strong>，所以我们不必再考虑 G 节点。G 节点就是被剪枝的节点。</p><p>重复这样的过程，会有更多的节点因为剪枝操作被忽略，从而对 minimax 算法进行了优化。</p><h2 id="Alpha-beta-剪枝算法的实现"><a href="#Alpha-beta-剪枝算法的实现" class="headerlink" title="Alpha-beta 剪枝算法的实现"></a>Alpha-beta 剪枝算法的实现</h2><p>接下来讨论如何修改前面实现的 minimax 算法，使其变为 alpha-beta 剪枝算法。</p><p>第一步在 constructor 中加入两个新属性，alpha、beta。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">data, type, depth, alpha, beta</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">    <span class="built_in">this</span>.type = type; <span class="comment">// 区分此节点的种类是 max 或 min</span></span><br><span class="line">    <span class="built_in">this</span>.depth = depth;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.alpha = alpha || -<span class="literal">Infinity</span>;</span><br><span class="line">    <span class="built_in">this</span>.beta = beta || <span class="literal">Infinity</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后每次都搜索会视情况更新 alpha, beta 的值，以下的代码片段来自于搜索 max 节点的过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alphabeta.js 中的 score() 函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.data.length; i++) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childScore &gt; maxScore) &#123;</span><br><span class="line">        maxScore = childScore;</span><br><span class="line">        <span class="comment">// 相对于 minimax 算法，alpha-beta 剪枝算法在这里增加了一个更新 alpha 值的操作</span></span><br><span class="line">        <span class="built_in">this</span>.alpha = maxScore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果满足了退出的条件，我们不需要继续搜索更多的节点了，退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.alpha &gt;= <span class="built_in">this</span>.beta) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>相对应的是在 min 节点中，我们更新的将是 beta 值。好了，只需要做这么些简单的改变，就将 minimax 算法改变成了 alpha-beta 剪枝算法了。</p><p>最后看看如何将算法应用到 tic-tac-toe 游戏中。</p><blockquote><p><a href="https://github.com/noiron/tic-tac-toe-js/blob/master/algorithms/alphabeta.js">完整的 alpha-beta 剪枝算法代码</a> </p></blockquote><h2 id="Tic-tac-toe-游戏中的应用"><a href="#Tic-tac-toe-游戏中的应用" class="headerlink" title="Tic-tac-toe 游戏中的应用"></a>Tic-tac-toe 游戏中的应用</h2><p>Tic-tac-toe，即井字棋游戏，规则是在双方轮流在 3x3 的棋盘上的任意位置下子，率先将三子连成一线的一方获胜。</p><p>这就是一个非常适合用 minimax 来解决的问题，即使在不考虑对称的情况，所有的游戏状态也只有 9! = 362880 种，相比于其它棋类游戏天文数字般的状态数量已经很少了，因而很适合作为算法的示例。</p><p>我在代码中将棋盘的状态用一个长度为9的数组来表示，然后利用 canvas 绘制出一个简易的棋盘，下子的过程就是修改数组的对应位置然后重绘画面。</p><p>现在我们已经有了现成的 minimax 和 alpha-beta 剪枝算法，只要加上一点儿细节就能完成这个游戏了😀。</p><p>先来定义一个 <code>GameState</code> 类，其中保存了游戏的状态，对应于之前分析过程中的节点，其 <code>constructor</code> 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">board, player, depth, alpha, beta</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.board = board;</span><br><span class="line">    <span class="comment">// player 是用字符 X 和 O 来标记当前由谁下子，以此来判断当前是 max 还是 min 节点</span></span><br><span class="line">    <span class="built_in">this</span>.playerTurn = player;</span><br><span class="line">    <span class="built_in">this</span>.depth = depth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存分数最高或最低的状态，用于确定下一步的棋盘状态</span></span><br><span class="line">    <span class="built_in">this</span>.choosenState = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.alpha = alpha || -<span class="literal">Infinity</span>;</span><br><span class="line">    <span class="built_in">this</span>.beta = beta || <span class="literal">Infinity</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为进行游戏，首先需要一个 <code>checkFinish</code> 函数，检查游戏是否结束，结束时返回胜利者信息。搜索的过程是在 <code>getScore</code> 函数中完成的，每次搜索先检查游戏是否结束，平局返回零分，我们的算法是站在 AI 的角度来考虑的，因此 AI 胜利时返回10分，AI 失利时返回-10分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alphabeta.js 中的 getScore() 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winner = <span class="built_in">this</span>.checkFinish();</span><br><span class="line"><span class="keyword">if</span> (winner) &#123;</span><br><span class="line">    <span class="keyword">if</span> (winner === <span class="string">&#x27;draw&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (winner === aiToken) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是对 max 和 min 节点的分类处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alphabeta.js 中的 getScore() 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得所有可能的位置，利用 shuffle 加入随机性</span></span><br><span class="line"><span class="keyword">const</span> availablePos = _.shuffle(<span class="built_in">this</span>.getAvailablePos());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 max 节点，返回的是子节点中的最大值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.playerTurn === aiToken) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxScore = -<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">let</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; availablePos.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> pos = availablePos[i];</span><br><span class="line">        <span class="comment">// 在给定的位置下子，生成一个新的棋盘</span></span><br><span class="line">        <span class="keyword">const</span> newBoard = <span class="built_in">this</span>.generateNewBoard(pos, <span class="built_in">this</span>.playerTurn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个新的节点</span></span><br><span class="line">        <span class="keyword">const</span> childState = <span class="keyword">new</span> GameState(newBoard, changeTurn(<span class="built_in">this</span>.playerTurn), <span class="built_in">this</span>.depth + <span class="number">1</span>, <span class="built_in">this</span>.alpha, <span class="built_in">this</span>.beta);</span><br><span class="line">        <span class="comment">// 这里开始递归调用 getScore() 函数</span></span><br><span class="line">        <span class="keyword">const</span> childScore = childState.getScore();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (childScore &gt; maxScore) &#123;</span><br><span class="line">            maxScore = childScore;</span><br><span class="line">            maxIndex = i;</span><br><span class="line">            <span class="comment">// 这里保存产生了最大的分数的节点，之后会被用于进行下一步</span></span><br><span class="line">            <span class="built_in">this</span>.choosenState = childState;</span><br><span class="line">            <span class="built_in">this</span>.alpha = maxScore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.alpha &gt;= <span class="built_in">this</span>.beta) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxScore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// min 节点的处理与上面类似</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>完整代码见<a href="https://github.com/noiron/tic-tac-toe-js/blob/master/src/alphabeta.js">alphabeta.js</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样就简单地介绍了 minimax 算法和 alpha-beta 算法，并分别给出了一个简单的实现，然后在 tic-tac-toe 游戏中应用了算法。</p><p>文章中所提到的所有代码可见此项目：<a href="https://github.com/noiron/tic-tac-toe-js">Tic-tac-toe-js</a>。其中的 <code>algorithms</code> 文件夹中是两种算法的简单实现，<code>src</code> 文件中是游戏的代码。</p><p>文章开头说到了这篇文章起源于写2048游戏项目的过程中，之后我将 minimax 算法应用到了2048游戏的 AI 中，不过对于局面的评估函数尚不完善，现在 AI 只能勉强合成1024😢， 还有很大的改进空间。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间用 React 写了个&lt;a href=&quot;https://github.com/noiron/react-2048&quot;&gt;2048 游戏&lt;/a&gt;来练练手，准备用来回顾下 React 相关的各种技术，以及试验一下新技术。在写这个2048的过程中，我考虑是否可以在其中加入一个 AI 算法来自动进行游戏，于是我找到了这篇文章：&lt;a href=&quot;http://blog.codinglabs.org/articles/2048-ai-analysis.html&quot;&gt;2048-AI程序算法分析&lt;/a&gt;，文中介绍了 minimax 算法和 alpha-beta 剪枝算法。于是我决定先学习下这两种算法，并以此写了这个 tic-tac-toe 游戏：&lt;a href=&quot;https://tic-tac-toe-js-app.herokuapp.com/&quot;&gt;tic-tac-toe-js&lt;/a&gt;（&lt;a href=&quot;https://github.com/noiron/tic-tac-toe-js&quot;&gt;代码见此处&lt;/a&gt;）。本文将说明如何用 JavaScript 来简单地实现算法，并将其运用到 tic-tac-toe 游戏中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="minimax" scheme="http://www.wukai.me/tags/minimax/"/>
    
      <category term="alpha-beta pruning" scheme="http://www.wukai.me/tags/alpha-beta-pruning/"/>
    
      <category term="游戏" scheme="http://www.wukai.me/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="算法" scheme="http://www.wukai.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2017年总结</title>
    <link href="http://www.wukai.me/2018/01/01/2017-annual-summary/"/>
    <id>http://www.wukai.me/2018/01/01/2017-annual-summary/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>活了二十多年，从来没有做过年终总结，但年岁渐长，总觉得有点时间的压力，应该记录点什么，就让2017年的总结作为第一次。</p><span id="more"></span><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>技术方面，继续写了一年的 React，还试着用了下 Vue，学了许多前端库，但是却没有什么完整的项目。</p><p>写了一个塔防游戏，待改的 Bug 比待实现的 feature 多，等着 2018 继续完善。</p><p>在 Coursera 上听了算法课，最后一周的作业没交，所以课程也没完成。</p><p>非前端的技术方面，看了本《C程序设计语言》，《深入理解计算机系统》只看到第二章，《Algorithms》也依旧没看完。重新开始学习线性代数了。</p><p>前端的书也没看多少，大多数情况下都在网上看资料。记得的书只有《你不知道的 JavaScript（上）》和《深入理解 ES6》。</p><p>总的来说，技术水平比起2016年有一点长进，但是也没有什么量化的指标，只是 JavaScript 写的更熟练了。唯一有所记录的是2017年在这里写了7篇博客，无论质量如何，聊胜于无。</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>读书方面，因为从来不会去数自己读了多少本。只能去翻翻订单记录和在豆瓣上的标记，除去技术类的书籍外，看了以下书籍：</p><ul><li>科幻书籍：《盲视》《让时间停止的女孩》《基地系列七部曲》（补上了后面几本）</li><li>三本村上春树：《没有色彩的多崎作和他的巡礼之年》《奇鸟形状录》《东京奇谭集》</li><li>三本伊坂幸太郎：《摩登时代》《魔王》《死神的精确度》</li><li>古龙的《小李飞刀：多情剑客无情剑》和《欢乐英雄》</li><li>苏童的《武则天》</li><li>莫言的《檀香刑》</li><li>马尔克斯的《一桩事先张扬的凶杀案》</li><li>燕垒生的《天行健》全集</li><li>罗斯·特里尔的《毛泽东传》</li><li>杨绛的《我们仨》</li><li>《亮剑》</li><li>《阿城精选集》</li><li>《易中天中华史》部分<br>大概就这些书了吧，还有一本哲学书《大问题》尚未翻完。</li></ul><p>想看英语原版书来着，不过还没找到什么感兴趣的，于是又去看哈利波特了：</p><ul><li>Holes</li><li>Hyperion （半本）</li><li>Harry Potter and the Sorcerer’s Stone</li><li>Harry Potter and the Chamber of Secrets</li><li>Harry Potter and the Prisoner of Azkaban</li><li>Harry Potter and the Goblet of Fire （目前为止看了46%）</li></ul><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p>17年去电影院看了12部电影，以《降临》为始，以《妖猫传》为终，其它电影不提也罢。至于各种乱七八糟的美剧、英剧、日剧，看了就忘，没有记录。</p><h2 id="锻炼"><a href="#锻炼" class="headerlink" title="锻炼"></a>锻炼</h2><p>17年每次跑步几乎都用悦跑圈做了记录，总的次数是43次，一共377公里，差不多一天一公里。</p><h2 id="其它的技能"><a href="#其它的技能" class="headerlink" title="其它的技能"></a>其它的技能</h2><p>上半年买了日语的教材，又一次停在了五十音图。</p><p>下半年买了把吉他，还在练习中，也许应该快要入门了吧。</p><hr><p>2017年大概就做了这些事吧。最后，新的一年已经来了，依旧是单身狗，没有变秃，也没有变强。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;活了二十多年，从来没有做过年终总结，但年岁渐长，总觉得有点时间的压力，应该记录点什么，就让2017年的总结作为第一次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="年度总结" scheme="http://www.wukai.me/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>不到200行 JavaScript 代码如何实现富文本编辑器</title>
    <link href="http://www.wukai.me/2017/12/31/rich-text-editor-in-less-than-200-lines-javascript/"/>
    <id>http://www.wukai.me/2017/12/31/rich-text-editor-in-less-than-200-lines-javascript/</id>
    <published>2017-12-30T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在寻找一些关于富文本编辑器的资料，然后发现了这个名为 <a href="https://github.com/jaredreich/pell">Pell</a> 的项目，它是一个所见即所得（WYSIWYG）的文本编辑器，虽然它的功能很简单，但是令人吃惊的是它只有 1kb 大小。而项目最核心的文件 <a href="https://github.com/jaredreich/pell/blob/master/src/pell.js">pell.js</a> 只有130行，即使加上其它部分，总的 js 数量也不到200行。这引起了我的兴趣，决定看看它的源码是如何做到这一点的。</p><span id="more"></span><p>项目的主要代码在 <code>pell.js</code> 文件中，其结构很简单，主要功能的实现依赖于以下的几个部分</p><ul><li><code>actions</code> 对象</li><li><code>exec()</code> 函数</li><li><code>init()</code> 函数</li></ul><h2 id="Document-execCommand"><a href="#Document-execCommand" class="headerlink" title="Document.execCommand()"></a>Document.execCommand()</h2><p>先从最简单的部分看起， <code>exec()</code> 函数只有下面三行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> exec = <span class="function">(<span class="params">command, value = <span class="literal">null</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.execCommand(command, <span class="literal">false</span>, value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它将 <code>document.execCommand()</code> 进行了一个简单的包装，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand">Document.execCommand()</a> 就是这个编辑器的核心，其语法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool = <span class="built_in">document</span>.execCommand(aCommandName, aShowDefaultUI, aValueArgument)</span><br></pre></td></tr></table></figure><ul><li><code>aCommandName</code> 是表示想执行的命令的字符串，比如：加粗 ‘bold’，创建链接 ‘createLink’，改变字体大小 ‘fontSize’ 等等</li><li><code>aShowDefaultUI</code> 是否显示默认的用户界面</li><li><code>aValueArgument</code> 有些命令需要额外的输入，如插入图片、链接时需要给出地址</li></ul><p>注：经过我的试验，在 Chrome 下改变 aShowDefaultUI 的值并未发现影响，<a href="https://stackoverflow.com/questions/38188015/what-is-the-the-default-user-interface-referred-to-by-the-ashowdefaultui-param">这个 stackoverflow 的问题</a>中提到这是一个来自于旧版 IE 的参数，所以这里设置为默认的 false 即可。</p><h2 id="actions-对象"><a href="#actions-对象" class="headerlink" title="actions 对象"></a>actions 对象</h2><p>文件中定义了一个名为 <code>actions</code> 的对象，对应的是下图工具栏上的这一行按钮， <code>actions</code> 中的每个子对象都保存了一个按钮的属性。</p><p><img src="/asset/images/2017-12-29-pell-editor-toobar.png" alt="2017-12-29-pell-editor-toobar.png"></p><p>部分代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="attr">bold</span>: &#123;</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;&lt;b&gt;B&lt;/b&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Bold&#x27;</span>,</span><br><span class="line">        <span class="attr">result</span>: <span class="function">() =&gt;</span> exec(<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">italic</span>: &#123;</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;&lt;i&gt;I&lt;/i&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Italic&#x27;</span>,</span><br><span class="line">        <span class="attr">result</span>: <span class="function">() =&gt;</span> exec(<span class="string">&#x27;italic&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">underline</span>: &#123;</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;&lt;u&gt;U&lt;/u&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Underline&#x27;</span>,</span><br><span class="line">        <span class="attr">result</span>: <span class="function">() =&gt;</span> exec(<span class="string">&#x27;underline&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中显示了名为 <code>bold</code>，<code>italic</code>，<code>underline</code> 的三个对象属性，对应于工具栏中前方的<strong>加粗</strong>、<em>斜体</em>、下划线按钮，可以看出它们的结构是相同的，都有下列三个属性：</p><ul><li><code>icon</code>: 如何在工具栏中显示</li><li><code>title</code>: 就是 title 啦</li><li><code>result</code>: 一个函数，会赋给按钮作为点击事件，调用之前所提到的 <code>exec()</code> 函数来对文本进行操作</li></ul><p>现在已有了 <code>actions</code> 对象，那么如何使用它呢？这就要看看 <code>init()</code> 函数了，它会根据一定的规则从 <code>actions</code> 对象中选出元素组成一个数组，数组的每一项都会生成一个按钮。下面代码中的 <code>settings.actions</code> 即为此数组，其中的每个元素都对应一个显示在工具栏上的按钮。<code>settings.actions</code> 的生成规则会在后面进行解释。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pell.js 中的 init() 函数</span></span><br><span class="line">settings.actions.forEach(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 新建一个按钮元素</span></span><br><span class="line">    <span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">    <span class="comment">// 给按钮加上 css 样式</span></span><br><span class="line">    button.className = settings.classes.button</span><br><span class="line">    <span class="comment">// 把 icon 属性作为内容显示出来</span></span><br><span class="line">    button.innerHTML = action.icon</span><br><span class="line">    button.title = action.title</span><br><span class="line">    <span class="comment">// 把 result 属性赋给按钮作为点击事件</span></span><br><span class="line">    button.onclick = action.result</span><br><span class="line">    <span class="comment">// 将创建的按钮添加到工具栏上</span></span><br><span class="line">    actionbar.appendChild(button)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样数组中的每个元素就都生成了一个工具栏上的按钮了。 </p><h2 id="init-初始化函数"><a href="#init-初始化函数" class="headerlink" title="init() 初始化函数"></a>init() 初始化函数</h2><p>想使用 pell 编辑器时，只要调用 <code>init()</code> 函数来初始化一个编辑器即可。它接收一个 <code>setting</code> 对象作为参数，其中包含这样的一些属性：</p><ul><li><code>element</code>: 编辑器的 DOM 元素</li><li><code>styleWithCSS</code>: 设置为 true 时，将会用 <code>&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;</code> 代替 <code>&lt;b&gt;&lt;/b&gt;</code></li><li><code>actions</code></li><li><code>onChange</code></li></ul><p>其中最重要的是 <code>actions</code>，它是一个数组，包含了你想在工具栏显示的按钮列表。</p><p><code>actions</code> 数组中可以有这几种元素：</p><ul><li>一个字符串</li><li>一个有 <code>name</code> 属性的对象</li><li>一个对象，没有 <code>name</code> 属性，但有生成一个按钮的必需属性 <code>icon</code>，<code>result</code> 等</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">actions: [</span><br><span class="line">  <span class="string">&#x27;bold&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;underline&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;italic&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">    <span class="attr">result</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> url = <span class="built_in">window</span>.prompt(<span class="string">&#x27;Enter the image URL&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (url) <span class="built_in">window</span>.pell.exec(<span class="string">&#x27;insertImage&#x27;</span>, ensureHTTP(url))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在 <code>init()</code> 函数中会把这个 <code>actions</code>参数 和 pell.js 中定义的 <code>actions</code>对象组合起来，可以将 <code>actions</code> 对象当作一个默认设置，看以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pell.js 中的 init() 函数</span></span><br><span class="line">settings.actions = settings.actions</span><br><span class="line">    ? settings.actions.map(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> actions[action]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果参数中传入的 action 已经在默认设置中存在，用传入的参数覆盖默认设置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (actions[action.name]) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; ...actions[action.name], ...action &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    &#125;)</span><br><span class="line">    : <span class="built_in">Object</span>.keys(actions).map(<span class="function"><span class="params">action</span> =&gt;</span> actions[action])</span><br></pre></td></tr></table></figure><p>如果参数对象 <code>setting</code> 中不包含 <code>actions</code> 数组,  则会默认使用之前定义的 <code>actions</code> 对象来初始化。</p><p>init() 函数里还有一个重要的部分，就是创建一个可编辑区域，这里创建了一个 <code>div</code> 元素，将其 <code>contentEditable</code> 属性设为 <code>true</code>，从而可以在这里使用之前提到的 <code>document.execCommand()</code> 命令了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建编辑区域的元素</span></span><br><span class="line">settings.element.content = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="comment">// 让 div 成为可编辑状态</span></span><br><span class="line">settings.element.content.contentEditable = <span class="literal">true</span></span><br><span class="line">settings.element.content.className = settings.classes.content</span><br><span class="line"><span class="comment">// 当用户输入时，更新页面的相应部分</span></span><br><span class="line">settings.element.content.oninput = <span class="function"><span class="params">event</span> =&gt;</span> </span><br><span class="line">    settings.onChange(event.target.innerHTML)</span><br><span class="line">settings.element.content.onkeydown = preventTab</span><br><span class="line">settings.element.appendChild(settings.element.content)</span><br></pre></td></tr></table></figure><h2 id="流程整理"><a href="#流程整理" class="headerlink" title="流程整理"></a>流程整理</h2><p>最后以“插入链接”为例来梳理下整个编辑器的流程：</p><p>一、在调用 <code>init()</code> 函数时，在参数对象的 <code>action</code> 数组中加入以下一项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;link&#x27;</span>,</span><br><span class="line">    <span class="attr">result</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="built_in">window</span>.prompt(<span class="string">&#x27;Enter the link URL&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (url) <span class="built_in">window</span>.pell.exec(<span class="string">&#x27;createLink&#x27;</span>, ensureHTTP(url))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、在 <code>init()</code> 的运行过程中，会检查已定义的 <code>actions</code> 对象中是否有 <code>link</code> 这个属性。经检查属性确实存在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">link: &#123;</span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;&amp;#128279;&#x27;</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;Link&#x27;</span>,</span><br><span class="line">    <span class="attr">result</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="built_in">window</span>.prompt(<span class="string">&#x27;Enter the link URL&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (url) exec(<span class="string">&#x27;createLink&#x27;</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为传入的参数中有 <code>result</code> 这一项，所以用传入的 <code>result</code> 来代替 <code>link</code> 对象中的默认值，然后将修改过的 <code>link</code> 对象放入 <code>settings.actions</code> 数组中。</p><p>三、对 <code>settings.actions</code> 数组进行一次迭代来生成工具栏，<code>link</code> 对象作为其中的一项生成了一个“插入链接”的按钮。<code>result</code> 属性成为其点击事件。</p><p>四、点击“插入链接”的按钮后，会让你输入一个 url，然后调用 <code>exec(&#39;createLink&#39;, url)</code> 在编辑区域插入该链接。</p><p>编辑器其它按钮的功能流程也类似。</p><p>这样 Pell 编辑器的大部分内容就讲解完毕了，剩余部分还需要自己去看源码。毕竟项目的代码不长，以此作为文本编辑器的入门倒不错。</p><hr><p>2017年的最后一篇文章了，再见，2017。</p><p><a href="http://www.wukai.me/2017/12/31/rich-text-editor-in-less-than-200-lines-javascript/">本文原地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间在寻找一些关于富文本编辑器的资料，然后发现了这个名为 &lt;a href=&quot;https://github.com/jaredreich/pell&quot;&gt;Pell&lt;/a&gt; 的项目，它是一个所见即所得（WYSIWYG）的文本编辑器，虽然它的功能很简单，但是令人吃惊的是它只有 1kb 大小。而项目最核心的文件 &lt;a href=&quot;https://github.com/jaredreich/pell/blob/master/src/pell.js&quot;&gt;pell.js&lt;/a&gt; 只有130行，即使加上其它部分，总的 js 数量也不到200行。这引起了我的兴趣，决定看看它的源码是如何做到这一点的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="编辑器" scheme="http://www.wukai.me/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>用 JavaScript 画光：基础</title>
    <link href="http://www.wukai.me/2017/12/10/light-2d-javascript/"/>
    <id>http://www.wukai.me/2017/12/10/light-2d-javascript/</id>
    <published>2017-12-09T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Any application that <strong>can</strong> be written in JavaScript, <strong>will</strong> eventually be written in JavaScript.<br>– Atwood’s Law</p></blockquote><p>本文来源于我在看了 Milo Yip 在知乎专栏里的这篇文章：<a href="https://zhuanlan.zhihu.com/p/30745861">《用 C 语言画光（一）：基础》</a>之后的一个想法，能不能将原文中 C 语言版本程序改成 JavaScript 版本的。动手之后发现出乎意料的顺利，我只需要把 C 语言中变量的类型通通去掉就可以了😀，Amazing！</p><span id="more"></span><p>最终结果可见此 CodePen：<a href="https://codepen.io/noiron/pen/aVgYMB?editors=1010">https://codepen.io/noiron/pen/aVgYMB?editors=1010</a></p><p><p data-height="400" data-theme-id="0" data-slug-hash="aVgYMB" data-default-tab="result" data-user="noiron" data-embed-version="2" data-pen-title="aVgYMB" class="codepen">See the Pen <a href="https://codepen.io/noiron/pen/aVgYMB/">aVgYMB</a> by wu kai (<a href="https://codepen.io/noiron">@noiron</a>) on <a href="https://codepen.io">CodePen</a>.</p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>在本文中，我主要解释一下 JavaScript 如何将图像输出，以及我对这个画光程序的一点理解。更多有关图形学原理部分的内容，建议还是看 Milo Yip 的原文。</p><h2 id="如何输出图像"><a href="#如何输出图像" class="headerlink" title="如何输出图像"></a>如何输出图像</h2><p>Milo Yip 在他的系列文章中使用了一个自己写的 <a href="https://zhuanlan.zhihu.com/p/26525083">svpng()</a> 函数，能够根据得到的图形数据生成 <code>png</code> 格式的图片。而使用 JavaScript 可以方便地在 <code>canvas</code> 元素上绘制出图形。</p><p>为了能够记录下图片的信息，需要记录每一个像素点的 <code>RGB</code> 值，对于一张宽度为 W，高度为 H 的图片，其像素点数量为 <code>W * H</code>，而每个像素点分别用三个数来表示其 R、G、B 值，所以记录下整张图片的数据，需要一个长度为 <code>W * H * 3</code> 的数组。如果图片带有 alpha 通道，需要记录 <code>RGBA</code> 值，则数组长度为 <code>W * H * 4</code>。这里有一个可以简化的地方，因为绘制的是一张黑白的图片，对于黑/白/灰色来说 R = G = B，所以用长度 <code>W * H</code> 的数组即可。</p><p>假设我们现在已经有了一个记录图片信息的数组 <code>p</code>，那么如何将其显示出来？这里需要用到 <code>getImageData</code>, <code>putImageData</code> 方法。</p><p>可以利用 <code>getImageData()</code> 方法来获得 ImageData 对象，从中得到图像的像素点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取 ImageData 对象</span></span><br><span class="line"><span class="keyword">const</span> imageData = ctx.getImageData(x, y, width, height)</span><br></pre></td></tr></table></figure><p><code>ImageData</code> 对象的 <code>data</code> 属性是一个数组，包含有每个像素点的 <code>RGBA</code>，其总长度为 <code>W * H * 4</code>。所以我们将记录图片信息的数组 <code>p</code> 中的值依序赋给 <code>data</code>，再利用 <code>putImageData</code> 方法即可将图片绘制到 canvas 上了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processImageData</span>(<span class="params">imageData, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = imageData.data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = p[i / <span class="number">4</span>];</span><br><span class="line">        data[i] = value;</span><br><span class="line">        data[i + <span class="number">1</span>] = value;</span><br><span class="line">        data[i + <span class="number">2</span>] = value;</span><br><span class="line">        data[i + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData(imageData, p);</span><br><span class="line">ctx.putImageData(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="如何获得一个点的光照强度"><a href="#如何获得一个点的光照强度" class="headerlink" title="如何获得一个点的光照强度"></a>如何获得一个点的光照强度</h2><p>现在我们考虑的是单色光，RGB 中的三个值是相等的，当光照越强时，RGB 值越大，图像的颜色也越白。</p><p>坐标为 (x, y) 的一个点，它获得的光来自于各个方向上的光的叠加，即是一个对角度的积分：</p><p>$$F\left( x,y\right) =\int ^{2\pi }_{0}L\left( x,y,\theta \right) d\theta$$</p><p>其中 $L\left( x,y,\theta \right)$ 代表在二维坐标 (x, y) 在 $\theta$ 方向有多少光经过。</p><p>由于无法直接计算出这个积分的值，需要用<strong>蒙特卡罗积分法</strong>来进行采样。利用 N 个方向的采样平均值作为这一点的光强。</p><p>那么 (x, y) 点在 $\theta$ 方向上能获得多少光照？我们现在只有一个处于画面中央的圆形光源，可考虑从 (x, y) 为起点的一条线段，如果它足够长，那只有两种可能性：</p><ul><li>终结于光源的表面，则 (x, y) 点在 $\theta$ 方向能获得光照</li><li>与光源无交点，则此方向上无光照</li></ul><p>但我们需要对这条线段的长度加以限制，所以逐步加长线段的长度，如果线段终点在光源的表面或内部，则获得光照。当步数达到 <code>MAX_STEP</code> 或距离达到 <code>MAX_DISTANCE</code>，停止计算，在此方向上获得的光照为0。</p><p>这里需要利用<strong>带符号距离场（signed distance field, SDF）</strong>来表示出当前的点与场景的最近距离，每次步进此距离能保证不会进入光源的内部。如下图中，每个圆的半径均为圆心和图中形状的最近距离，则按 P0 -&gt; P1 -&gt; P2 -&gt; … 的顺序前进能保证不会和图中的形状相交。 </p><p><img src="/asset/images/2017-12-10-sphere-tracing.jpg" alt="sphere-tracing"><br>（图源：<a href="https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter08.html）">https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter08.html）</a></p><p>此即原文中提到的<strong>光线步进（ray marching）</strong>方法（又称为<strong>球体追踪／sphere tracing</strong>）。</p><h2 id="JavaScript-的实现"><a href="#JavaScript-的实现" class="headerlink" title="JavaScript 的实现"></a>JavaScript 的实现</h2><p>利用 <code>sample()</code> 函数计算并保存所有坐标点的光照：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>, i = <span class="number">0</span>; y &lt; HEIGHT; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; WIDTH; x++) &#123;</span><br><span class="line">        <span class="comment">// x / W, y / H 其值被限制在 [0, 1] 之间</span></span><br><span class="line">        p[i++] = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.min(sample(x / WIDTH, y / HEIGHT) * <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用蒙特卡罗积分法进行 N 次采样取平均值获得 (x, y) 处的光照强度，其中的 <code>trace()</code> 函数代表的是从 $\theta$ 方向获取的光强。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sample</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">// 以下为三种不同的采样方式</span></span><br><span class="line">        <span class="comment">// const theta = Math.PI * 2 * Math.random();           // 随机采样</span></span><br><span class="line">        <span class="comment">// const theta = Math.PI * 2 * i / N;                   // 分层采样（stratified sampling）</span></span><br><span class="line">        <span class="keyword">const</span> theta = <span class="built_in">Math</span>.PI * <span class="number">2</span> * (i + <span class="built_in">Math</span>.random()) / N;    <span class="comment">// 抖动采样（jittered sampling）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// trace() 所返回的值是点 (x, y) 从 theta 方向获取的光</span></span><br><span class="line">        sum += trace(x, y, <span class="built_in">Math</span>.cos(theta), <span class="built_in">Math</span>.sin(theta));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>circleSDF</code> 为带符号距离场（signed distance field, SDF），值为负时，表示在光源的内部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">circleSDF</span>(<span class="params">x, y, cx, cy, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ux = x - cx;</span><br><span class="line">    <span class="keyword">const</span> uy = y - cy;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(ux * ux + uy * uy) - r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是 <code>trace()</code> 方法，用<strong>光线步进</strong>来计算出 (ox, oy) 沿单位向量 (dx, dy) 方向上获得的光照。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>(<span class="params">ox, oy, dx, dy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> MAX_STEP = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> MAX_DISTANCE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> EPSILON = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0.0</span>;    <span class="comment">// t 为步进的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; MAX_STEP &amp;&amp; t &lt; MAX_DISTANCE; i++) &#123;</span><br><span class="line">        <span class="comment">// 光源中心为 (sourceX, sourceY) </span></span><br><span class="line">        <span class="comment">// 沿单位向量 (dx, dy) 方向前进，t 表示前进的距离</span></span><br><span class="line">        <span class="keyword">const</span> sd = circleSDF(ox + dx * t, oy + dy * t, sourceX, sourceY, <span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时已到达发光的圆形表面</span></span><br><span class="line">        <span class="keyword">if</span> (sd &lt; EPSILON) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续增加步进的距离</span></span><br><span class="line">        t += sd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我还在代码添加了一个点击事件，可以改变光源位置来查看不同的效果。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/YIXUNFE/blog/issues/12">Canvas 操作图像像素</a></p><hr><p>[<strong>2018-01-01 更新</strong>]<br>在 GitHub 上建立了一个项目，准备将《用C语言画光》系列文章中的代码都移植到 JavaScipt 中来。<br>项目地址：<a href="https://github.com/noiron/light2d-javascript">light2d-javascript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Any application that &lt;strong&gt;can&lt;/strong&gt; be written in JavaScript, &lt;strong&gt;will&lt;/strong&gt; eventually be written in JavaScript.&lt;br&gt;– Atwood’s Law&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文来源于我在看了 Milo Yip 在知乎专栏里的这篇文章：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30745861&quot;&gt;《用 C 语言画光（一）：基础》&lt;/a&gt;之后的一个想法，能不能将原文中 C 语言版本程序改成 JavaScript 版本的。动手之后发现出乎意料的顺利，我只需要把 C 语言中变量的类型通通去掉就可以了😀，Amazing！&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="计算机图形学" scheme="http://www.wukai.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>塔防游戏中的敌人如何沿路径前进 (JavaScript 实现)</title>
    <link href="http://www.wukai.me/2017/12/09/boid-path-following/"/>
    <id>http://www.wukai.me/2017/12/09/boid-path-following/</id>
    <published>2017-12-08T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<p>如果开发一个塔防游戏，很自然的会遇上这么两个名字很像的问题：</p><ul><li><strong>Path-finding</strong>: 如果知道起点和终点，如何在其间找到一条路径</li><li><strong>Path-following</strong>: 已知从起点到终点的路径，物体如何才能沿着它行进</li></ul><p>本文将要讨论的是第二个问题 <strong>path following</strong>，给定一条路径，看物体如何沿着它从起点运行至终点。为了方便描述，接下来的内容中，用单词 <a href="https://en.wikipedia.org/wiki/Boids">Boid</a> 来表示行进的物体或塔防中的敌人。</p><p>接下来会用一种简单的方法来解决这一问题，最终完成的代码库可见 GitHub: <a href="https://github.com/noiron/boid-path-following">boid-path-following</a>，repo 的多个分支对应了文中的不同步骤。</p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>先来看看如何标识出画面中的位置，首先画面被一系列的横纵线分成了许多网格，对于地图范围内的一个点，它会有自己的像素坐标 (x, y)，同时它所处的格子也有自己的坐标 (col, row) 或 (xIndex, yIndex)，表示所处的列和行。</p><p><img src="/asset/images/2017-12-09-path-following-map.png" alt=""></p><p>为了区分，下文中提到<strong>像素坐标</strong>即为用像素表示的坐标，<strong>网格坐标</strong>表示点在网格中的列和行。</p><p>在这种表示方法下，还需要一个工具函数 <code>index2Px(col, row)</code>，用于计算格子中心的像素坐标。</p><p>接下来给出路径的坐标，路径是如下的一个二维数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = [[<span class="number">0</span>, <span class="number">1</span>], [COLS - <span class="number">4</span>, <span class="number">1</span>], [COLS - <span class="number">4</span>, <span class="number">4</span>], [<span class="number">6</span>, <span class="number">4</span>], [<span class="number">6</span>, <span class="number">7</span>], <span class="comment">/* 部分省略 */</span>]</span><br></pre></td></tr></table></figure><p>每一项都是路径上一个点的网格坐标，将这些点用直线连接起来后就得到了 boid 行进的路径。我们的目标就是要让 boid 能够从路径第一个坐标移动至最后一个坐标。</p><h2 id="Boid-如何沿直线前进"><a href="#Boid-如何沿直线前进" class="headerlink" title="Boid 如何沿直线前进"></a>Boid 如何沿直线前进</h2><p>先考虑最简单的问题，如何让 Boid 沿着一条直线行进。</p><p>物体的移动需要位置和速度，为了表示其像素坐标，<code>boid</code> 需要 <code>x</code>, <code>y</code> 属性；其速度需要 <code>speed</code> 属性，同时还需要一个 <code>angle</code>，以便计算出速度在两个方向上的分量 <code>vx</code>, <code>vy</code>。</p><p>动画效果的实现需要用 <code>requestAnimationFrame</code> 函数，每一秒为60帧，每一帧中都会执行一次循环，在其中改变位置：</p><pre><code>下一时刻的位置 = 当前时刻的位置 + 速度</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示意代码</span></span><br><span class="line"><span class="comment">// Boid 类的 step() 方法</span></span><br><span class="line"><span class="function"><span class="title">step</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> speed = <span class="built_in">this</span>.speed;</span><br><span class="line">    <span class="keyword">const</span> angle = <span class="built_in">Math</span>.PI / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.vx = <span class="built_in">Math</span>.cos(angle) * speed;</span><br><span class="line">    <span class="built_in">this</span>.vy = <span class="built_in">Math</span>.sin(angle) * speed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 vx, vy 不变化，则会沿一条直线前进</span></span><br><span class="line">    <span class="built_in">this</span>.x += <span class="built_in">this</span>.vx;</span><br><span class="line">    <span class="built_in">this</span>.y += <span class="built_in">this</span>.vy; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每一个循环中，boid 的位置都会发生变化，在新的位置上将其画出即可看到 boid 沿直线运动的效果。</p><p>这一部分可在示例代码库的 <code>demo01/go-straight</code> 分支上查看：</p><pre><code>git checkout demo01/go-straightnpm run demo01</code></pre><p>现在 boid 已经动起来了，但是却没法停止，这就是我们接下来需要考虑的问题。</p><h2 id="如何让-boid-在目标点处停止"><a href="#如何让-boid-在目标点处停止" class="headerlink" title="如何让 boid 在目标点处停止"></a>如何让 boid 在目标点处停止</h2><p>要让 boid 能够知道自己到达了目标点，则在每一次循环过程中，需要计算出此刻离目标点的距离分量 <code>dx</code>，<code>dy</code>，据此算出距离 <code>dist</code>，将其与速度 <code>speed</code> 进行比较。如果 <code>dist &gt; speed</code>，说明物体离目标点还挺远，继续将速度加到位置上即可。反之则表明物体将要到达终点，此时若直接加上速度，boid 可能会越过目标点，因此需要一点不同的处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示意代码</span></span><br><span class="line"><span class="function"><span class="title">step</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reachDest) &#123;</span><br><span class="line">        <span class="comment">// 已到达终点，可根据实际需要进行操作            </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> speed = <span class="built_in">this</span>.speed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与目标点的距离</span></span><br><span class="line">    <span class="built_in">this</span>.dx = target.x - <span class="built_in">this</span>.x;</span><br><span class="line">    <span class="built_in">this</span>.dy = target.y - <span class="built_in">this</span>.y;</span><br><span class="line">    <span class="built_in">this</span>.dist = <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.dx * <span class="built_in">this</span>.dx + <span class="built_in">this</span>.dy * <span class="built_in">this</span>.dy);</span><br><span class="line">    <span class="built_in">this</span>.angle = <span class="built_in">Math</span>.atan2(<span class="built_in">this</span>.dy, <span class="built_in">this</span>.dx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 速度分量</span></span><br><span class="line">    <span class="built_in">this</span>.vx = <span class="built_in">Math</span>.cos(<span class="built_in">this</span>.angle) * speed;</span><br><span class="line">    <span class="built_in">this</span>.vy = <span class="built_in">Math</span>.sin(<span class="built_in">this</span>.angle) * speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.dist &gt; speed) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x += <span class="built_in">this</span>.vx;</span><br><span class="line">        <span class="built_in">this</span>.y += <span class="built_in">this</span>.vy; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时刻的位置加上速度后超过了当前目标点</span></span><br><span class="line">        <span class="comment">// 物体下一时刻将处于当前目标点的位置</span></span><br><span class="line">        <span class="built_in">this</span>.x = target.x;</span><br><span class="line">        <span class="built_in">this</span>.y = target.y;</span><br><span class="line">        <span class="built_in">this</span>.reachDest = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分可在示例代码库的 <code>demo01/stop</code> 分支上查看：</p><pre><code>git checkout demo01/stopnpm run demo01</code></pre><p>此时，到达了终点的 boid 被清除而不再显示。</p><h2 id="如何让-boid-能够转向"><a href="#如何让-boid-能够转向" class="headerlink" title="如何让 boid 能够转向"></a>如何让 boid 能够转向</h2><p>前面叙述中为了简化，路径中只有起点和终点，所以 boid 没有机会转向，那当路径变复杂了之后，boid 该如何运动？</p><p>前面已经提到过，<code>path</code> 是一个记录了路径网格坐标的数组，boid 会从中取一个坐标作为自己的当前目标点，然后一直向前行进，到达了这个目标点之后，它会从 <code>path</code> 数组中取出下一个坐标，继续移动至该位置。循环以上过程，直到 boid 到达 <code>path</code> 中的最后一个坐标。</p><p>上面的代码中，我们的目标点 <code>target</code> 固定为 <code>path</code> 的最后一个坐标，而现在每一次转向时 <code>target</code> 都会变化，所以加入这样的两个变量：</p><ul><li><code>waypoint</code> 表示<strong>当前</strong>目标点的索引</li><li><code>angleFlag</code> 记录是否需要转向。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Boid 的 step() 中的部分示意代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每次转向后目标点需要重新计算 */</span></span><br><span class="line"><span class="keyword">const</span> waypoint = path[<span class="built_in">this</span>.waypoint];   <span class="comment">// 当前目标点的网格坐标</span></span><br><span class="line"><span class="keyword">const</span> target = index2Px(...waypoint);   <span class="comment">// 当前目标点的像素坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要转向，如果需要转向，则重新计算角度</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.angleFlag) &#123;</span><br><span class="line">    <span class="built_in">this</span>.angle = <span class="built_in">Math</span>.atan2(<span class="built_in">this</span>.dy, <span class="built_in">this</span>.dx);</span><br><span class="line">    <span class="built_in">this</span>.angleFlag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次到达一个目标点之后，都要检查是否为终点</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.waypoint + <span class="number">1</span> &gt;= path.length) &#123;</span><br><span class="line">    <span class="comment">// 到达终点</span></span><br><span class="line">    <span class="built_in">this</span>.reachDest = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.waypoint++;</span><br><span class="line">    <span class="built_in">this</span>.angleFlag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分可在示例代码库的 <code>demo01/steering</code> 分支上查看：</p><pre><code>git checkout demo01/steeringnpm run demo01</code></pre><p>结果可见下图：<br><img src="/asset/images/2017-12-09-path-following-1.png" alt=""></p><p>到此为止，这种 boid 沿路径行进的方法已经讲解完毕了。建议读者查看一下 repo 中的代码，自己修改部分代码，比如更改路径，看结果会有何不同。</p><h2 id="其它的方法"><a href="#其它的方法" class="headerlink" title="其它的方法"></a>其它的方法</h2><p>这一种方法中的确实现了沿路径移动的效果，但是有点儿单调，boid 只能在路径的中轴线上移动，而且它们之间也没有交互的效果。<a href="http://natureofcode.com/book/">The Nature of Code</a> 这本书的第六章 <a href="http://natureofcode.com/book/chapter-6-autonomous-agents/">Autonomous Agents</a> 中介绍了另一种稍微复杂的方法来实现 path following。</p><p>我之前参考他人的代码实现了<a href="http://www.wukai.me/html-demo/path-following/">这种方法的一个演示版本</a>，其代码在<a href="https://github.com/noiron/html-demo/tree/master/path-following">此处</a>。</p><p>(也许之后会补一篇博客来介绍 <em>The Nature of Code</em> 中的实现，但谁知道会不会写呢🤔)</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后，<a href="https://github.com/noiron/tower-defense-js">我最近在写的这个塔防游戏</a>中就使用了本文介绍的 path following 方法。虽然游戏还没完成，但点进去看看再给个 star 又不费电😀。</p><hr><p><a href="http://www.wukai.me/2017/12/09/boid-path-following/">本文地址：塔防游戏中的敌人如何沿路径前进 (JavaScript 实现)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果开发一个塔防游戏，很自然的会遇上这么两个名字很像的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Path-finding&lt;/strong&gt;: 如果知道起点和终点，如何在其间找到一条路径&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Path-following&lt;/strong&gt;: 已知从起点到终点的路径，物体如何才能沿着它行进&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将要讨论的是第二个问题 &lt;strong&gt;path following&lt;/strong&gt;，给定一条路径，看物体如何沿着它从起点运行至终点。为了方便描述，接下来的内容中，用单词 &lt;a href=&quot;https://en.wikipedia.org/wiki/Boids&quot;&gt;Boid&lt;/a&gt; 来表示行进的物体或塔防中的敌人。&lt;/p&gt;
&lt;p&gt;接下来会用一种简单的方法来解决这一问题，最终完成的代码库可见 GitHub: &lt;a href=&quot;https://github.com/noiron/boid-path-following&quot;&gt;boid-path-following&lt;/a&gt;，repo 的多个分支对应了文中的不同步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="游戏开发" scheme="http://www.wukai.me/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>React Router v4 之代码分割：从放弃到入门</title>
    <link href="http://www.wukai.me/2017/09/25/react-router-v4-code-splitting/"/>
    <id>http://www.wukai.me/2017/09/25/react-router-v4-code-splitting/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>React Router v4 推出已有六个月了，网络上因版本升级带来的哀嚎仿佛就在半年前。我在使用这个版本的 React Router 时，也遇到了一些问题，比如这里所说的代码分割，所以写了这篇博客作为总结，希望能对他人有所帮助。</p><h2 id="什么是代码分割（code-splitting）"><a href="#什么是代码分割（code-splitting）" class="headerlink" title="什么是代码分割（code splitting）"></a>什么是代码分割（code splitting）</h2><p>在用户浏览我们的网站时，一种方案是一次性地将所有的 JavaScript 代码都下载下来，可想而知，代码体积会很可观，同时这些代码中的一部分可能是用户此时并不需要的。另一种方案是按需加载，将 JavaScript 代码分成多个块（chunk），用户只需下载当前浏览所需的代码即可，用户进入到其它页面或需要渲染其它部分时，才加载更多的代码。这后一种方案中用到的就是所谓的<strong>代码分割（code splitting）</strong>了。</p><span id="more"></span><p>当然为了实现代码分割，仍然需要和 webpack 搭配使用，先来看看 webpack 的文档中是如何介绍的。</p><p><a href="https://webpack.js.org/guides/code-splitting/">Webpack 文档的 code splitting 页面</a>中介绍了三种方法：</p><ol><li>利用 webpack 中的 <code>entry</code> 配置项来进行手动分割</li><li>利用 <code>CommonsChunkPlugin</code> 插件来提取重复 chunk</li><li>动态引入（Dynamic Imports）</li></ol><p>你可以读一下此篇文档，从而对 webpack 是如何进行代码分割的有个基本的认识。本文后面将提到的方案就是基于上述的第三种方法。</p><h2 id="React-Router-中如何进行代码分割"><a href="#React-Router-中如何进行代码分割" class="headerlink" title="React Router 中如何进行代码分割"></a>React Router 中如何进行代码分割</h2><p>在 v4 之前的版本中，一般是利用 <code>require.ensure()</code> 来实现代码分割的，而在 v4 中又是如何处理的呢？</p><h3 id="使用-bundle-loader-的方案"><a href="#使用-bundle-loader-的方案" class="headerlink" title="使用 bundle-loader 的方案"></a>使用 bundle-loader 的方案</h3><p>在 React Router v4 官方给出的<a href="https://reacttraining.com/react-router/web/guides/code-splitting">文档</a>中，使用了名为 <a href="https://github.com/webpack-contrib/bundle-loader"><code>bundle-loader</code></a> 的工具来实现这一功能。</p><p>其主要实现思路为创建一个名为 <code>&lt;Bundle&gt;</code> 的组件，当应用匹配到了对应的路径时，该组件会动态地引入所需模块并将自身渲染出来。</p><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> loadSomething <span class="keyword">from</span> <span class="string">&#x27;bundle-loader?lazy!./Something&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;Bundle load=&#123;loadSomething&#125;&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">mod</span>) =&gt;</span> (</span><br><span class="line">    <span class="comment">// do something w/ the module</span></span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/Bundle&gt;</span><br></pre></td></tr></table></figure><p>更多关于 <code>&lt;Bundle&gt;</code> 组件的实现可参见上面给出的文档地址。</p><h3 id="使用-bundle-loader-方法存在的不足之处"><a href="#使用-bundle-loader-方法存在的不足之处" class="headerlink" title="使用 bundle-loader 方法存在的不足之处"></a>使用 bundle-loader 方法存在的不足之处</h3><p>这里提到的两个缺点我们在实际开发工作中遇到的，与我们的项目特定结构相关，所以你可能并不会遇上。</p><p>一、 代码丑陋</p><p>由于我们的项目是从 React Router v2, v3 升级过来的，在之前的版本中对于异步加载的实现采用了集中配置的方案，即项目中存在一个 <code>Routes.js</code> 文件，整个项目的路径设置都放在了该文件中，这样方便集中管理。</p><p>但是在 React Router v4 版本中，由于使用了 <code>bundle-loader</code> 来实现代码分割，必须使用以下写法来引入组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> loadSomething <span class="keyword">from</span> <span class="string">&#x27;bundle-loader?lazy!./Something&#x27;</span></span><br></pre></td></tr></table></figure><p>而我们的 <code>reducer</code> 和 <code>saga</code> 文件也需要使用此种方法引入，导致 <code>Routes.js</code> 文件顶端将会出现一长串及其冗长的组件引入代码，不易维护。如下所示：</p><p><img src="/asset/images/2017-08-14-bundle-loader.png" alt=""></p><p>当用这种方法引入的模块数量过多时，文件将会不忍直视。</p><p>二、 存在莫名的组件生命周期Bug</p><p>在使用了这种方案后，在某些页面中会出现这样的一个Bug：应用中进行页面跳转时，上一个页面的组件会在 <code>unmount</code> 之后重新创建一次。表现为已经到了下一页面，但是会调用存在于跳转前页面中的组件的 <code>componentDidMount</code> 方法。</p><p>当然，这个Bug只与我自己的特定项目有关，错误原因可能与 <code>bundle-loader</code> 并无太大关联。不过因为一直无法解决这一问题，所以决定换一个方案来代替 <code>bundle-loader</code>。</p><h2 id="使用-import-的新方案"><a href="#使用-import-的新方案" class="headerlink" title="使用 import() 的新方案"></a>使用 import() 的新方案</h2><p>Dan Abramov 在这个 create-react-app 的 issue 中给出了 <code>bundle-loader</code> 的替代方案的链接：<a href="http://serverless-stack.com/chapters/code-splitting-in-create-react-app.html">Code Splitting in Create React App</a>，可以参考该篇文章来实现我们项目中的代码分割功能。</p><h3 id="代码分割和-React-Router-v4"><a href="#代码分割和-React-Router-v4" class="headerlink" title="代码分割和 React Router v4"></a>代码分割和 React Router v4</h3><p>一个常规的 React Router 项目结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码出处：</span></span><br><span class="line"><span class="comment">// http://serverless-stack.com/chapters/code-splitting-in-create-react-app.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Import the components */</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./containers/Home&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Posts <span class="keyword">from</span> <span class="string">&#x27;./containers/Posts&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">&#x27;./containers/NotFound&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use components to define routes */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/posts/:id&quot;</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">&#123;Posts&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;NotFound&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>首先根据我们的 route 引入相应的组件，然后将其用于定义相应的 <code>&lt;Route&gt;</code>。</p><p>但是，不管匹配到了哪一个 route，我们这里都一次性地引入所有的组件。而我们想要的效果是当匹配了一个 route，则只引入与其对应的组件，这就需要实现代码分割了。</p><h3 id="创建一个异步组件（Async-Component）"><a href="#创建一个异步组件（Async-Component）" class="headerlink" title="创建一个异步组件（Async Component）"></a>创建一个异步组件（Async Component）</h3><p>异步组件，即只有在需要的时候才会引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncComponent</span>(<span class="params">importComponent</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AsyncComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        <span class="attr">component</span>: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">default</span>: component &#125; = <span class="keyword">await</span> importComponent();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        <span class="attr">component</span>: component</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> C = <span class="built_in">this</span>.state.component;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> C</span><br><span class="line">        ? <span class="xml"><span class="tag">&lt;<span class="name">C</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">        : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> AsyncComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>asyncComponent</code> 接收一个 <code>importComponent</code> 函数作为参数，<code>importComponent()</code> 在被调用时会动态引入给定的组件。</p><p>在 <code>componentDidMount()</code>中，调用传入的 <code>importComponent()</code>，并将动态引入的组件保存在 state 中。</p><h3 id="使用异步组件（Async-Component）"><a href="#使用异步组件（Async-Component）" class="headerlink" title="使用异步组件（Async Component）"></a>使用异步组件（Async Component）</h3><p>不再使用如下静态引入组件的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./containers/Home&#x27;</span>;</span><br></pre></td></tr></table></figure><p>而是使用 <code>asyncComponent</code> 方法来动态引入组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncHome = asyncComponent(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./containers/Home&#x27;</span>));</span><br></pre></td></tr></table></figure><p>此处的 <code>import()</code> 来自于新的 ES 提案，其结果是一个 Promise，这是一种动态引入模块的方法，即上文 webpack 文档中提到的第三种方法。更多关于 <code>import()</code> 的信息可以查看这篇文章：<a href="http://2ality.com/2017/01/import-operator.html">ES proposal: import() – dynamically importing ES modules</a>。</p><p>注意这里并没有进行组件的引入，而是传给了 <code>asyncComponent</code> 一个函数，它将在 <code>AsyncHome</code> 组件被创建时进行动态引入。同时，这种传入一个函数作为参数，而非直接传入一个字符串的写法能够让 webpack 意识到此处需要进行代码分割。</p><p>最后如下使用这个 <code>AsyncHome</code> 组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/&quot;</span> exact component=&#123;AsyncHome&#125; /&gt;</span><br></pre></td></tr></table></figure><h3 id="对于-reducer-和-saga-文件的异步加载"><a href="#对于-reducer-和-saga-文件的异步加载" class="headerlink" title="对于 reducer 和 saga 文件的异步加载"></a>对于 reducer 和 saga 文件的异步加载</h3><p>在上面的这篇文章中，只给出了对于组件的异步引入的解决方案，而在我们的项目中还存在将 <code>reducer</code> 和 <code>saga</code> 文件异步引入的需求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">processReducer</span>(<span class="params">reducer</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(reducer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all(reducer.map(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">this</span>.processReducer(r)));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">Object</span>.keys(reducer)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> reducer[key]().then(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">            injectAsyncReducer(key, x.default);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将需要异步引入的 reducer 作为参数传入，利用 Promise 来对其进行异步处理。在 <code>componentDidMount</code> 方法中等待 reducer 处理完毕后在将组件保存在 state 中，对于 saga 文件同理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// componentDidMount 中做如下修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">default</span>: component &#125; = <span class="keyword">await</span> importComponent();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.all([<span class="built_in">this</span>.processReducer(reducers),</span><br><span class="line">            <span class="built_in">this</span>.processSaga(sagas)]).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            component</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面对 <code>reducer</code> 文件进行处理时，使用了这样的一行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">injectAsyncReducer(key, x.default);</span><br></pre></td></tr></table></figure><p>其作用是利用 Redux 中的 <code>replaceReducer()</code> 方法来修改 reducer，具体代码见下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducerList 是你当前的 reducer 列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReducer</span>(<span class="params">asyncReducers</span>) </span>&#123;</span><br><span class="line">    asyncReducers</span><br><span class="line">    &amp;&amp; !reducersList[<span class="built_in">Object</span>.keys(asyncReducers)[<span class="number">0</span>]]</span><br><span class="line">    &amp;&amp; (reducersList = <span class="built_in">Object</span>.assign(&#123;&#125;, reducersList, asyncReducers));</span><br><span class="line">    <span class="keyword">return</span> combineReducers(reducersList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectAsyncReducer</span>(<span class="params">name, asyncReducer</span>) </span>&#123;</span><br><span class="line">    store.replaceReducer(createReducer(&#123; [name]: asyncReducer &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的 asyncComponent 代码可见以下 gist，注意一点，为了能够灵活地使用不同的 <code>injectAsyncReducer</code>, <code>injectAsyncSaga</code> 函数，代码中使用了高阶组件的写法，你可以直接使用内层的 <code>asyncComponent</code> 函数。</p><script src="https://gist.github.com/noiron/7f774dea55bcc52921e5bc5a50c2aa10.js"></script><h2 id="asyncComponent-方法与-React-Router-v4-的结合使用"><a href="#asyncComponent-方法与-React-Router-v4-的结合使用" class="headerlink" title="asyncComponent 方法与 React Router v4 的结合使用"></a>asyncComponent 方法与 React Router v4 的结合使用</h2><h3 id="组件、reducer、saga-的异步引入"><a href="#组件、reducer、saga-的异步引入" class="headerlink" title="组件、reducer、saga 的异步引入"></a>组件、reducer、saga 的异步引入</h3><p>考虑到代码可读性，可在你的 <code>route</code> 目录下新建一个 <code>asyncImport.js</code> 文件，将需要异步引入的模块写在该文件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入前面所写的异步加载函数</span></span><br><span class="line"><span class="keyword">import</span> asyncComponent <span class="keyword">from</span> <span class="string">&#x27;route/AsyncComponent&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只传入第一个参数，只需要组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AsyncHomePage = asyncComponent(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./homepage/Homepage&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入三个参数，分别为 component, reducer, saga</span></span><br><span class="line"><span class="comment">// 注意这里的第二个参数 reducer 是一个对象，其键值对应于redux store中存放的键值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AsyncArticle = asyncComponent(</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./market/Common/js/Container&#x27;</span>),</span><br><span class="line">    &#123; <span class="attr">market</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./market/Common/js/reducer&#x27;</span>) &#125;,</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./market/Saga/watcher&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer 和 saga 参数可以传入数组</span></span><br><span class="line"><span class="comment">// 当只有 saga，而无 reducer 参数时，第二项参数传入空数组 []</span></span><br><span class="line"><span class="keyword">const</span> UserContainer = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./user/Common/js/Container&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> userReducer = &#123; <span class="attr">userInfo</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./user/Common/js/userInfoReducer&#x27;</span>) &#125;;</span><br><span class="line"><span class="keyword">const</span> userSaga = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./user/Saga/watcher&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AsyncUserContainer = asyncComponent(</span><br><span class="line">    UserContainer,</span><br><span class="line">    [userReducer, createReducer],</span><br><span class="line">    [userSaga, createSaga]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后在项目的 <code>Router</code> 组件中引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// route/index.jsx</span></span><br><span class="line">&lt;Route path=<span class="string">&quot;/user&quot;</span> component=&#123;AsyncArticle&#125; /&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/user/:userId&quot;</span> <span class="attr">component</span>=<span class="string">&#123;AsyncUserContainer&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>根据 React Router v4 的哲学，React Router 中的一切皆为组件，所以不必在一个单独的文件中统一配置所有的路由信息。建议在你最外层的容器组件，比如我的 <code>route/index.jsx</code> 文件中只写入<strong>对应一个单独页面的容器组件</strong>，而页面中的子组件在该容器组件中异步引入并使用。</p><p><del>在 React Router v5 发布之前完成了本文，可喜可贺👏</del></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="http://serverless-stack.com/chapters/code-splitting-in-create-react-app.html">Code Splitting in Create React App</a><br><a href="http://2ality.com/2017/01/import-operator.html">ES proposal: import() – dynamically importing ES modules</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;React Router v4 推出已有六个月了，网络上因版本升级带来的哀嚎仿佛就在半年前。我在使用这个版本的 React Router 时，也遇到了一些问题，比如这里所说的代码分割，所以写了这篇博客作为总结，希望能对他人有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;什么是代码分割（code-splitting）&quot;&gt;&lt;a href=&quot;#什么是代码分割（code-splitting）&quot; class=&quot;headerlink&quot; title=&quot;什么是代码分割（code splitting）&quot;&gt;&lt;/a&gt;什么是代码分割（code splitting）&lt;/h2&gt;&lt;p&gt;在用户浏览我们的网站时，一种方案是一次性地将所有的 JavaScript 代码都下载下来，可想而知，代码体积会很可观，同时这些代码中的一部分可能是用户此时并不需要的。另一种方案是按需加载，将 JavaScript 代码分成多个块（chunk），用户只需下载当前浏览所需的代码即可，用户进入到其它页面或需要渲染其它部分时，才加载更多的代码。这后一种方案中用到的就是所谓的&lt;strong&gt;代码分割（code splitting）&lt;/strong&gt;了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://www.wukai.me/tags/webpack/"/>
    
      <category term="react-router" scheme="http://www.wukai.me/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>利用 socket.io 实现消息实时推送</title>
    <link href="http://www.wukai.me/2017/08/27/push-message-with-socketio/"/>
    <id>http://www.wukai.me/2017/08/27/push-message-with-socketio/</id>
    <published>2017-08-26T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目背景介绍"><a href="#项目背景介绍" class="headerlink" title="项目背景介绍"></a>项目背景介绍</h2><p>最近在写的项目中存在着社交模块，需要实现这样的一个功能：当发生了用户被点赞、评论、关注等操作时，需要由服务器向用户实时地推送一条消息。最终完成的项目地址为：<a href="https://github.com/noiron/socket-message-push">socket-message-push</a>，这里将介绍一下实现的思路及部分代码。</p><p>项目的流程中存在着这样的几个对象：</p><ul><li>用 Java 实现的后端服务器</li><li>用 Node.js 实现的消息推送服务器</li><li>用户进行操作的客户端</li></ul><p>事件处理的流程如下：</p><ol><li>用户进行点赞操作时，后端服务器会进行处理，并向 Node.js 消息推送服务器发送一条消息</li><li>Node.js 消息推送服务器接收到后端发送的消息后，处理数据，并确定向哪个用户进行推送</li><li>用户的客户端接收到由 Node.js 服务器推送来的消息后，即可进行通知的显示。</li></ol><p>上面的流程中，Java 后端服务器是如何实现的不在此篇文章的讨论范围内，本文将主要介绍如何使用 Node.js 来实现这个消息推送服务器。</p><span id="more"></span><p>考虑消息推送服务器上必须记录下当前在线用户的信息，这样才能向特定的用户推送消息。所以当用户登录时，必须将自身的用户信息发到 Node.js 服务器上。为了达到这种双向的实时消息传递，很明显地考虑用 WebSocket 来实现。既然我们在消息推送服务器上使用了 Node.js，我们就有了一个很方便的选项：socket.io。</p><h2 id="Socket-io-介绍"><a href="#Socket-io-介绍" class="headerlink" title="Socket.io 介绍"></a>Socket.io 介绍</h2><p><a href="https://socket.io">Socket.io</a>是一个用 JavaScript 实现的实时双向通信的库，利用它来实现我们的功能会很简单。</p><p><code>socket.io</code> 包含两个部分：</p><ul><li>服务器端（server）：运行在 Node.js 服务器上</li><li>客户端（client）：运行在浏览器中</li></ul><p>可以看看如下的 <code>socket.io</code> 的示例代码，它给出了 <code>socket.io</code> 发出及监听事件的基本用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">  socket.emit(<span class="string">&#x27;request&#x27;</span>, <span class="comment">/* */</span>); <span class="comment">// emit an event to the socket</span></span><br><span class="line">  io.emit(<span class="string">&#x27;broadcast&#x27;</span>, <span class="comment">/* */</span>); <span class="comment">// emit an event to all connected sockets</span></span><br><span class="line">  socket.on(<span class="string">&#x27;reply&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* */</span> &#125;); <span class="comment">// listen to the event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于 Socket.io 还有一点需要注意：Socke.io 并不完全是 WebSocket 的实现。</p><blockquote><p>Note: Socket.IO is not a WebSocket implementation. Although Socket.IO indeed uses WebSocket as a transport when possible, it adds some metadata to each packet: the packet type, the namespace and the ack id when a message acknowledgement is needed.</p></blockquote><p>接下来我们需要用 Express.js 来建立一个服务器端程序，并在其中引入 Socket.io。</p><h2 id="Node-js-服务器的搭建"><a href="#Node-js-服务器的搭建" class="headerlink" title="Node.js 服务器的搭建"></a>Node.js 服务器的搭建</h2><h3 id="利用-Express-js-搭建基础服务器"><a href="#利用-Express-js-搭建基础服务器" class="headerlink" title="利用 Express.js 搭建基础服务器"></a>利用 Express.js 搭建基础服务器</h3><p>我们使用了 Express.js 来搭建 Node.js 消息推送服务器，先利用一个简要的例子来浏览其功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).Server(app);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">4001</span>;</span><br><span class="line"></span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">&#x27;public&#x27;</span>)));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.sendFile(__dirname + <span class="string">&#x27;/public/index.html&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/api&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.listen(port, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`listening on port:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将上面的代码保存为 <code>server.js</code>，新建一个 <code>public</code> 文件夹，在其中放入 <code>index.html</code> 文件。运行以下命令：</p><pre><code>node server.js</code></pre><p>现在即可在 <code>localhost:4001</code> 查看效果了。</p><h3 id="引入-socket-io"><a href="#引入-socket-io" class="headerlink" title="引入 socket.io"></a>引入 socket.io</h3><p>现在已经有了一个基础的 Express 服务器，接下来需要将 Socket.io 加入其中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>)(http);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a user connected&#x27;</span>);</span><br><span class="line">    socket.broadcast.emit(<span class="string">&#x27;new_user&#x27;</span>, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>io</code> 监听 <code>connection</code> 事件，当 <code>client</code> 与 <code>server</code> 建立了连接之后，这里的回调函数会被调用（<code>client</code> 中的代码将在下一节介绍）。</p><p>函数的参数 <code>socket</code> 代表的是当前的 <code>client</code> 和 <code>server</code> 间建立的这个连接。可在 <code>client</code> 程序中将这个建立的 socket 连接打印出来，如下图所示：</p><p><img src="/asset/images/2017-08-16-socket-attribute.png" alt=""></p><p>其中的 <code>id</code> 属性可以用于标识出这一连接，从而 <code>server</code> 可以向特定的用户发送消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.broadcast.emit(<span class="string">&#x27;new_user&#x27;</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure><p>这一行代码表示 <code>socket</code> 将向当前所有与 <code>server</code> 建立了连接的 <code>client</code>（不包括自己） 广播一条名为 <code>new_user</code> 的消息。</p><h3 id="后端推送消息的处理流程"><a href="#后端推送消息的处理流程" class="headerlink" title="后端推送消息的处理流程"></a>后端推送消息的处理流程</h3><ol><li><p>在 Node 服务器建立一个用户信息和 socket id 的映射表，因为同一用户可能打开了多个页面，所以他的 socket id 可能存在多个值。当用户建立连接时，往其中添加值；用户断开连接后，删除相应值。</p></li><li><p>当 Java 后台存在需要推送的消息时，会向 Node 服务器的 <code>/api</code> 路径 post 一条消息，其中包括用于标识用户的 tokenId 和其它数据。</p></li><li><p>Node 服务器接收到 post 请求后，对请求内容进行处理。根据 tokenId 找出与该用户对应的 socket id，socket.io 会根据 id 来向用户推送消息。</p></li></ol><h3 id="对用户信息的处理"><a href="#对用户信息的处理" class="headerlink" title="对用户信息的处理"></a>对用户信息的处理</h3><p>方便起见，这里只用一个数组保存用户信息，实际工作中可以根据需要放入数据库中保存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">global</span>.users = []; <span class="comment">// 记录下登录用户的tokenId, socketId</span></span><br></pre></td></tr></table></figure><p>当用户登录时，<code>client</code> 会向 <code>server</code> 发送 <code>user_login</code> 事件，服务器接收到后会做如下操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">&#x27;user_login&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; tokenId, userId, socketId &#125; = info;</span><br><span class="line">    addSocketId(users, &#123; tokenId, socketId, userId &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>addSocketId()</code> 会向 <code>users</code> 数组中添加用户信息，不同用户通过 tokenId 进行区分，每个用户有一个 <code>socketIds</code> 数组，保存可能存在的多个 <code>socketId</code>。该函数的具体代码可见 <code>src/utils.js</code> 文件。</p><p>同理，还有一个 <code>deleteSocketId()</code> 函数用于删除用户信息，代码可见同一文件。</p><p>在获取了用户的 tokenId 之后，就需要找到对应的 socketId，然后向特定用户推送消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只向 id = socketId 的这一连接发送消息 </span></span><br><span class="line">io.sockets.to(socketId).emit(<span class="string">&#x27;receive_message&#x27;</span>, &#123;</span><br><span class="line">    entityType,</span><br><span class="line">    data</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>服务器的思路大致如此，接下来介绍客户端中是如何进行相应的处理的。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="Socket-io-的初始化"><a href="#Socket-io-的初始化" class="headerlink" title="Socket.io 的初始化"></a>Socket.io 的初始化</h3><p>首先在 html 文件中引入 Socket.io 的 client 端文件，例如通过 CDN 引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其它的引入方式:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io-client&#x27;</span>);</span><br><span class="line"><span class="comment">// or with import syntax</span></span><br><span class="line"><span class="keyword">import</span> io <span class="keyword">from</span> <span class="string">&#x27;socket.io-client&#x27;</span>;</span><br></pre></td></tr></table></figure><p>引入 Socket.io 后就获得了 <code>io</code> 函数，通过它来与消息推送服务器建立连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设你将 Node 服务器部署后的地址为：https://www.example.com/ws</span></span><br><span class="line"><span class="comment">// 则： WS_HOST = &#x27;https://www.example.com&#x27;</span></span><br><span class="line"><span class="keyword">const</span> msgSocket = io(<span class="string">`<span class="subst">$&#123;WS_HOST&#125;</span>`</span>, &#123;</span><br><span class="line">    <span class="attr">secure</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/ws/socket.io&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果监听本地：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msgSocket = io(<span class="string">&#x27;http://localhost:4001&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这里如果写成 <code>io(&#39;https://www.example.com/ws&#39;)</code> 会出现错误，需要将 <code>/ws</code> 写入path中。</p><p>为了能在其它文件使用这一变量，可将 <code>msgSocket</code> 作为一个全局变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.msgSocket = msgSocket;</span><br></pre></td></tr></table></figure><h3 id="用户建立连接"><a href="#用户建立连接" class="headerlink" title="用户建立连接"></a>用户建立连接</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户登录时，向服务器发送用户的信息。服务器会在收到信息后建立 socket 与用户的映射。</span></span><br><span class="line">msgSocket.emit(<span class="string">&#x27;user_login&#x27;</span>, &#123;</span><br><span class="line">    userId,</span><br><span class="line">    <span class="attr">socketId</span>: msgSocket.id,</span><br><span class="line">    tokenId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="接收到推送的消息后的处理"><a href="#接收到推送的消息后的处理" class="headerlink" title="接收到推送的消息后的处理"></a>接收到推送的消息后的处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebSocket 连接建立后，监听名为 receive_message 的事件 </span></span><br><span class="line">msgSocket.on(<span class="string">&#x27;receive_message&#x27;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    store.dispatch(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;NEW_SOCKET_MSG&#x27;</span>,</span><br><span class="line">        <span class="attr">payload</span>: msg</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当 WebSocket 服务器向客户端推送了消息之后，客户端需要监听 <code>receive_message</code> 事件，接收到的参数中有相应待处理的信息。<br>由于使用了 Redux 进行数据的处理，所以这里 dispatch 了一个 <code>NEW_SOCKET_MSG</code> action，后续则是常规的 redux 处理流程了。</p><h2 id="项目的使用"><a href="#项目的使用" class="headerlink" title="项目的使用"></a>项目的使用</h2><p>GitHub 上的项目地址：<a href="https://github.com/noiron/socket-message-push">socket-message-push</a></p><pre><code>npm run dev</code></pre><p>即可在 devlopment 环境下进行测试，现在你就有了一个运行在4001端口的消息推送服务器了。</p><p>但是这里并没有后端的服务器来向我们发送消息，所以我们将利用 Postman 来模拟发送消息。</p><p>为了展示程序的功能，在项目的 client 文件夹下放置了一个 <code>index.html</code> 文件。注意这个文件并不能用在实际的项目中，只是用来显示消息推送的效果而已。</p><p>在开启了服务器之后，打开 <code>client/index.html</code>，根据提示随意输入一个 tokenId 即可。</p><p>现在利用 Postman 向 <code>localhost:4001/api</code> post 如下的一条信息：</p><pre><code>&#123;    // tokens 数组表示你想向哪个用户推送消息    &quot;tokens&quot;: [&quot;1&quot;, &quot;2&quot;],    &quot;data&quot;: &quot;You shall not pass!!!&quot;&#125;</code></pre><p><img src="/asset/images/2017-08-27-postman-post-msg.png" alt="postman-post-a-message"></p><p>至此，如果一切顺利，你应该能够在 client 的控制台中看到收到的消息了。</p><p><img src="/asset/images/2017-08-27-client-receive-msg.png" alt="client-message"></p><p>你可以打开多个 client 页面，输入不同的 tokenId，然后检查消息是否发送给了正确的用户。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://github.com/socketio/socket.io/tree/master/examples/chat">https://github.com/socketio/socket.io/tree/master/examples/chat</a><br><a href="https://socket.io/docs/">https://socket.io/docs/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目背景介绍&quot;&gt;&lt;a href=&quot;#项目背景介绍&quot; class=&quot;headerlink&quot; title=&quot;项目背景介绍&quot;&gt;&lt;/a&gt;项目背景介绍&lt;/h2&gt;&lt;p&gt;最近在写的项目中存在着社交模块，需要实现这样的一个功能：当发生了用户被点赞、评论、关注等操作时，需要由服务器向用户实时地推送一条消息。最终完成的项目地址为：&lt;a href=&quot;https://github.com/noiron/socket-message-push&quot;&gt;socket-message-push&lt;/a&gt;，这里将介绍一下实现的思路及部分代码。&lt;/p&gt;
&lt;p&gt;项目的流程中存在着这样的几个对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 Java 实现的后端服务器&lt;/li&gt;
&lt;li&gt;用 Node.js 实现的消息推送服务器&lt;/li&gt;
&lt;li&gt;用户进行操作的客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件处理的流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户进行点赞操作时，后端服务器会进行处理，并向 Node.js 消息推送服务器发送一条消息&lt;/li&gt;
&lt;li&gt;Node.js 消息推送服务器接收到后端发送的消息后，处理数据，并确定向哪个用户进行推送&lt;/li&gt;
&lt;li&gt;用户的客户端接收到由 Node.js 服务器推送来的消息后，即可进行通知的显示。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面的流程中，Java 后端服务器是如何实现的不在此篇文章的讨论范围内，本文将主要介绍如何使用 Node.js 来实现这个消息推送服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="socket.io" scheme="http://www.wukai.me/tags/socket-io/"/>
    
      <category term="node.js" scheme="http://www.wukai.me/tags/node-js/"/>
    
      <category term="express.js" scheme="http://www.wukai.me/tags/express-js/"/>
    
  </entry>
  
  <entry>
    <title>如何用 html 和 css 画一拳超人</title>
    <link href="http://www.wukai.me/2017/04/16/draw-one-punch-man-with-html-and-css/"/>
    <id>http://www.wukai.me/2017/04/16/draw-one-punch-man-with-html-and-css/</id>
    <published>2017-04-15T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇博客的起因是我看了Medium上的这篇文章：<a href="https://blog.prototypr.io/how-i-started-drawing-css-images-3fd878675c89">How I started drawing CSS Images</a>，然后哇哦😦，同样是前端开发，这区别怎么这么大呢？这位作者和我完全点了不同的技能点啊！</p><p>看了几个她在codepen上的作品，比如这个<a href="http://codepen.io/sashatran/pen/VmwmJO">皮卡丘</a>，发现用到的技术也并不多，于是我也想试试。</p><p>不过有哪个动漫中的人物足够简单，能够用几个基本的几何图形就画出来呢？我想到了一个人，于是我决定画一个《一拳超人》中的<del>卤蛋</del>，不对，是<del>秃头披风侠</del>——琦玉老师。</p><span id="more"></span><p>结果展示：</p><p><p data-height="450" data-theme-id="dark" data-slug-hash="oZKgMJ" data-default-tab="html,result" data-user="noiron" data-embed-version="2" data-pen-title="One punch man" class="codepen">See the Pen <a href="http://codepen.io/noiron/pen/oZKgMJ/">One punch man</a> by wu kai (<a href="http://codepen.io/noiron">@noiron</a>) on <a href="http://codepen.io">CodePen</a>.</p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h2 id="技术概述"><a href="#技术概述" class="headerlink" title="技术概述"></a>技术概述</h2><p>从html文件中你可以看到这张图片实际上全部是由<code>div</code>元素组合而成的，一共用到了15个div。在给一个div元素加上适当的css样式后，就形成了脸上的一个部位。</p><p>在绘制琦玉的头像时，最重要的一个css属性就是<code>border-radius</code>，我们用它可以画出圆形、椭圆及各种变体。图中的脸部轮廓、眼睛、耳朵的形状都是由<code>border-radius</code>来实现的，稍后将介绍其使用方法。</p><p>另一个需要说明的css属性是<code>transform</code>，可以实现平移和旋转。</p><h2 id="border-radius-介绍"><a href="#border-radius-介绍" class="headerlink" title="border-radius 介绍"></a>border-radius 介绍</h2><p>之前我对<code>border-radius</code>的认识只局限于可以给元素加上圆角，以及将其值设为50%可以让矩形显示为圆形。查了些资料后，才发现可以用它画出许多图形。</p><p><code>border-radius</code>是以下四个属性的简写，每一个属性用于设置一个角的形状：</p><pre><code>border-top-left-radiusborder-top-right-radiusborder-bottom-right-radiusborder-bottom-left-radius</code></pre><p><img src="https://developer.mozilla.org/files/3638/border-radius-sh.png" alt="border-radius"></p><p>图片来自<a href="https://developer.mozilla.org/en/docs/Web/CSS/border-radius">MDN</a></p><p>从上图可以看出当只设置一个值或设置两个相同的值时，显示为圆；设置两个不同的值时，显示为椭圆。以<code>border-top-left-radius</code>为例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the corner is a circle */</span></span><br><span class="line"><span class="comment">/* border-top-left-radius: radius */</span></span><br><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">3px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the corner is an ellipsis */</span></span><br><span class="line"><span class="comment">/* border-top-left-radius: horizontal vertical */</span></span><br><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">0.5em</span> <span class="number">1em</span>;</span><br></pre></td></tr></table></figure><p>若是简写形式，则写成如下格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">48%</span> <span class="number">48%</span> <span class="number">50%</span> <span class="number">50%</span> / <span class="number">42%</span> <span class="number">42%</span> <span class="number">54%</span> <span class="number">54%</span>;</span><br></pre></td></tr></table></figure><p>‘/‘之前的四个值表示水平轴的长度，’/‘之后的四个值表示垂直轴的长度，当水平轴的长度和垂直轴的长度相等时，可以省略’/‘及之后的这一组值。</p><p>对于同一组的四个数值，也有简写方式。方法与 padding 和 margin 的简写类似，第一个值与第三个值相同或第二个值与第四个值相同时，可以只写一遍。</p><p>在了解了<code>border-radius</code>的用法后，通过给<code>div</code>元素合适的宽高比，在调整四个圆角的半径，就能够获得你想要的形状了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 以下的样式能够画出琦玉的脸部形状</span><br><span class="line">// 在调整<span class="attribute">width</span>, <span class="attribute">height</span>, <span class="attribute">border-radius</span> 后，可画出眼、鼻、嘴的形状</span><br><span class="line"><span class="selector-id">#div1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">144px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">48%</span> <span class="number">48%</span> <span class="number">50%</span> <span class="number">50%</span> / <span class="number">42%</span> <span class="number">42%</span> <span class="number">54%</span> <span class="number">54%</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="transform-介绍"><a href="#transform-介绍" class="headerlink" title="transform 介绍"></a>transform 介绍</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform">transform属性</a>也是一个很强大的属性，能够对元素做各种变形。不过我们这里只需要用它来进行平移和旋转的操作。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以用 translate 来实现平移操作 */</span></span><br><span class="line"><span class="comment">/* translate() 的两个参数分别表示水平方向和垂直方向的平移距离 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">12px</span>, <span class="number">50%</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上面这一行与下面的这两行是等价的 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">12px</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">50%</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顺时针旋转20度 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">20deg</span>);</span><br></pre></td></tr></table></figure><h2 id="组合得到最终结果"><a href="#组合得到最终结果" class="headerlink" title="组合得到最终结果"></a>组合得到最终结果</h2><p>在你已经将琦玉头像进行拆解，把各个部分都用一个<code>div</code>来表示并加上了合适的样式后，就能将它们组合起来了。你可以用<code>transform</code>来调整它们的距离，或者直接用<code>absoulte</code>定位。</p><p>最后就得到了琦玉的头像：</p><p><img src="/asset/images/2017-04-10-one-punch-man-not-completed.png" alt=""></p><p>额，秃子，你谁啊！？</p><p>看来不是所有的光头都叫琦玉，还需要对细节进行一点调整：</p><p><img src="/asset/images/2017-04-10-one-punch-man.png" alt=""></p><p>OK，这样就有点像琦玉老师了。最后，如果你愿意的话，还可以用<code>transition</code>属性来稍微加上点动画效果。</p><p>再放一遍代码地址：</p><blockquote><p><a href="https://codepen.io/noiron/pen/oZKgMJ">Codepen代码及展示</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇博客的起因是我看了Medium上的这篇文章：&lt;a href=&quot;https://blog.prototypr.io/how-i-started-drawing-css-images-3fd878675c89&quot;&gt;How I started drawing CSS Images&lt;/a&gt;，然后哇哦😦，同样是前端开发，这区别怎么这么大呢？这位作者和我完全点了不同的技能点啊！&lt;/p&gt;
&lt;p&gt;看了几个她在codepen上的作品，比如这个&lt;a href=&quot;http://codepen.io/sashatran/pen/VmwmJO&quot;&gt;皮卡丘&lt;/a&gt;，发现用到的技术也并不多，于是我也想试试。&lt;/p&gt;
&lt;p&gt;不过有哪个动漫中的人物足够简单，能够用几个基本的几何图形就画出来呢？我想到了一个人，于是我决定画一个《一拳超人》中的&lt;del&gt;卤蛋&lt;/del&gt;，不对，是&lt;del&gt;秃头披风侠&lt;/del&gt;——琦玉老师。&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="http://www.wukai.me/tags/html/"/>
    
      <category term="css" scheme="http://www.wukai.me/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>课程笔记--Building a javascript development environment</title>
    <link href="http://www.wukai.me/2017/03/05/lesson-note-build-a-javascript-development-environment/"/>
    <id>http://www.wukai.me/2017/03/05/lesson-note-build-a-javascript-development-environment/</id>
    <published>2017-03-04T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客是我在学习 <a href="https://app.pluralsight.com/library/courses/javascript-development-environment/recommended-courses">Pluralsight上的课程：Building a JavaScript Development Environment</a> 时记下的笔记，仅作个人记录之用。</p><p>这门课程系统地介绍了前端开发中的许多工具和术语，从编辑器的选择到项目的部署都进行了介绍，我在学习了这个课程后感觉将之前零散学习的内容串了起来。</p><p>顺便一说，Pluralsight网站上面有许多不错的课程，不过价格太贵，需每月付29美元😥。但是，你可以用微软账号加入<a href="https://www.visualstudio.com/zh-hans/dev-essentials/">Visual Studio Dev Essentials 计划</a>，这样就可以免费获得Pluralsight 3个月的订阅了😀。</p><hr><h2 id="1-Course-Overview"><a href="#1-Course-Overview" class="headerlink" title="1. Course Overview"></a>1. Course Overview</h2><p>编程的时候要做许多选择</p><ul><li>Editor</li><li>Module format</li><li>HTML generation</li><li>Transpiling</li><li>Bundler</li><li>Linting</li><li>Testing</li><li>…</li></ul><p>这门课程介绍了如何在这些选项中做出选择</p><span id="more"></span><h2 id="2-You-need-a-starter-kit"><a href="#2-You-need-a-starter-kit" class="headerlink" title="2. You need a starter kit"></a>2. You need a starter kit</h2><h3 id="You-need-a-starter-kit"><a href="#You-need-a-starter-kit" class="headerlink" title="You need a starter kit"></a>You need a starter kit</h3><p>原因：</p><ul><li>Codifies<ul><li>决定</li><li>最佳实践</li><li>教训</li></ul></li><li>鼓励一致性</li><li>避免忘记重要的细节</li><li>增加质量<ul><li>Doing the “right” thing is the easy thing</li></ul></li><li>避免重复工作</li></ul><h3 id="A-starter-kit-is-an-automated-checklist"><a href="#A-starter-kit-is-an-automated-checklist" class="headerlink" title="A starter kit is an automated checklist"></a>A starter kit is an automated checklist</h3><h3 id="Who-is-this-course-for"><a href="#Who-is-this-course-for" class="headerlink" title="Who is this course for?"></a>Who is this course for?</h3><p>Atwood’s Law </p><p>JavaScript is Everywhere</p><h3 id="What-Belongs-in-your-starter-kit"><a href="#What-Belongs-in-your-starter-kit" class="headerlink" title="What Belongs in your starter kit?"></a>What Belongs in your starter kit?</h3><ul><li>Package Management</li><li>Bundling</li><li>Minification</li><li>Sourcemaps</li><li>Transpiling</li><li>Dynamic HTML Generation</li><li>Centralized HTTP</li><li>Mock API framework</li><li>Component libraries</li><li>Development Webserver</li><li>Linting</li><li>Automated Testing</li><li>Continuous Integration</li><li>Automated deployment</li><li>Working example app</li></ul><h3 id="Agenda"><a href="#Agenda" class="headerlink" title="Agenda"></a>Agenda</h3><p>Rhythm</p><ol><li>Options</li><li>Recommendation</li><li>Implement</li></ol><hr><h2 id="3-Editors-and-Configuration"><a href="#3-Editors-and-Configuration" class="headerlink" title="3. Editors and Configuration"></a>3. Editors and Configuration</h2><h3 id="What-to-look-for-in-a-JavaScript-Editor"><a href="#What-to-look-for-in-a-JavaScript-Editor" class="headerlink" title="What to look for in a JavaScript Editor"></a>What to look for in a JavaScript Editor</h3><ul><li>Strong ES2015+ support</li><li>framework intelligence</li><li>Built-in terminal</li></ul><p>可选编辑器：</p><ul><li>Atom</li><li>WebStorm</li><li>Brackets</li><li>VSCode</li></ul><h3 id="Editorconfig"><a href="#Editorconfig" class="headerlink" title="Editorconfig"></a>Editorconfig</h3><p>EditorConfig 保证大家的编辑器设置一样。</p><h3 id="Demo-Editorconfig"><a href="#Demo-Editorconfig" class="headerlink" title="Demo: Editorconfig"></a>Demo: Editorconfig</h3><p>增加 .editorconfig 文件</p><hr><h2 id="4-Package-Management"><a href="#4-Package-Management" class="headerlink" title="4. Package Management"></a>4. Package Management</h2><h3 id="Package-Managers"><a href="#Package-Managers" class="headerlink" title="Package Managers"></a>Package Managers</h3><ul><li>Bower</li><li>npm</li><li>JSPM</li><li>…</li></ul><h3 id="Demo-Install-Node-and-npm-Packages"><a href="#Demo-Install-Node-and-npm-Packages" class="headerlink" title="Demo: Install Node and npm Packages"></a>Demo: Install Node and npm Packages</h3><h3 id="Package-Security"><a href="#Package-Security" class="headerlink" title="Package Security"></a>Package Security</h3><p>何时 Run Security Check ?</p><p>npm start </p><h3 id="Demo-Node-Security-Platform"><a href="#Demo-Node-Security-Platform" class="headerlink" title="Demo: Node Security Platform"></a>Demo: Node Security Platform</h3><p>全局安装 nsp</p><pre><code>nsp install -g nspλ nsp check(+) No known vulnerabilities found</code></pre><hr><h2 id="5-Development-Web-Server"><a href="#5-Development-Web-Server" class="headerlink" title="5. Development Web Server"></a>5. Development Web Server</h2><h3 id="Development-Web-Servers"><a href="#Development-Web-Servers" class="headerlink" title="Development Web Servers"></a>Development Web Servers</h3><ul><li>http-server</li><li>live-server</li><li>Express</li><li>budo</li><li>Webpack dev server</li><li>Browsersync</li></ul><h3 id="Sharing-Work-in-progress"><a href="#Sharing-Work-in-progress" class="headerlink" title="Sharing Work-in-progress"></a>Sharing Work-in-progress</h3><h4 id="localtunnel"><a href="#localtunnel" class="headerlink" title="localtunnel"></a>localtunnel</h4><p>步骤：</p><pre><code>1. npm install localtunnel -g2. start app3. lt --port 3000</code></pre><h4 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h4><ol><li>注册</li><li>安装 ngrok</li><li>安装 authtoken</li><li>start app</li><li>./ngrok http 80</li></ol><h4 id="now"><a href="#now" class="headerlink" title="now"></a>now</h4><h4 id="surge"><a href="#surge" class="headerlink" title="surge"></a>surge</h4><p>快速将静态文件部署到公开URL上去。</p><ol><li>npm install -g surge</li><li>surge</li></ol><h2 id="6-Automation"><a href="#6-Automation" class="headerlink" title="6. Automation"></a>6. Automation</h2><h3 id="Automation-Options"><a href="#Automation-Options" class="headerlink" title="Automation Options"></a>Automation Options</h3><ul><li>Grunt</li><li>Gulp</li><li>npm scripts</li></ul><h3 id="Demo-Pre-Post-Hooks"><a href="#Demo-Pre-Post-Hooks" class="headerlink" title="Demo: Pre/Post Hooks"></a>Demo: Pre/Post Hooks</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">    <span class="attr">&quot;prestart&quot;</span>: <span class="string">&quot;node buildScripts/startMessage.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;node buildScripts/srcServer.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;poststart&quot;</span>: <span class="string">&quot;...&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行 <code>npm start</code> 时，<code>prestart</code>命令中的内容会自动在其之前运行。</p><h3 id="Demo-Create-Security-Check-and-Share-Scripts"><a href="#Demo-Create-Security-Check-and-Share-Scripts" class="headerlink" title="Demo: Create Security Check and Share Scripts"></a>Demo: Create Security Check and Share Scripts</h3><p>在 scripts 项中加入：</p><pre><code>&quot;security-check&quot;: &quot;nsp check&quot;</code></pre><h3 id="Demo-Concurrent-Tasks"><a href="#Demo-Concurrent-Tasks" class="headerlink" title="Demo: Concurrent Tasks"></a>Demo: Concurrent Tasks</h3><p>假设在运行server的同时，进行security-check，对start命令进行如下的修改：</p><pre><code>&quot;start&quot;: &quot;npm-run-all --parallel security-check open:src&quot;,&quot;open:src&quot;: &quot;node buildScripts/srcServer.js&quot;,</code></pre><p>其中用 npm-run-all 来代替。</p><p>可以用 npm start -s 减少输出中的噪声。</p><h2 id="7-Transpiling"><a href="#7-Transpiling" class="headerlink" title="7. Transpiling"></a>7. Transpiling</h2><h3 id="JavaScript-Versions"><a href="#JavaScript-Versions" class="headerlink" title="JavaScript Versions"></a>JavaScript Versions</h3><h3 id="Transpilers"><a href="#Transpilers" class="headerlink" title="Transpilers"></a>Transpilers</h3><p>Popular transpilers:</p><ul><li>Babel</li><li>TypeScript</li><li>Elm</li></ul><p>Babel可以将最新版本的JavaScript代码向下转换成ES5，从而可以使用所有的新特性。也是最流行的。</p><p>TypeScript是JavaScript的超集。 </p><p>Elm不是JavaScript，可以编译成JS。</p><p>Babel配置风格：</p><ol><li><p>使用.babelrc文件：不止能用在npm中，独立文件易于阅读</p></li><li><p>package.json：项目中少了一个文件</p></li></ol><p>在文件中加入<code>babel</code>项即可</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-package&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// my babel config here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Transpiling-Build-Scripts"><a href="#Transpiling-Build-Scripts" class="headerlink" title="Transpiling Build Scripts"></a>Transpiling Build Scripts</h3><h3 id="Demo-Set-Up-Babel"><a href="#Demo-Set-Up-Babel" class="headerlink" title="Demo: Set Up Babel"></a>Demo: Set Up Babel</h3><p>加入 .babelrc文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;latest&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在preset命令中用babel-node来代替node，来使用es6语法。这样可以使用import, const 等关键字。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;prestart&quot;</span>: <span class="string">&quot;babel-node buildScripts/startMessage.js&quot;</span>,</span><br></pre></td></tr></table></figure><hr><h2 id="8-Bundling"><a href="#8-Bundling" class="headerlink" title="8. Bundling"></a>8. Bundling</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>CommonJS不能在web浏览器中工作，需要将npm package打包成浏览器能够使用的形式。</p><h3 id="Module-Formats"><a href="#Module-Formats" class="headerlink" title="Module Formats"></a>Module Formats</h3><p>5中模块形式：</p><ul><li>IIFE</li><li>AMD</li><li>CommonJS</li><li>UMD</li><li>ES6 Modules</li></ul><p>现在应继续使用的两种模块：</p><ul><li><p>CommonJS: node中使用</p><p>  var jquery = require(‘jquery’)</p></li><li><p>ES6 Module</p></li></ul><h3 id="Why-ES6-Modules"><a href="#Why-ES6-Modules" class="headerlink" title="Why ES6 Modules?"></a>Why ES6 Modules?</h3><p>原因：</p><ul><li>Standardized</li><li>Statically analyzable<ul><li>Improved autocomplete</li><li>intelligent refactoring</li><li>Fails fast</li><li>Tree shaking</li></ul></li><li>Easy to read<ul><li>Named imports</li><li>Default exports</li></ul></li></ul><h3 id="Choosing-a-Bundler"><a href="#Choosing-a-Bundler" class="headerlink" title="Choosing a Bundler"></a>Choosing a Bundler</h3><ul><li>require.js: first popular bundler</li><li>Browserify: large plugin ecosystem</li><li>Webpack: bundles more than just JS</li><li>Rollup: tree shaking, fast loading production code, quite new …</li><li>JSPM: load modules at runtime</li></ul><p>Why webpack?</p><ul><li>Much more than just js<ul><li>css</li><li>images</li><li>fonts</li><li>html</li></ul></li><li>Bundle splitting</li><li>Hot module reloading</li><li>Webpack2 offers tree shaking</li></ul><h3 id="Demo-Configuring-Webpack"><a href="#Demo-Configuring-Webpack" class="headerlink" title="Demo: Configuring Webpack"></a>Demo: Configuring Webpack</h3><p>在根目录下新建<code>webpack.config.dev.js</code>文件，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">debug</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;inline-source-map&#x27;</span>,</span><br><span class="line">  <span class="attr">noInfo</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">entry</span>: [</span><br><span class="line">    path.resolve(__dirname, <span class="string">&#x27;src/index&#x27;</span>)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;web&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">loaders</span>: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/.js$/</span>, exclude: <span class="regexp">/node_modules/</span>, loaders: [<span class="string">&#x27;babel&#x27;</span>]&#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, loaders: [<span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;css&#x27;</span>]&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note: Webpack won’t actually generate any physical files for our development build. It will serve our build from memory.</p><h3 id="Demo-Configure-Webpack-with-Express"><a href="#Demo-Configure-Webpack-with-Express" class="headerlink" title="Demo: Configure Webpack with Express"></a>Demo: Configure Webpack with Express</h3><p>在 <code>buildScripts/srcServer.js</code>中添加下列内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">&#x27;webpack&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;../webpack.config.dev&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-middleware&#x27;</span>)(compiler, &#123;</span><br><span class="line">  <span class="attr">noInfo</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">publicPath</span>: config.output.publicPath</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="Demo-Create-app-entry-point"><a href="#Demo-Create-app-entry-point" class="headerlink" title="Demo: Create app entry point"></a>Demo: Create app entry point</h3><p>添加<code>index.js</code>文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> numeral <span class="keyword">from</span> <span class="string">&#x27;numeral&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> courseValue = numeral(<span class="number">1000</span>).format(<span class="string">&#x27;$0, 0.00&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`I would pay <span class="subst">$&#123;courseValue&#125;</span> for this awesome course!`</span>);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Demo-Handling-css-with-webpack"><a href="#Demo-Handling-css-with-webpack" class="headerlink" title="Demo: Handling css with webpack"></a>Demo: Handling css with webpack</h3><p>在我们的webpack配置文件中已经加入了css的loader的情况下，只需要在index.js引入css文件即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="Sourcemaps"><a href="#Sourcemaps" class="headerlink" title="Sourcemaps"></a>Sourcemaps</h3><p>Why: Debug transpiled and bundled code.</p><p>Maps code back to original source</p><h3 id="Demo-Debugging-via-sourcemaps"><a href="#Demo-Debugging-via-sourcemaps" class="headerlink" title="Demo: Debugging via sourcemaps"></a>Demo: Debugging via sourcemaps</h3><h2 id="9-Linting"><a href="#9-Linting" class="headerlink" title="9. Linting"></a>9. Linting</h2><h3 id="Why-Lint"><a href="#Why-Lint" class="headerlink" title="Why Lint?"></a>Why Lint?</h3><ul><li>Enforce consistency</li><li>Avoid mistakes</li></ul><h3 id="Linters"><a href="#Linters" class="headerlink" title="Linters"></a>Linters</h3><p>Linter选择:</p><ul><li>JSLint</li><li>JSHint</li><li><strong>ESLint</strong></li></ul><h3 id="ESLint-Configuration-Decisions-Overview"><a href="#ESLint-Configuration-Decisions-Overview" class="headerlink" title="ESLint Configuration Decisions Overview"></a>ESLint Configuration Decisions Overview</h3><ol><li>Config format?</li><li>Which built-in rules?</li><li>Warnings or errors?</li><li>Which plugins?</li><li>Use preset instead?</li></ol><h3 id="Decision-1-Configuration-File-Fomat"><a href="#Decision-1-Configuration-File-Fomat" class="headerlink" title="Decision 1: Configuration File Fomat"></a>Decision 1: Configuration File Fomat</h3><p>创建ESLint配置文件，或在<code>package.json</code>文件中加入<code>eslintConfig</code>项。</p><h3 id="Decision-2-Which-rules"><a href="#Decision-2-Which-rules" class="headerlink" title="Decision 2: Which rules"></a>Decision 2: Which rules</h3><h3 id="Decision-3-Warnings-or-errors"><a href="#Decision-3-Warnings-or-errors" class="headerlink" title="Decision 3: Warnings or errors"></a>Decision 3: Warnings or errors</h3><ul><li><p>Warnings</p><ul><li>Can continnue development</li><li>Can be ignored</li></ul></li><li><p>Error</p><ul><li>Breaks the build</li><li>Cannot be ignored</li></ul></li></ul><h3 id="Decision-4-Which-plugins"><a href="#Decision-4-Which-plugins" class="headerlink" title="Decision 4: Which plugins"></a>Decision 4: Which plugins</h3><p>React开发推荐：eslint-plugin-react</p><p><a href="https://github.com/dustinspecker/awesome-eslint">Awesome ESLint</a></p><h3 id="Decision-5-Preset"><a href="#Decision-5-Preset" class="headerlink" title="Decision 5: Preset"></a>Decision 5: Preset</h3><ul><li>From scratch</li><li>Recommended</li><li>Presets</li></ul><h3 id="Watching-Files-with-ESLint"><a href="#Watching-Files-with-ESLint" class="headerlink" title="Watching Files with ESLint"></a>Watching Files with ESLint</h3><p>Issue: ESLint doesn’t watch files</p><p>解决方案：</p><ul><li>eslint-loader<ul><li>Re-lint all files upon save</li></ul></li><li>eslint-watch<ul><li>ESLint wrapper that adds file watch</li><li>Not tied to webpack</li><li>Better warning/error formatting</li><li>…</li></ul></li></ul><h3 id="Linting-Experimental-Features"><a href="#Linting-Experimental-Features" class="headerlink" title="Linting Experimental Features"></a>Linting Experimental Features</h3><ul><li>Run ESLint directly<ul><li>Supports ES6 and ES7 natively</li></ul></li><li>Babel-eslint<ul><li>Also lints stage 0-4 features</li></ul></li></ul><p>We’ll use plain ESLint and run it via eslint-watch.</p><h3 id="Why-Lint-Via-an-antomated-Build"><a href="#Why-Lint-Via-an-antomated-Build" class="headerlink" title="Why Lint Via an antomated Build?"></a>Why Lint Via an antomated Build?</h3><ol><li>One place to check</li><li>Universal Configuration</li><li>Part of continuous integration</li></ol><h3 id="Demo-ESLint-Set-Up"><a href="#Demo-ESLint-Set-Up" class="headerlink" title="Demo: ESLint Set Up"></a>Demo: ESLint Set Up</h3><p>ESLint设置：</p><ul><li>ESLint Recommended</li><li>eslint-watch</li></ul><p>添加<code>.eslintrc.json</code>文件，内容如下：</p><p><a href="https://gist.github.com/coryhouse/61f866c7174220777899bcfff03dab7f">GitHubGist</a></p><p>创建调用<code>eslint-watch</code>的 npm script：</p><pre><code>&quot;lint&quot;: &quot;esw webpack.config.* src buildScripts --color&quot;,</code></pre><p>可以使用注释来排除某一个eslint的规则：</p><pre><code>/* eslint-disable no-console */// eslint-disable-line no-console</code></pre><h3 id="Demo-Watching-Files"><a href="#Demo-Watching-Files" class="headerlink" title="Demo: Watching Files"></a>Demo: Watching Files</h3><p>在 lint script 下加一句：</p><pre><code>&quot;lint:watch&quot;: &quot;npm run lint -- --watch&quot;,</code></pre><p>加入 start script 中：</p><pre><code>&quot;start&quot;: &quot;npm-run-all --parallel security-check open:src lint:watch&quot;,</code></pre><h2 id="10-Testing-and-Continuous-Integration"><a href="#10-Testing-and-Continuous-Integration" class="headerlink" title="10. Testing and Continuous Integration"></a>10. Testing and Continuous Integration</h2><h3 id="Test-Decisions-Overview"><a href="#Test-Decisions-Overview" class="headerlink" title="Test Decisions Overview"></a>Test Decisions Overview</h3><table><thead><tr><th>Style</th><th>Focus</th></tr></thead><tbody><tr><td>Unit</td><td>Single function or module</td></tr><tr><td>Integration</td><td>Interations between modules</td></tr><tr><td>UI</td><td>Automate interaations with UI</td></tr></tbody></table><h3 id="Decision-1-Testing-Framework"><a href="#Decision-1-Testing-Framework" class="headerlink" title="Decision 1: Testing Framework"></a>Decision 1: Testing Framework</h3><ul><li><strong>Mocha</strong></li><li>Jasmine</li><li>Tape</li><li>QUnit</li><li>AVA</li><li>Jest</li></ul><p>以上任一皆可。</p><h3 id="Decision-2-Assertion-Libries"><a href="#Decision-2-Assertion-Libries" class="headerlink" title="Decision 2: Assertion Libries"></a>Decision 2: Assertion Libries</h3><p>Jasmine and Jest have assertion libries built in.</p><p>Assertion: Declare what you expect</p><pre><code>eg. expect(2 + 2).to.equal(4)</code></pre><ul><li><strong>Chai</strong></li><li>Should.js</li><li>expect</li></ul><h3 id="Decision-3-Helper-Libraries"><a href="#Decision-3-Helper-Libraries" class="headerlink" title="Decision 3: Helper Libraries"></a>Decision 3: Helper Libraries</h3><ul><li><p>JSOM: Simulate the browser’s DOM</p></li><li><p>Cheerio: jQuery for the server</p></li></ul><h3 id="Decision-4-Where-to-run-tests"><a href="#Decision-4-Where-to-run-tests" class="headerlink" title="Decision 4: Where to run tests"></a>Decision 4: Where to run tests</h3><ul><li>Browser: Karma, Testem</li><li>Headless Browser: PhantomJS</li><li>In-mermory DOM: <strong>JSDOM</strong></li></ul><h3 id="Decision-5-Where-do-test-files-belong"><a href="#Decision-5-Where-do-test-files-belong" class="headerlink" title="Decision 5: Where do test files belong"></a>Decision 5: Where do test files belong</h3><ul><li>Centralized: in a folder called ‘test’<ul><li>Less “noise” in src folder</li><li>Deployment confusion</li><li>Inertia</li></ul></li><li>Alongside<ul><li>Easy imports</li><li>Clear visibility</li><li>Conventient to open</li><li>…</li></ul></li></ul><h3 id="Decision-6-When-should-tests-run"><a href="#Decision-6-When-should-tests-run" class="headerlink" title="Decision 6: When should tests run?"></a>Decision 6: When should tests run?</h3><ul><li>Unit tests should run when you hit save<ul><li>Rapid feedback</li></ul></li><li>Interation tests often run on demand, or in QA</li></ul><h3 id="Demo-Testing-Setup"><a href="#Demo-Testing-Setup" class="headerlink" title="Demo: Testing Setup"></a>Demo: Testing Setup</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** buildScripts/testSetup.js */</span></span><br><span class="line"><span class="comment">// Register babel to transpile before our test run.</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;babel-register&#x27;</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable webpack features that Mocha doesn&#x27;t understand.</span></span><br><span class="line"><span class="built_in">require</span>.extensions[<span class="string">&#x27;.css&#x27;</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add &quot;test&quot; scripts in package.json</span></span><br><span class="line"><span class="string">&quot;test&quot;</span>: <span class="string">&quot;mocha --reporter progress buildScripts/testSetup.js \&quot;src/**/*.test.js\&quot; &quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/index.test.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">&#x27;chai&#x27;</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;Our first test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&#x27;should pass&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(<span class="literal">true</span>).to.equal(<span class="literal">true</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Demo-DOM-Testing"><a href="#Demo-DOM-Testing" class="headerlink" title="Demo: DOM Testing"></a>Demo: DOM Testing</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsdom <span class="keyword">from</span> <span class="string">&#x27;jsdom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;index.html&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&#x27;should say hello&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = fs.readFileSync(<span class="string">&#x27;./src/index.html&#x27;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    jsdom.env(index, <span class="function"><span class="keyword">function</span>(<span class="params">err, <span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> h1 = <span class="built_in">window</span>.document.getElementsByTagName(<span class="string">&#x27;h1&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">      expect(h1.innerHTML).to.equal(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">      done();</span><br><span class="line">      <span class="built_in">window</span>.close();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Demo-Watching-Tests"><a href="#Demo-Watching-Tests" class="headerlink" title="Demo: Watching Tests"></a>Demo: Watching Tests</h3><p>Add this script to <code>package.json</code>:</p><pre><code>&quot;test:watch&quot;: &quot;npm run test -- --watch&quot;</code></pre><p>Then add <code>test:watch</code> to the end of <code>start</code> script:</p><pre><code>&quot;start&quot;: &quot;npm-run-all --parallel security-check open:src lint:watch test:watch&quot;</code></pre><h3 id="Why-Continuous-Integration"><a href="#Why-Continuous-Integration" class="headerlink" title="Why Continuous Integration?"></a>Why Continuous Integration?</h3><p>When team commits code, confirm immediately that the commit works as expected when on another machine.</p><h3 id="What-Does-Continuous-Integration-Do"><a href="#What-Does-Continuous-Integration-Do" class="headerlink" title="What Does Continuous Integration Do?"></a>What Does Continuous Integration Do?</h3><ul><li>Run automated build</li><li>Run your tests</li><li>Check code coverage</li><li>Automate deployment</li></ul><h3 id="Choosing-a-CI-Server"><a href="#Choosing-a-CI-Server" class="headerlink" title="Choosing a CI Server"></a>Choosing a CI Server</h3><ul><li><strong>Travis</strong>: Linux based</li><li><strong>Appveyor</strong>: Windows based</li><li>Jenkins</li><li>CircleCI</li><li>Semaphore</li><li>SnapCI</li></ul><h3 id="Demo-Travis-CI"><a href="#Demo-Travis-CI" class="headerlink" title="Demo: Travis CI"></a>Demo: Travis CI</h3><p>使用GitHub账号登录<a href="https://travis-ci.org/">Travis CI</a>，即可选择你在GitHub上的项目进行持续集成。</p><p>需要在项目中加入travis的配置文件<code>.travis.yml</code>：</p><pre><code>language: node_jsnode_js:  - &quot;6&quot;</code></pre><h3 id="Demo-Appveyor"><a href="#Demo-Appveyor" class="headerlink" title="Demo: Appveyor"></a>Demo: Appveyor</h3><h2 id="11-HTTP-Calls"><a href="#11-HTTP-Calls" class="headerlink" title="11. HTTP Calls"></a>11. HTTP Calls</h2><h3 id="HTTP-Call-Approaches"><a href="#HTTP-Call-Approaches" class="headerlink" title="HTTP Call Approaches"></a>HTTP Call Approaches</h3><ul><li>Node<ul><li>http</li><li>request</li></ul></li><li>Browser<ul><li>XMLHttpRequest</li><li>jQuery</li><li>Framework-based</li><li>Fetch</li></ul></li><li>Node &amp; Browser<ul><li>isomorphic-fetch</li><li>xhr</li><li>superagent</li><li>axios</li></ul></li></ul><h3 id="Centralizing-HTTP-Requests"><a href="#Centralizing-HTTP-Requests" class="headerlink" title="Centralizing HTTP Requests"></a>Centralizing HTTP Requests</h3><p>Why?</p><ul><li>Configure all calls</li><li>Handle preloader logic</li><li>Handle errors</li><li>Single seam for mocking</li></ul><h3 id="Demo-Fetch"><a href="#Demo-Fetch" class="headerlink" title="Demo: Fetch"></a>Demo: Fetch</h3><p>修改 <code>srcServer.js</code> 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/users&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.json([</span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>,<span class="string">&quot;firstName&quot;</span>:<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;lastName&quot;</span>:<span class="string">&quot;Smith&quot;</span>,<span class="string">&quot;email&quot;</span>:<span class="string">&quot;bob@gmail.com&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">2</span>,<span class="string">&quot;firstName&quot;</span>:<span class="string">&quot;Tammy&quot;</span>,<span class="string">&quot;lastName&quot;</span>:<span class="string">&quot;Norton&quot;</span>,<span class="string">&quot;email&quot;</span>:<span class="string">&quot;tnorton@yahoo.com&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">3</span>,<span class="string">&quot;firstName&quot;</span>:<span class="string">&quot;Tina&quot;</span>,<span class="string">&quot;lastName&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;email&quot;</span>:<span class="string">&quot;lee.tina@hotmail.com&quot;</span>&#125;</span><br><span class="line">  ]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>加入 userApi.js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;whatwg-fetch&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(<span class="string">&#x27;users&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(url).then(onSuccess, onError);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onSuccess</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error); <span class="comment">// eslint-disable-line no-console</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时打开<code>localhost:3000/users</code>，能查看API结果。</p><h3 id="Selective-Polyfilling"><a href="#Selective-Polyfilling" class="headerlink" title="Selective Polyfilling"></a>Selective Polyfilling</h3><p>Polyfill.io: Only send polyfill to those who need it</p><h3 id="Why-Mock-HTTP"><a href="#Why-Mock-HTTP" class="headerlink" title="Why Mock HTTP?"></a>Why Mock HTTP?</h3><ul><li>Unit Testing</li><li>Instant response</li><li>Keep working when services are down</li><li>Rapid prototyping</li><li>Avoid inter-team bottlenecks</li><li>Work offline</li></ul><h3 id="How-to-Mock-HTTP"><a href="#How-to-Mock-HTTP" class="headerlink" title="How to Mock HTTP"></a>How to Mock HTTP</h3><ul><li>Nock</li><li>Static JSON</li><li>Create development webserver<ul><li>api-mock</li><li>JSON server</li><li>JSON Schema faker</li><li>Browsersync</li><li>Express, etc</li></ul></li></ul><h3 id="Our-Plan-for-Mocking"><a href="#Our-Plan-for-Mocking" class="headerlink" title="Our Plan for Mocking"></a>Our Plan for Mocking</h3><ol><li>Declare our schema:<ul><li>JSON Schema Faker</li></ul></li><li>Generate Random Data:<ul><li>faker.js</li><li>chance.js</li><li>randexp.js</li></ul></li><li>Serve Data via API<ul><li>JSON Server</li></ul></li></ol><h3 id="Mocking-Libraries"><a href="#Mocking-Libraries" class="headerlink" title="Mocking Libraries"></a>Mocking Libraries</h3><p>JSON Schema Faker</p><p>JSON Server</p><h3 id="Demo-Creating-a-Mock-API-Data-Schema"><a href="#Demo-Creating-a-Mock-API-Data-Schema" class="headerlink" title="Demo: Creating a Mock API Data Schema"></a>Demo: Creating a Mock API Data Schema</h3><ul><li>Mock HTTP</li></ul><p>创建文件：<code>buildScripts/mockDataSchema.js</code>文件，内容如下：bit.ly/ps-mock-data-schema</p><h3 id="Demo-Generating-Mock-Data"><a href="#Demo-Generating-Mock-Data" class="headerlink" title="Demo: Generating Mock Data"></a>Demo: Generating Mock Data</h3><p>在<code>buildScripts</code>中新建文件<code>generateMockData.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buildScripts/generateMockData.js</span></span><br><span class="line"><span class="keyword">import</span> jsf <span class="keyword">from</span> <span class="string">&#x27;json-schema-faker&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; schema &#125; <span class="keyword">from</span> <span class="string">&#x27;./mockDataSchema&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">&#x27;chalk&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = <span class="built_in">JSON</span>.stringify(jsf(schema));</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">&quot;./src/api/db.json&quot;</span>, json, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(chalk.red(err));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.green(<span class="string">&quot;Mock data generated&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在<code>package.json</code>中加入<code>generate-mock-data</code> script:</p><pre><code>&quot;generate-mock-data&quot;: &quot;babel-node buildScripts/generateMockData&quot;</code></pre><p>运行<code>npm run generate-mock-data</code>，会生成一个<code>db.json</code>文件。</p><h3 id="Demo-Serving-Mock-Data-via-JSON-Server"><a href="#Demo-Serving-Mock-Data-via-JSON-Server" class="headerlink" title="Demo: Serving Mock Data via JSON Server"></a>Demo: Serving Mock Data via JSON Server</h3><p>Add script:</p><pre><code>&quot;start-mockapi&quot;: &quot;json-server --watch src/api/db.json --port 3001&quot;</code></pre><p>json-server 会将<code>db.json</code>中的内容生成一个API，如下为运行后输出内容。</p><pre><code>Loading src/api/db.jsonDoneResourceshttp://localhost:3001/usersHomehttp://localhost:3001</code></pre><p>在开发环境中需要将API换成 mock api。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/api</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getBaseUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inDevelopment = <span class="built_in">window</span>.location.hostname === <span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> inDevelopment ? <span class="string">&#x27;http://localhost:3001/&#x27;</span> : <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return fetch(url).then(onSuccess, onError);</span></span><br><span class="line">  <span class="keyword">return</span> fetch(baseUrl + url).then(onSuccess, onError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Demo-Manipulating-Data-via-JSON-Server"><a href="#Demo-Manipulating-Data-via-JSON-Server" class="headerlink" title="Demo: Manipulating Data via JSON Server"></a>Demo: Manipulating Data via JSON Server</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/api</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteUser</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> del(<span class="string">`users/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> request = <span class="keyword">new</span> Request(baseUrl + url, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;DELETE&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fetch(request).then(onSuccess, onError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="12-Project-Structure"><a href="#12-Project-Structure" class="headerlink" title="12. Project Structure"></a>12. Project Structure</h2><h3 id="Why-a-Demo-App"><a href="#Why-a-Demo-App" class="headerlink" title="Why a Demo App?"></a>Why a Demo App?</h3><p>Examples of:</p><ul><li>Directory structure and file naming</li><li>Framework usage</li><li>Testing</li><li>Mock API</li><li>Automated deployment</li></ul><h3 id="Tip-1-JS-Belongs-in-a-js-File"><a href="#Tip-1-JS-Belongs-in-a-js-File" class="headerlink" title="Tip 1: JS Belongs in a .js File"></a>Tip 1: JS Belongs in a .js File</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// dont&#x27;t put code here</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="Tip-2-Consider-Organizing-by-Feature"><a href="#Tip-2-Consider-Organizing-by-Feature" class="headerlink" title="Tip 2: Consider Organizing by Feature"></a>Tip 2: Consider Organizing by Feature</h3><h3 id="Tip-3-Extract-Logic-to-POJOs"><a href="#Tip-3-Extract-Logic-to-POJOs" class="headerlink" title="Tip 3: Extract Logic to POJOs"></a>Tip 3: Extract Logic to POJOs</h3><p>POJOs: Plain Old JavaScript Objects, Pure logic, No framework-specific code</p><h2 id="13-Production-Build"><a href="#13-Production-Build" class="headerlink" title="13. Production Build"></a>13. Production Build</h2><h3 id="Minification-and-Sourcemaps"><a href="#Minification-and-Sourcemaps" class="headerlink" title="Minification and Sourcemaps"></a>Minification and Sourcemaps</h3><h3 id="Demo-Production-Webpack-Configuration-with-Minification"><a href="#Demo-Production-Webpack-Configuration-with-Minification" class="headerlink" title="Demo: Production Webpack Configuration with Minification"></a>Demo: Production Webpack Configuration with Minification</h3><p>新建<code>webpack.config.prod.js</code>，相比<code>webpack.config.dev.js</code>加入plugin：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// Eliminate duplicate packages when generating bundle</span></span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.DedupePlugin(),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Minify JS</span></span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>新建<code>buildScripts/build.js</code>文件。</p><h3 id="Demo-Configure-Local-dist-Server"><a href="#Demo-Configure-Local-dist-Server" class="headerlink" title="Demo: Configure Local/dist Server"></a>Demo: Configure Local/dist Server</h3><p>新建<code>buildScripts/distServer.js</code>文件，用于 static files。</p><h3 id="Demo-Toggle-Mock-API"><a href="#Demo-Toggle-Mock-API" class="headerlink" title="Demo: Toggle Mock API"></a>Demo: Toggle Mock API</h3><h3 id="Demo-Production-Build-npm-Scripts"><a href="#Demo-Production-Build-npm-Scripts" class="headerlink" title="Demo: Production Build npm Scripts"></a>Demo: Production Build npm Scripts</h3><h3 id="Dynamic-HTML-Generation"><a href="#Dynamic-HTML-Generation" class="headerlink" title="Dynamic HTML Generation"></a>Dynamic HTML Generation</h3><h3 id="Bundle-Splitting"><a href="#Bundle-Splitting" class="headerlink" title="Bundle Splitting"></a>Bundle Splitting</h3><h3 id="Cache-Busting"><a href="#Cache-Busting" class="headerlink" title="Cache Busting"></a>Cache Busting</h3><h3 id="Demo-Extract-and-Minify-CSS"><a href="#Demo-Extract-and-Minify-CSS" class="headerlink" title="Demo: Extract and Minify CSS"></a>Demo: Extract and Minify CSS</h3><h3 id="Error-Logging"><a href="#Error-Logging" class="headerlink" title="Error Logging"></a>Error Logging</h3><h2 id="14-Production-Deploy"><a href="#14-Production-Deploy" class="headerlink" title="14. Production Deploy"></a>14. Production Deploy</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客是我在学习 &lt;a href=&quot;https://app.pluralsight.com/library/courses/javascript-development-environment/recommended-courses&quot;&gt;Pluralsight上的课程：Building a JavaScript Development Environment&lt;/a&gt; 时记下的笔记，仅作个人记录之用。&lt;/p&gt;
&lt;p&gt;这门课程系统地介绍了前端开发中的许多工具和术语，从编辑器的选择到项目的部署都进行了介绍，我在学习了这个课程后感觉将之前零散学习的内容串了起来。&lt;/p&gt;
&lt;p&gt;顺便一说，Pluralsight网站上面有许多不错的课程，不过价格太贵，需每月付29美元😥。但是，你可以用微软账号加入&lt;a href=&quot;https://www.visualstudio.com/zh-hans/dev-essentials/&quot;&gt;Visual Studio Dev Essentials 计划&lt;/a&gt;，这样就可以免费获得Pluralsight 3个月的订阅了😀。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-Course-Overview&quot;&gt;&lt;a href=&quot;#1-Course-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Course Overview&quot;&gt;&lt;/a&gt;1. Course Overview&lt;/h2&gt;&lt;p&gt;编程的时候要做许多选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Editor&lt;/li&gt;
&lt;li&gt;Module format&lt;/li&gt;
&lt;li&gt;HTML generation&lt;/li&gt;
&lt;li&gt;Transpiling&lt;/li&gt;
&lt;li&gt;Bundler&lt;/li&gt;
&lt;li&gt;Linting&lt;/li&gt;
&lt;li&gt;Testing&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这门课程介绍了如何在这些选项中做出选择&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="webpack" scheme="http://www.wukai.me/tags/webpack/"/>
    
      <category term="npm" scheme="http://www.wukai.me/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>从头创建一个基于 React, webpack, babel 的模板项目</title>
    <link href="http://www.wukai.me/2016/09/14/create-a-react-webpack-es6-project/"/>
    <id>http://www.wukai.me/2016/09/14/create-a-react-webpack-es6-project/</id>
    <published>2016-09-13T16:00:00.000Z</published>
    <updated>2022-02-16T13:57:16.004Z</updated>
    
    <content type="html"><![CDATA[<p>如果是一个刚接触 React 的新手，当学完了 React 的各种基本概念和语法之后，准备开始实际的开发工作时，他又会碰到各种新颖的名词：npm, webpack, babel, flux, es2015…… 如果以前接触过这些工具还好，否则为了建立一个简单的项目，还需要学习这一整套的流程，而在这中间又会碰上各种坑，这个过程将会非常痛苦。一个解决方案是去 GitHub 上寻找各种模板项目，用 React + webpack + … 作为关键字搜索可以发现许多别人创建的空项目，你可以在其基础上稍作修改然后开始开发。我在学习的过程中就是这么做的，但之后对其中的一些配置项仍是一知半解。</p><p>我在这里从头开始创建一个模板项目，并将过程记录下来，一方面希望能给看到这篇文章的人以帮助，另一方面也是加深我自己的理解。</p><p>最后完成的项目见这个项目：<a href="https://github.com/noiron/react-webpack-babel-boilerplate">react-webpack-babel-boilerplate</a>，在建立这个项目过程中的步骤可见另一个项目：<a href="https://github.com/noiron/create-react-boilerplate-steps">create-react-boilerplate-steps</a>，过程被分到了多个文件夹中。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>在开始之前先看看项目的文件结构：</p><pre><code>- src  - index.js  - App.js- .babelrc- index.html- package.json- server.js- webpack.config.js</code></pre><p>以上就是我们的项目需要的全部文件了。</p><p>接下来我会将这个项目的构建过程分解成几个步骤，你只要按照这些步骤依次进行即可。</p><span id="more"></span><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>首先我们新建一个名为 react-webpack-boilerplate 的文件夹，然后需要在命令行下对项目进行初始化。</p><p>你需要到 Node.js 的官网上下载 node.js 并安装，如果你已经对 NPM 有了基本的了解，可以在命令行下进入项目目录运行：</p><pre><code>npm init</code></pre><p>之后你需要按照提示输入你的项目的基本信息，这里也可以一直回车，则选择默认选项，或者运行：</p><pre><code>npm init -y    // 所有信息都按照默认设置</code></pre><p><code>npm init</code> 命令的作用就是初始化一个项目，你可以发现项目文件夹内多出了一个 <code>package.json</code> 文件，它的内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照默认设置生成的 package.json 文件</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;react-webpack-boilerplate&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目的运行需要依赖各种 npm 包，需要在文件的 “dependencies” 或 “devDependencies” 项下写明 npm 包的名称及版本。现在这个项目还是空的，所以这里还没有这两项。</p><p>由于直接用 npm 安装的速度很慢，我们可以考虑用 cnpm install 命令来代替 npm install 命令。</p><p>CNPM 是淘宝建立的一个 NPM 镜像，由于服务器在国内，速度自然也就快多了。</p><pre><code>// 安装 cnpm$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>完成后，你就可以用 cnpm install 来安装所需的 npm 包了。</p><blockquote><p><a href="https://npm.taobao.org/">淘宝 NPM 镜像</a></p></blockquote><h2 id="安装及配置-webpack"><a href="#安装及配置-webpack" class="headerlink" title="安装及配置 webpack"></a>安装及配置 webpack</h2><h3 id="webpack-是什么？"><a href="#webpack-是什么？" class="headerlink" title="webpack 是什么？"></a>webpack 是什么？</h3><p>webpack 是一个打包工具，它能够将各种资源如 js、css、图片作为模块载入并进行打包。你可以从<a href="https://github.com/petehunt/webpack-howto">GitHub上这个教程</a><br>开始学习 webpack 的基本用法。</p><h3 id="webpack-的安装"><a href="#webpack-的安装" class="headerlink" title="webpack 的安装"></a>webpack 的安装</h3><p>在命令行下面运行：</p><pre><code>$ npm install webpack --save-dev</code></pre><p>这一句的作用的是给项目安装 webpack，现在查看项目文件夹，会发现多出了一个 <code>node_modules</code> 文件夹，这里就是存放项目所依赖的 npm 包的地方。</p><p>上面的这条命令后面跟着的 <code>--save-dev</code>，表示将会把 webpack 的名称写入 <code>package.json</code> 文件中。我们打开 <code>package.json</code> 文件，发现文件中多了一项：</p><pre><code>&quot;devDependencies&quot;: &#123;    &quot;webpack&quot;: &quot;^1.13.2&quot;&#125;</code></pre><p><code>--save-dev</code> 表示会写入 “devDependencies” 项中，而 <code>--save</code> 写入的是 “dependencies” 项。</p><h3 id="webpack-的测试"><a href="#webpack-的测试" class="headerlink" title="webpack 的测试"></a>webpack 的测试</h3><p>你可以选择将 webpack 安装在全局中，或者安装在这一个项目中。全局安装时需要在命令后面加上 <code>-global</code> 或 <code>-g</code> 参数，这样你可以直接在命令行中使用 webpack 命令了。</p><p>选择全局安装：</p><pre><code>$ cnpm install webpack -g </code></pre><p>既然我们已经将 webpack 安装在了全局，那就先在命令行下测试一下它的打包功能。</p><p>新建 <code>index.js</code> 文件，里面只有一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;This is a javascript file for test.&#x27;</span>);</span><br></pre></td></tr></table></figure><p>运行一个最简单的 webpack 命令：</p><pre><code>$ webpack index.js bundle.js</code></pre><p>它的意思是将 <code>index.js</code> 文件打包成名为 <code>bundle.js</code> 的文件，后一个参数是你想要生成的文件名称。</p><p>运行之后会发现多出了一个 <code>bundle.js</code> 文件，用 node 运行该文件测试一下：</p><pre><code>$ node bundle.jsThis is a javascript file for test.    // 输出了正确的结果</code></pre><p>可以新建一个 html 文件，引入 <code>bundle.js</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>react webpack boilerplate<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开 <code>index.html</code>，你可以在浏览器的控制台中看到输出结果。</p><h3 id="webpack-的配置文件"><a href="#webpack-的配置文件" class="headerlink" title="webpack 的配置文件"></a>webpack 的配置文件</h3><p>我们可以在命令行下完成各种复杂的 webpack 操作，不过更方便的方法是利用配置文件。</p><p>新建 <code>webpack.config.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的 webpack.config.js 文件</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// webpack 进行打包的入口文件，这里 webpack 从根目录下的 index.js 开始进行打包</span></span><br><span class="line">  <span class="attr">entry</span>: [</span><br><span class="line">    <span class="string">&#x27;./index&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// webpack 打包后的输出文件的路径</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 文件放至当前路径下的 dist 文件夹</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,  <span class="comment">// 将打包后的输出文件命名为 bundle.js</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>html 文件的引用路径相应地改成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再将 webpack 安装在本地：</p><pre><code>$ npm install webpack --save-dev</code></pre><p>现在你可以运行 <code>webpack</code> 看看效果了。</p><p>我们在上面的过程虽然称之为打包，但是我们只不过将一个 <code>index.js</code> 文件变成了 <code>bundle.js</code> 文件，文件的体积甚至还变大了。那看一下如果我们有两个 js 文件是如何处理的。</p><p>新建 <code>a.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = a;</span><br></pre></td></tr></table></figure><p>在 index.js 中加入下列语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span>, a);</span><br></pre></td></tr></table></figure><p>再次用 <code>webpack</code> 命令打包，生成了新的 <code>bundle.js</code> 文件。好了，现在我们不需要用 <code>script</code> 标签分别来引入 <code>index.js</code> 和 <code>a.js</code> 两个文件了，直接引入 <code>bundle.js</code> 这一个就行了。如果我们有许多引用的资源，经过这样的打包过程，自然就方便多了。</p><p>以上的步骤可以在 step1 文件夹内查看。</p><h3 id="安装-web-dev-server，并用其开启一个服务器"><a href="#安装-web-dev-server，并用其开启一个服务器" class="headerlink" title="安装 web-dev-server，并用其开启一个服务器"></a>安装 web-dev-server，并用其开启一个服务器</h3><p>首先运行如下命令，安装 web-dev-server：</p><pre><code>$ npm i webpack-dev-server --save-dev</code></pre><p>添加如下的 server.js 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> WebpackDevServer = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-server&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> WebpackDevServer(webpack(config));</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="string">&#x27;localhost&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;listening at locahost:3000...&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> WebpackDevServer(webpack(config));</span><br></pre></td></tr></table></figure><p>这一句创建了一个 webpack dev server，这是一个 node.js express 服务器，关于它的用法可以见<a href="https://webpack.github.io/docs/webpack-dev-server.html">这里的文档</a>。</p><p>在 webpack.config.js 的 output 这一项中加上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publicPath: <span class="string">&#x27;/static/&#x27;</span></span><br></pre></td></tr></table></figure><p>server.js 修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> WebpackDevServer(webpack(config), &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: config.output.publicPath</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>好了，现在你可以运行：</p><pre><code>$ node server.js</code></pre><p>然后打开浏览器进入 <a href="http://localhost:3000">http://localhost:3000</a> 查看效果了（当然，现在除了在控制台输出了信息之外什么都没干）</p><p>在 <code>package.json</code> 文件内加上这么一项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;node server.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>你可以用 <code>npm start</code> 来代替上面的 <code>node server.js</code> 了，这两者是等价的。</p><p>上述步骤可以到 step2 文件夹中查看，运行下列命令：</p><pre><code>$ npm i$ npm start</code></pre><blockquote><p>webpack 的参考资料：<br><a href="https://webpack.github.io/docs/tutorials/getting-started/">https://webpack.github.io/docs/tutorials/getting-started/</a><br><a href="https://medium.com/@rajaraodv/webpack-the-confusing-parts-58712f8fcad9#.81jvwhvmo">https://medium.com/@rajaraodv/webpack-the-confusing-parts-58712f8fcad9#.81jvwhvmo</a><br><a href="http://www.cnblogs.com/skylar/p/webpack-module-bundler.html">http://www.cnblogs.com/skylar/p/webpack-module-bundler.html</a></p></blockquote><h2 id="关于-Babel"><a href="#关于-Babel" class="headerlink" title="关于 Babel"></a>关于 Babel</h2><h3 id="Babel-是什么？"><a href="#Babel-是什么？" class="headerlink" title="Babel 是什么？"></a>Babel 是什么？</h3><p>因为在 React 的项目中会用到 ES6(即ES2015) 的语法，而 ES6 还没有得到广泛的支持，所以我们需要借用 Babel 这个工具将我们使用了 ES6 语法的代码转换成 ES5 的语法，从而可以在更广泛的环境下运行。</p><blockquote><p><a href="https://babeljs.io/">Babel 的官方网站</a></p></blockquote><h3 id="怎么安装-Babel？"><a href="#怎么安装-Babel？" class="headerlink" title="怎么安装 Babel？"></a>怎么安装 Babel？</h3><p>在我们的项目中，需要安装这样的几个 package：</p><pre><code>$ npm install --save-dev babel-loader babel-core</code></pre><p>在 Babel 6.x 之前的版本中，Babel 会执行一些默认的转换规则，而在 6.x 之后的版本，你需要显示地告诉 babel 你想执行什么转换。最简单的方法就是使用 preset，比如说 ES2015 Preset。</p><pre><code>$ npm install babel-preset-es2015 --save-dev</code></pre><blockquote><p>Presets are sharable .babelrc configs or simply an array of babel plugins.</p></blockquote><p>我们这里还需要另一个名为 stage-0 的 Preset：</p><pre><code>$ npm install babel-preset-es2015 --save-dev</code></pre><blockquote><p>参考文档：<br><a href="https://babeljs.io/docs/setup/#installation">Babel 的安装</a><br><a href="https://babeljs.io/docs/plugins/#presets">Presets</a></p></blockquote><p>现在只要添加一个 .babelrc 文件即可，<a href="https://babeljs.io/docs/usage/babelrc/">babelrc</a> 是 Babel 的配置文件，你可以在<a href="http://babeljs.io/docs/usage/options/">这个页面</a>找到你可以加入文件中的各种选项。</p><p>这里只需在 .babelrc 中写入如下内容即可：</p><pre><code>&#123;  &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-0&quot;]&#125;</code></pre><p>将 webpack.config.js 文件做如下的修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">loaders</span>: [&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loaders: [<span class="string">&#x27;babel&#x27;</span>],</span><br><span class="line">    <span class="attr">include</span>: path.join(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">stats</span>: <span class="string">&#x27;errors-only&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以在我们的项目使用 babel 来进行转码了。</p><p>这一步可在 step 3 中查看。</p><h2 id="安装-React"><a href="#安装-React" class="headerlink" title="安装 React"></a>安装 React</h2><p>既然你在看这篇文章，相信你已经对 React 有了一定的了解，React 是做什么的就不用再多介绍了。</p><p>安装 React 的 package 十分简单：</p><pre><code>$ npm install react react-dom --save</code></pre><p>为了能够让 babel 对 react 进行处理，再安装一个 babel-preset-react</p><pre><code>$ npm install babel-preset-react</code></pre><p>同时在 .babelrc 文件中也加入这一项：</p><pre><code>&quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-0&quot;, &quot;react&quot;]</code></pre><p>新建一个基本的 React 组件试试看：</p><p>首先在 index.html 中加上这样的一个元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React 元素将在上面渲染。</p><p>在 src 文件夹下新建两个文件 App.js index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./src/index.js</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./src/App.js</span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;%c%s&#x27;</span>, <span class="string">&#x27;font-size:20px;color:red&#x27;</span>, <span class="string">&#x27;Something happened.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>This is a react boilerplate project with webpack and es6.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你可以 npm start 看看效果了。</p><p>以上内容可以在 step4 文件夹中查看。</p><h2 id="安装-react-hot-loader"><a href="#安装-react-hot-loader" class="headerlink" title="安装 react-hot-loader"></a>安装 react-hot-loader</h2><p>其实到上一步为止，我们已经完成了一个完整的 react 模板项目，不过还缺一点，就是当我们在编辑器中修改了文件的时候，需要在浏览器里手动刷新，才能看到结果。我们可以利用一个名为 react-hot-loader 的工具来帮助我们实现浏览器自动刷新的效果。</p><p>首先安装 react-hot-loader:</p><pre><code>npm install react-hot-loader@^1.3.0 --save-dev</code></pre><p>这里加上了版本号是因为默认安装最新的 react-hot-loader v3.0.0-beta 版本，设置会和下面的有所区别。</p><p>在 server.js 中加一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> WebpackDevServer(webpack(config), &#123;</span><br><span class="line">  <span class="attr">stats</span>: config.devServer.stats,</span><br><span class="line">  <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">publicPath</span>: config.output.publicPath</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对 webpack.config.js 做如下修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">entry: [</span><br><span class="line">  <span class="string">&#x27;webpack-dev-server/client?http://localhost:3000&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;webpack/hot/only-dev-server&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;./src/index&#x27;</span></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="attr">loaders</span>: [&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  loaders: [<span class="string">&#x27;react-hot&#x27;</span>, <span class="string">&#x27;babel&#x27;</span>],</span><br><span class="line">  <span class="attr">include</span>: path.join(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>并加入一个插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这一步的内容可以查看 step5 文件夹。</p><hr><p>到此我们的这个模板项目就完成了。你可以在<a href="https://github.com/noiron/react-webpack-babel-boilerplate">GitHub上的这个项目中</a>看到完整的项目代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果是一个刚接触 React 的新手，当学完了 React 的各种基本概念和语法之后，准备开始实际的开发工作时，他又会碰到各种新颖的名词：npm, webpack, babel, flux, es2015…… 如果以前接触过这些工具还好，否则为了建立一个简单的项目，还需要学习这一整套的流程，而在这中间又会碰上各种坑，这个过程将会非常痛苦。一个解决方案是去 GitHub 上寻找各种模板项目，用 React + webpack + … 作为关键字搜索可以发现许多别人创建的空项目，你可以在其基础上稍作修改然后开始开发。我在学习的过程中就是这么做的，但之后对其中的一些配置项仍是一知半解。&lt;/p&gt;
&lt;p&gt;我在这里从头开始创建一个模板项目，并将过程记录下来，一方面希望能给看到这篇文章的人以帮助，另一方面也是加深我自己的理解。&lt;/p&gt;
&lt;p&gt;最后完成的项目见这个项目：&lt;a href=&quot;https://github.com/noiron/react-webpack-babel-boilerplate&quot;&gt;react-webpack-babel-boilerplate&lt;/a&gt;，在建立这个项目过程中的步骤可见另一个项目：&lt;a href=&quot;https://github.com/noiron/create-react-boilerplate-steps&quot;&gt;create-react-boilerplate-steps&lt;/a&gt;，过程被分到了多个文件夹中。&lt;/p&gt;
&lt;h2 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h2&gt;&lt;p&gt;在开始之前先看看项目的文件结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- src
  - index.js
  - App.js
- .babelrc
- index.html
- package.json
- server.js
- webpack.config.js
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上就是我们的项目需要的全部文件了。&lt;/p&gt;
&lt;p&gt;接下来我会将这个项目的构建过程分解成几个步骤，你只要按照这些步骤依次进行即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://www.wukai.me/tags/webpack/"/>
    
      <category term="es6" scheme="http://www.wukai.me/tags/es6/"/>
    
      <category term="react" scheme="http://www.wukai.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>用 React.js 写一个最简单的 To-do List 应用</title>
    <link href="http://www.wukai.me/2016/06/19/write-a-simplest-todolist-with-reactjs/"/>
    <id>http://www.wukai.me/2016/06/19/write-a-simplest-todolist-with-reactjs/</id>
    <published>2016-06-18T16:00:00.000Z</published>
    <updated>2022-02-16T13:57:16.004Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间忙着找工作去了，有段时间没有写博客了，上一篇还是三月份的，今天来更新一篇。</p><hr><p>最近在学 React.js，也写了一些练习的项目，之前参考网上的一些代码写了一个很简单的 to-do list。对于初学者来说，写个基本的 to-do list 对于理解 React 中的一些概念及语法倒是挺有帮助的。</p><p>现在很多的 React 项目中已经开始使用 ES6 来写了，不过因为我在学习 React 的时候看的教程大多都是用 ES5 写的，我这里还是用的还是更熟悉的 ES5 写法，虽然有点落伍了，但若想改成 ES6 版本倒也挺方便的。</p><blockquote><p><a href="https://github.com/noiron/simplest-react-todolist">GitHub 上的项目地址</a><br><a href="http://www.wukai.me/simplest-react-todolist">在线 demo</a></p></blockquote><span id="more"></span><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>在正式的生产项目中，使用 webpack 可以很方便地对我们的文件进行打包，这里因为程序比较简单，直接用 <code>&lt;script&gt;</code> 标签将 React 组件引入了。</p><p>首先新建一个 <code>index.html</code> 文件，引入相关的资源文件。</p><p>再新建一个 <code>js</code> 文件夹，我们使用 React 需要这样的两个文件： <code>react.js</code> 和 <code>react-dom.js</code>，你可以使用 cdn 引入，这里直接将文件下载放在了 <code>js</code> 文件夹内。</p><p><code>js</code> 文件夹内还有一个 <code>script.jsx</code> 文件，我们程序的主要内容就放在这个文件中。注意这里的后缀名是 <code>jsx</code>，表示它是使用 React 的 <code>jsx</code> 语法来写的，引入它的时候按如下写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/script.jsx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时还需要一个 <code>browser.js</code> 文件，它可以让 <code>jsx</code> 语法的文件在浏览器中运行。</p><p>最后我们再建立一个 <code>css</code> 文件夹，存放样式文件，我的项目中使用了 Bootstrap 的样式，所以需要下载 Bootstrap 的样式文件。</p><h2 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h2><p>作为一个最简单的 to-do list，这个程序没有过多的功能。可以从 <a href="http://www.wukai.me/simplest-react-todolist/">demo</a> 里看出，它的功能如下：</p><ul><li><p>显示每一个任务</p></li><li><p>可以将任务标记为已完成，以区分未完成的任务</p></li><li><p>加入任务 / 删除任务</p></li><li><p>统计任务总数和完成的任务数量</p></li></ul><p>作为一个示例程序，以上就是它的功能了。</p><h2 id="组件结构"><a href="#组件结构" class="headerlink" title="组件结构"></a>组件结构</h2><p>我们可以使用 React 开发出各种组件（component），利用不同组件的功能来实现一个应用。我们这里创建的组件有:</p><pre><code>TodoBox    -TodoList        -TodoItem        -TodoFooter    -TodoForm</code></pre><ul><li><p>TodoBox 是最外层的组件，其余的都是它的子组件</p></li><li><p>TodoList 是各个单独的待办任务的集合</p></li><li><p>TodoItem 即为一条单独的待办事项</p></li><li><p>TodoFooter 对上述的事项进行统计</p></li><li><p>TodoForm 用于加入新的项目</p></li></ul><h2 id="属性的传递"><a href="#属性的传递" class="headerlink" title="属性的传递"></a>属性的传递</h2><p>React 的组件有两种不同的属性，<code>state</code> 和 <code>props</code>。可以用一种简单的方法来区分它们：如果这个属性是其父组件传给它的，那么就是 <code>props</code>，反之如果一个属性是组件自己的，那么就是 <code>state</code>。</p><p>具体什么时候用 <code>state</code>，什么时候用 <code>props</code>，可以参考这几条：</p><blockquote><ul><li>Is it passed in from a parent via props? If so, it probably isn’t state.</li></ul></blockquote><blockquote><ul><li>Does it change over time? If not, it probably isn’t state.</li></ul></blockquote><blockquote><ul><li>Can you compute it based on any other state or props in your component? If so, it’s not state.</li></ul></blockquote><blockquote><p><a href="https://facebook.github.io/react/docs/thinking-in-react.html#step-3-identify-the-minimal-but-complete-representation-of-ui-state">参考来源：Thinking in React</a></p></blockquote><p>这里我们从代码来看看，属性是如何从父组件传递到子组件的。</p><p>每一条待办事项有这样的几个属性:</p><ul><li>id: 任务的编号</li><li>task: 任务的具体内容</li><li>complete: 任务是否已经完成</li></ul><p>我们看看属性的传递过程。</p><p>首先在 <code>TodoBox</code> 组件的 <code>state</code> 中有一个 <code>data</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: [</span><br><span class="line">  &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;0001&quot;</span>, <span class="string">&quot;task&quot;</span>:<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;complete&quot;</span>: <span class="string">&quot;false&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;0002&quot;</span>, <span class="string">&quot;task&quot;</span>:<span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;complete&quot;</span>: <span class="string">&quot;true&quot;</span>&#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>TodoBox</code> 组件的 render 函数中会有 <code>TodoList</code> 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TodoList data=&#123;<span class="built_in">this</span>.state.data&#125;</span><br><span class="line">  <span class="comment">// 其他的属性及方法写在这里</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>这样 <code>TodoBox</code> 组件的 <code>data</code> 属性就传递给了子组件 <code>TodoBox</code>。在 <code>TodoBox</code> 中通过 <code>this.props</code> 来引用这一属性，即 <code>this.props.data</code>。</p><p><code>TodoBox</code> 组件还有子组件 <code>TodoItem</code>，可以将属性继续传递下去。在 <code>TodoList</code> 组件的 <code>render</code> 函数中这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskList = <span class="built_in">this</span>.props.data.map(<span class="function"><span class="keyword">function</span>(<span class="params">listItem</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">TodoItem</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">taskId</span>=<span class="string">&#123;listItem.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">key</span>=<span class="string">&#123;listItem.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">task</span>=<span class="string">&#123;listItem.task&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">complete</span>=<span class="string">&#123;listItem.complete&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        // 其他的属性及方法</span></span></span><br><span class="line"><span class="tag"><span class="xml">    )</span></span></span><br><span class="line"><span class="tag"><span class="xml">  &#125;, <span class="attr">this</span>);</span></span></span><br></pre></td></tr></table></figure><p>在 <code>TodoItem</code> 组件中就可以用 <code>this.props.taskId</code> 获得任务的 id 了。</p><h2 id="函数的传递"><a href="#函数的传递" class="headerlink" title="函数的传递"></a>函数的传递</h2><p>我们的程序中需要的函数有这几个：</p><ul><li>handleTaskDelete: 根据id删除一项任务</li><li>handleToggleComplete: 切换一项任务的完成状态</li><li>handleSubmit: 新增一项任务</li><li>generateId: 给新增的任务一个随机的id</li></ul><p>在 React 的组件中传递方法与传递属性类似，现在 <code>TodoBox</code> 组件中有一个 <code>handleToggleComplete</code> 函数，将它传递给 <code>TodoList</code> 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TodoList toggleComplete=&#123;<span class="built_in">this</span>.handleToggleComplete&#125;</span><br><span class="line">  <span class="comment">// 其他的属性及方法写在这里</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>这样你就可以在 <code>TodoList</code> 组件中通过 <code>this.props.toggleComplete</code> 来调用这一方法了，你也可以将这一方法继续向下一层的组件传递。</p><h2 id="程序的运行"><a href="#程序的运行" class="headerlink" title="程序的运行"></a>程序的运行</h2><p>你可以下载 <a href="https://github.com/noiron/simplest-react-todolist">GitHub 上的项目文件</a>，再用 python 开启一个 HTTP 服务器，就可以打开 <a href="http://localhost:8000/">http://localhost:8000/</a> 查看运行结果了。</p><pre><code>git clone https://github.com/noiron/simplest-react-todolist.gitcd simplest-react-todolistpython -m SimpleHTTP server // open a server with python</code></pre><p>这篇博客里没有对整个项目所有的代码进行分析，更多内容还是<a href="https://github.com/noiron/simplest-react-todolist">直接看代码</a>更清楚。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间忙着找工作去了，有段时间没有写博客了，上一篇还是三月份的，今天来更新一篇。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最近在学 React.js，也写了一些练习的项目，之前参考网上的一些代码写了一个很简单的 to-do list。对于初学者来说，写个基本的 to-do list 对于理解 React 中的一些概念及语法倒是挺有帮助的。&lt;/p&gt;
&lt;p&gt;现在很多的 React 项目中已经开始使用 ES6 来写了，不过因为我在学习 React 的时候看的教程大多都是用 ES5 写的，我这里还是用的还是更熟悉的 ES5 写法，虽然有点落伍了，但若想改成 ES6 版本倒也挺方便的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/noiron/simplest-react-todolist&quot;&gt;GitHub 上的项目地址&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.wukai.me/simplest-react-todolist&quot;&gt;在线 demo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="react" scheme="http://www.wukai.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>开发一个用于屏蔽知乎网内容的Chrome扩展</title>
    <link href="http://www.wukai.me/2016/03/25/chrome-extension-zhihufilter/"/>
    <id>http://www.wukai.me/2016/03/25/chrome-extension-zhihufilter/</id>
    <published>2016-03-24T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.544Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间电影《疯狂动物城》上映了，然后我的知乎首页就被它刷屏了。虽然我对这部电影没有任何意见，但作为一个还没去电影院看过的人来说，每看到相关问题一次都是无情的剧透，于是我毅然屏蔽了“疯狂动物园”这个话题。本以为问题解决了，但是接下来我又被迫看到这个问题：</p><p><img src="/asset/images/2016-03-25-zhihu-filter1.png" alt=""></p><p>问题上添加的五个话题无一命中，我又被剧透了一脸。算了，既然知乎的屏蔽规则靠不住，那就自己动手吧。这样我的Chrome浏览器扩展——ZhihuFilter就诞生了，<a href="https://github.com/noiron/ZhihuFilter">点击这里查看Github上的项目</a>。</p><h2 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h2><p>其实扩展的功能很简单，当打开知乎首页后，扩展会依次检查你的屏蔽关键词列表是否出现在了某一个答案中，如果出现了，就会把这个答案隐藏，取而代之的是提示信息和一个展开答案的按钮。效果如下图所示：</p><p><img src="/asset/images/2016-03-25-zhihu-filter-demo1.png" alt=""></p><p>你可以点击图中的按钮来查看答案，之后可以选择再次隐藏或展开。</p><span id="more"></span><p>当你安装了扩展后，会在地址栏的右侧显示出图标</p><p><img src="/asset/images/2016-03-25-icon.png" alt="icon"></p><p>点击图标后，将会出现设置屏蔽词的界面</p><p><img src="/asset/images/2016-03-25-popup.png" alt="popup页面"></p><p>你可以在这个页面中设置你想屏蔽的词语。</p><h2 id="关于Chrome扩展的开发"><a href="#关于Chrome扩展的开发" class="headerlink" title="关于Chrome扩展的开发"></a>关于Chrome扩展的开发</h2><p>关于Chrome扩展开发的内容，可以查看<a href="https://developer.chrome.com/extensions/getstarted">Google的官方文档</a>或者是<a href="http://www.ituring.com.cn/minibook/950">这个教程</a>。</p><blockquote><p>一个应用（扩展）其实是压缩在一起的一组文件，包括HTML，CSS，Javascript脚本，图片文件，还有其它任何需要的文件。</p></blockquote><p>开发扩展的时候，必不可少的是一个<code>manifest.json</code>文件，这是一个配置文件，会告诉Chrome你的扩展中包含了哪些内容。<code>manifest.json</code>中包含扩展的名字、版本及各种资源文件（如图标、显示页面等）的链接。</p><p><a href="https://github.com/noiron/ZhihuFilter/blob/master/manifest.json">我的扩展的manifest.json文件</a></p><h3 id="Browser-action-和-page-action"><a href="#Browser-action-和-page-action" class="headerlink" title="Browser_action 和 page_action"></a>Browser_action 和 page_action</h3><p><code>Browser_action</code>和<code>page_action</code>是扩展的两种类型，它们很相似，主要的区别在于<code>browser_action</code>可以应用于所有的页面，而<code>page_action</code>只能在你设定的几个特定网站内使用。我的扩展是专门用于知乎网站的，因此选择了<code>page_action</code>来处理。</p><p>按照Google的文档描述，两者还有一个区别：<code>browser_action</code>的图标显示在地址栏的外部，<code>page_action</code>的图标显示在地址栏内部。但是，在<a href="https://groups.google.com/a/chromium.org/forum/#!searchin/chromium-extensions/upcoming/chromium-extensions/7As9MKhav5E/dNiZDoSCCQAJ">这里的讨论</a>中，似乎新版本的Chrome浏览器中已经将两者都显示在了地址栏的外侧，不过<code>page_action</code>的图标只有在打开特定的网站时才不会显示为灰色。</p><p>在<code>manifest.json</code>文件中进行如下设置：</p><pre><code>&quot;page_action&quot;: &#123;  &quot;default_icon&quot;: &quot;images/icon.png&quot;,  &quot;default_title&quot;: &quot;知乎屏蔽扩展&quot;&#125;,</code></pre><h3 id="background-js"><a href="#background-js" class="headerlink" title="background.js"></a>background.js</h3><blockquote><p>在Manifest中指定background域可以使扩展常驻后台。background可以包含三种属性，分别是<code>scripts</code>、<code>page</code>和<code>persistent</code>。</p></blockquote><p>我在扩展中只用到了<code>scripts</code>：</p><pre><code>&quot;background&quot;: &#123;  &quot;scripts&quot;: [&quot;js/jquery-2.2.1.js&quot;,&quot;js/background.js&quot;]&#125;,</code></pre><p>这样就会自动生成一个包含了列出的脚本文件的后台页面。</p><p>在我的<code>background.js</code>文件中有如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当网址改变的时候，判断当前的页面是否是知乎</span></span><br><span class="line"><span class="comment">// 如果是的话，就显示出图标，并设置它的弹出页面</span></span><br><span class="line">chrome.tabs.onUpdated.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">id, info, tab</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tab.url.toLowerCase().indexOf(<span class="string">&quot;zhihu.com&quot;</span>) &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">        chrome.pageAction.show(id);</span><br><span class="line">        chrome.pageAction.setPopup(&#123;</span><br><span class="line">            <span class="attr">tabId</span>: id,</span><br><span class="line">            <span class="attr">popup</span>: <span class="string">&#x27;popup.html&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>background.js</code>文件中还有一个用于和<code>content_script</code>进行通信的监听器。</p><blockquote><p>参考资料：<br><a href="https://developer.chrome.com/extensions/background_pages">Google的Backgorund Pages文档</a><br><a href="http://www.ituring.com.cn/article/60242">另一个教程</a></p></blockquote><h3 id="Content-Scripts"><a href="#Content-Scripts" class="headerlink" title="Content Scripts"></a>Content Scripts</h3><blockquote><p>Content scripts是在Web页面内运行的javascript脚本。通过使用标准的DOM，它们可以获取浏览器所访问页面的详细信息，并可以修改这些信息。</p></blockquote><p>在<code>manifest.json</code>文件中进行设置：</p><pre><code>&quot;content_scripts&quot;: [&#123;  &quot;matches&quot;: [&quot;*://*.zhihu.com/*&quot;],  &quot;js&quot;: [&quot;js/jquery-2.2.1.js&quot;, &quot;js/content_script.js&quot;]&#125;</code></pre><p>在打开匹配的网站时，列出的js文件会被注入页面，这样就可以获得浏览器所访问的web页面的详细信息，并可以对页面做出修改。虽然content script和页面共享了DOM结构，但不能访问该页面或其它content script中定义的函数和变量，这样就避免了相同的函数或变量名称的干扰。</p><p>我的扩展的主要功能就是在<code>content_script.js</code>中完成的，在该脚本中通过对页面的DOM进行操作来实现功能。</p><h2 id="扩展功能的实现"><a href="#扩展功能的实现" class="headerlink" title="扩展功能的实现"></a>扩展功能的实现</h2><h3 id="对知乎首页进行分析"><a href="#对知乎首页进行分析" class="headerlink" title="对知乎首页进行分析"></a>对知乎首页进行分析</h3><p>查看一下知乎首页的源代码，所有的答案内容是放在一个<code>id=js-home-feed-list</code>的div中的，结构大致如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--这里省略了很多内容，只是一个大致示意--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;js-home-feed-list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;feed-item&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里省略一些题目的id，url等信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="comment">&lt;!--头像--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;feed-main&quot;</span>&gt;</span>  <span class="comment">&lt;!--除了头像外的其它部分--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;source&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--答案内容及按钮等部分--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;feed-item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;feed-item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而在答案部分中，又分为摘要和完整的答案。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;zm-item-answer-detail&quot;</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;zm-item-rich-text&quot;</span>&gt;</span>   <span class="comment">&lt;!--内容部分--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;zm-editable-content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="comment">&lt;!--点击显示全部后，这一部分才显示--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">&quot;content hidden&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="comment">&lt;!--包括了全部答案内容但不显示--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;zh-summary summary clearfix&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!--显示摘要--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以获取上面的节点内容，来确定是否需要屏蔽这个答案。最简单的实现方法就是查找关键词是否在节点的<code>outerHTML</code>中出现，如果出现了就给<code>.feed-main</code>加上一个名为<code>hidden</code>的class。</p><h3 id="用于替换的内容"><a href="#用于替换的内容" class="headerlink" title="用于替换的内容"></a>用于替换的内容</h3><p>原来的答案被隐藏了之后，需要在这个地方换上点新的内容，我在这里创建了一个div，内部有一个p元素用于显示信息，及一个button用于切换答案的状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建用于替换的div</span></span><br><span class="line"><span class="keyword">var</span> $div = $(<span class="string">&#x27;&lt;div class=&quot;block-info&quot;&gt;&lt;/div&gt;&#x27;</span>);</span><br><span class="line">$div.append($(<span class="string">&#x27;&lt;p&gt;这里有一个被屏蔽的答案&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&#x27;</span>));</span><br><span class="line">$div.append($(<span class="string">&#x27;&lt;button class=&quot;block-btn&quot;&gt;手贱一下&lt;/button&gt;&#x27;</span>));</span><br></pre></td></tr></table></figure><p>还需要在按钮上绑定点击事件，p元素内显示的信息也会根据实际进行修改。</p><h3 id="关键词的存储"><a href="#关键词的存储" class="headerlink" title="关键词的存储"></a>关键词的存储</h3><p>在我的扩展中，我是将需要屏蔽的关键词存放在了<code>localStorage</code>中。关键词保存在localStorage中的<code>keywords</code>键下，是一个简单的由逗号分隔开的字符串。</p><blockquote><p>要访问同一个localStorage对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。</p></blockquote><p>由于content script注入到了知乎页面，而localStorage存放在扩展的域下，要在content script中获得关键词的值，就必须用到页面中的通信。</p><p>Chrome提供了4个有关扩展页面间相互通信的接口，分别是<code>runtime.sendMessage</code>、<code>runtime.onMessage</code>、<code>runtime.connect</code>和<code>runtime.onConnect</code>，<br>这里用到了前两个。</p><p>content_script.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从扩展的localStorage中获得存储的关键词</span></span><br><span class="line">chrome.runtime.sendMessage(&#123;<span class="attr">method</span>: <span class="string">&quot;getKeywords&quot;</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    str = response.keywords;</span><br><span class="line">    keywords = str !== <span class="string">&#x27;&#x27;</span> ? str.split(<span class="string">&#x27;,&#x27;</span>) : [];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对应的background.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.method == <span class="string">&quot;getKeywords&quot;</span>)</span><br><span class="line">        sendResponse(&#123;<span class="attr">keywords</span>: <span class="built_in">localStorage</span>[<span class="string">&#x27;keywords&#x27;</span>]&#125;);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sendResponse(&#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就可以在content script中使用localStorage的值了。</p><blockquote><p>参考资料：<a href="http://www.ituring.com.cn/article/60272">扩展页面中的通信</a></p></blockquote><h3 id="检测页面加载了更多内容"><a href="#检测页面加载了更多内容" class="headerlink" title="检测页面加载了更多内容"></a>检测页面加载了更多内容</h3><p>每当当知乎页面加载了更多的答案时，我们需要再进行处理。那么如何检测页面中加载了更多内容，这里需要用到<code>MutationObserver</code>对象。<code>MutationObserver</code>提供了检测页面中的DOM变化的方法。</p><p><code>MutationObserver</code>的使用方法：</p><p>首先，创建一个mutationObserver的实例</p><pre><code>var observer = new MutationObserver(callback)</code></pre><p>这里需要一个回调函数作为构造器的参数。</p><p>callback函数接受一个参数，所有被记录到的DOM变化将会组合成一个数组，作为参数传给回调函数进行处理。</p><p>mutationObserver对象有几个方法，这里只用到observe方法。</p><p>observe方法接收两个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> observe(</span><br><span class="line">  Node target,</span><br><span class="line">  MutationObserverInit options</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>第一个参数指的是你要观察哪一个节点的DOM变化。第二个参数是一个选项参数，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    <span class="string">&#x27;childList&#x27;</span>: <span class="literal">true</span>,    <span class="comment">// 观察子元素</span></span><br><span class="line">    <span class="string">&#x27;subtree&#x27;</span>: <span class="literal">true</span>,      <span class="comment">// 观察目标节点的后代元素</span></span><br><span class="line">    <span class="string">&#x27;attributes&#x27;</span>: <span class="literal">false</span>   <span class="comment">// 不观察目标节点属性的变化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里只设置了三个选项，其余属性可以看<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#MutationObserverInit">MDN文档</a>。</p><p>观察到的每一个变化都是一个MutationRecord对象，它有许多属性，比如：</p><ul><li>type，记录变化的类型</li><li>addedNodes，由增加的节点组成的NodeList</li><li>removeNodes，由删除的节点组成的NodeList</li></ul><p>因为addedNodes是一个NodeList，所以可以在它上面应用jQuery的$(), <code>$(mutation.addedNodes)</code>。</p><p>其它的属性可以见<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord">MDN文档</a>。</p><p>所有的MutationRecord会被放进一个list中，作为参数传给上面的callback函数。通过对MutationRecord对象的属性进行检测，如果新增的节点里出现了<code>class=feed-main</code>的元素，则代表加载了新的答案，需要再一次运行程序。</p><blockquote><p>参考资料：<br><a href="https://dev.opera.com/articles/mutation-observers-tutorial/">Getting to Know Mutation Observers</a><br><a href="http://javascript.ruanyifeng.com/dom/mutationobserver.html">Mutation Observer</a></p></blockquote><h2 id="扩展的使用"><a href="#扩展的使用" class="headerlink" title="扩展的使用"></a>扩展的使用</h2><p>在我的设想中，扩展可以提供一些选项，比如正则表达式的支持，再比如除了首页外，在答案页面是否也需要提供屏蔽功能。这些选项会在之后逐步加入。</p><p>由于Chrome的设置，不能够安装Web Store中没有的程序。而发布扩展需要先付$5，我没有信用卡，也就暂时没有发布扩展。如果想尝试一下扩展的话，可以直接下载<a href="https://github.com/noiron/ZhihuFilter">Github中的代码</a>到本地。在Chrome浏览器的菜单中选择 More tools -&gt; Extensions，进入扩展页面后，勾选右上角的Developer mode，选择Load unpacked extension，选择扩展文件夹即可。</p><p>欢迎使用后提出建议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间电影《疯狂动物城》上映了，然后我的知乎首页就被它刷屏了。虽然我对这部电影没有任何意见，但作为一个还没去电影院看过的人来说，每看到相关问题一次都是无情的剧透，于是我毅然屏蔽了“疯狂动物园”这个话题。本以为问题解决了，但是接下来我又被迫看到这个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/asset/images/2016-03-25-zhihu-filter1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;问题上添加的五个话题无一命中，我又被剧透了一脸。算了，既然知乎的屏蔽规则靠不住，那就自己动手吧。这样我的Chrome浏览器扩展——ZhihuFilter就诞生了，&lt;a href=&quot;https://github.com/noiron/ZhihuFilter&quot;&gt;点击这里查看Github上的项目&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;扩展功能&quot;&gt;&lt;a href=&quot;#扩展功能&quot; class=&quot;headerlink&quot; title=&quot;扩展功能&quot;&gt;&lt;/a&gt;扩展功能&lt;/h2&gt;&lt;p&gt;其实扩展的功能很简单，当打开知乎首页后，扩展会依次检查你的屏蔽关键词列表是否出现在了某一个答案中，如果出现了，就会把这个答案隐藏，取而代之的是提示信息和一个展开答案的按钮。效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/asset/images/2016-03-25-zhihu-filter-demo1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可以点击图中的按钮来查看答案，之后可以选择再次隐藏或展开。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="chrome扩展" scheme="http://www.wukai.me/tags/chrome%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>(译)用神经网络实现能够自主避让障碍的生物</title>
    <link href="http://www.wukai.me/2016/03/01/creatures-avoiding-planks/"/>
    <id>http://www.wukai.me/2016/03/01/creatures-avoiding-planks/</id>
    <published>2016-02-29T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.544Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是我去年看到的一个很有趣的项目，还试着模仿它的代码写一个类似的项目出来，不过一直没有完成。这里把原作者的一篇相关博客翻译过来，说不定有更多的人对此感兴趣。</p><ul><li>项目演示：<a href="http://otoro.net/planks/">原作者用JavaScript实现的demo</a></li><li>原文地址：<a href="http://blog.otoro.net/2015/05/07/creatures-avoiding-planks/">creatures avoiding planks</a></li><li>原作者的twitter地址：<a href="https://twitter.com/hardmaru">hardmaru’s twitter</a></li><li>原作者的另一个实验：<a href="http://otoro.net/kanji/">生成伪汉字的实验</a></li><li>译文地址：<a href="http://noiron.github.io/2016/03/01/creatures-avoiding-planks/">用神经网络实现能够自主避让障碍的生物</a></li><li>翻译：吴锴（noiron）</li></ul><p><strong>注意：原文中引用了一些墙外链接，请配合梯子食用</strong></p><p>以下为译文内容：</p><hr><p><img src="/asset/images/2016-03-01-planks_blog.png" alt=""><br><strong>具有神经网络大脑的agent为了生存而进化</strong></p><p><a href="http://otoro.net/planks/">这里是javascript的演示</a></p><p>最近我看到了一个模拟<a href="https://www.youtube.com/watch?v=fmSTNu0Zjh8">视频</a>，展示了使用进化技术来训练agent，让它们能够避开移动的障碍物。<a href="https://www.reddit.com/r/gamedev/comments/31idqb/im_building_evolution_based_ai_toolkit_to/">这里使用的方法</a>似乎是<a href="http://www.cs.ucf.edu/~kstanley/neat.html">NEAT</a>算法的变种。NEAT算法用于神经网络拓扑结构的进化，使其能够正确完成特定的任务。它是为了<a href="http://en.wikipedia.org/wiki/Unity_(game_engine">Unity 5</a>游戏引擎而写的，想被整合进综合的游戏AI中，这引起了我的兴趣。</p><p>这个结果很酷而且动起来似乎很优雅，所以我想试着用javascript实现一个类似的demo，这样就可以在浏览器中运行了。在玩了一下基本的实现后，我发现对于障碍躲避问题，一个简单的神经网络就可以高效的完成了，甚至于一个完全连接的神经网络都算是杀鸡用牛刀了。最后我也意识到就算是一个简单的类<a href="http://upload.wikimedia.org/wikipedia/commons/3/31/Perceptron.svg">感知器（perceptron）</a>网络都能够很好地完成任务，而在之前提到的障碍躲避demo中，隐藏单元也并不能够增加多少好处。</p><p><img src="/asset/images/2016-03-01-perceptron.png" alt="perceptron"><br><strong>简单的感知器图解（维基百科）</strong></p><p>因为agent可以在探测到障碍物的瞬间自由地向任意方向移动，而且agent之间不会产生相互作用，因此这个任务变得太简单了，使用NEAT算法的杀伤力过大了。我们使用一个简单的类感知器网络（即单神经元网络），就能让agent有效地完成躲避障碍的任务了。</p><span id="more"></span><h2 id="让agent的生活变得艰难，因为生活是艰难的"><a href="#让agent的生活变得艰难，因为生活是艰难的" class="headerlink" title="让agent的生活变得艰难，因为生活是艰难的"></a>让agent的生活变得艰难，因为生活是艰难的</h2><p>我想让事情有趣点，所以加了几个额外的条件让任务更困难。</p><ol><li><p>运动被限制在严格版本的<a href="http://www.red3d.com/cwr/steer/">Reynolds转向</a>下，如<a href="http://www.cs.uu.nl/docs/vakken/mcrs/papers/8.pdf">这篇论文</a>中概述的创建逼真的模拟行为这样，与之相对应的是可以向任意方向自由移动。</p></li><li><p>Agent可以选择向左或向右转向，但不能够直行。就像一辆没有动力的车转弯一样，它也必须在转弯时朝着所转的方向前进。我想看看agent能否发展出这样一种转向模式，即通过快速地在左转和右转之间切换从而向前移动。这样事情变得更加困难了，你可以想象驾驶一辆汽车时，为了能向前直行，只能不断地向左或向右打死方向盘。</p></li><li><p>Agent之间会互相碰撞，如果适应度函数是按这种方式设置的话，它们也许需要发展出一种策略来避开对方，要不然我内心的邪恶面会希望它们一起跑向木板。</p></li></ol><p>我发现有了这些限制，agent就不能依靠一个简单的单神经元完成这一任务了。我仍然认为这一任务不应当依靠类似ESP或NEAT等高级的方法，我想用现成的<a href="http://cs.stanford.edu/people/karpathy/convnetjs/">convnet.js</a>库来生成神经网络，所以我选择了在<a href="http://blog.otoro.net/2015/03/28/neural-slime-volleyball/">neural slime volleyball</a>项目中使用过的同样超级简单的神经网络结构。下面是我的第一次尝试：</p><iframe src="https://instagram.com/p/1qJiRMwiaw/embed/captioned/?v=4" width="80%"></iframe><p>每一个agent的大脑由十个神经元组成，每个神经元都和所有的输入及其余的神经元相连接，也许就像真实大脑的中一个小区域的切片一样。下面是大脑的原理图：</p><p><img src="/asset/images/2016-03-01-planks_net_8_recurrent.png" alt="basic diagram of the neural network"><br><strong>神经网络的基本图解——每个大脑有269个权重值</strong></p><p>这种网络结构被称作<a href="http://en.wikipedia.org/wiki/Recurrent_neural_network#Fully_recurrent_network">全连接的递归网络（fully connected recurrent network）</a>。每一个agent都有一组将送入递归网络中的感知输入。10个神经元中的2个将控制agent的动作，其它的是用于计算和思考的“隐藏神经元单元”。所有的神经元输出信号又将送回输入层，所以每一个神经元都与其它的神经元完全连接起来了，这中间会有一帧（~1/30s）的时间延迟。</p><p>输出层的第一个神经元用于控制agent是向左还是向右转，取决于输出的信号。我们使用<a href="http://mathworld.wolfram.com/HyperbolicTangent.html">双曲正切</a>函数来启动神经元，因为神经元的输出值在-1至1之间，所以做这样的一个二元选择（左/右）是很自然的。第二个神经元控制agent是移动还是保持静止，也取决于输出信号。</p><h2 id="训练网络"><a href="#训练网络" class="headerlink" title="训练网络"></a>训练网络</h2><p>100个初始化为随机权重值的agent被用于训练，它们会在模拟中四处跑动直到它们被一块木板杀死。在模拟的最后所有人都死了，这种感觉很糟糕，但是人固有一死……</p><p>当所有的agent在一次模拟中全都死亡了之后，我们保留在模拟中存活了最长时间的30个agent的基因用于下一代，丢弃其余的70个agent。最好的30个基因，即神经连接的权值和偏置（bias）的向量，将会进行交叉变异以传递给下一代中新产生的70个agent。这个过程（将在下面的繁殖部分解释）将会持续进行，直到最好的agent能够熟练地躲开木板并存活五分钟以上。</p><p>下面是一个运行中的进化模拟<a href="http://otoro.net/planks/training.html">demo</a>，它的第一代是完全随机的网络（我将这个demo缩减为50个agent而不是100个，这样在大部分电脑甚至是智能手机上都能够运行）。起初，大部分的agent都不会试图存活下去（或者直接放弃了！），但是也许一个或两个知道该干些什么并且做的好了些，所以它们能够进入下一代并且进行繁殖。在几代过后，你会看到种群的能力增加了，它们全都开始躲避移动的木板了。我惊讶地发现，在30代后结果就不错了。如果你感兴趣，可以看一下这个<a href="http://otoro.net/planks/training.html">训练demo</a>中它们是如何从开始时完全不知道如何生存进化到这一步的。注意这些结果是每十代更新一次的。因为我希望它们尽可能快的进化，而不是将进化限制在每秒30帧，所以把模拟运行到电脑能允许的最快速度，而每隔十代运行一次作为展示的模拟，因此你可以品评实时的进度——而实际的进化是在屏幕之后以光速进行的。</p><p><img src="/asset/images/2016-03-01-planks_training-1024x1022.png" alt=""><br><strong>训练的草图——观看agent如何从一无所知进化而来</strong></p><p>Agent周围的线条是它的知觉传感器，就像视觉输入一样，它们给每一个agent提供了周围世界的感知能力。Agent感知到的物体越近则线条的强度越大。每个agent能够看到周围的8个方向，探测距离最大为其身体半径的12倍。我是这样决定信号值的，agent探测到的物体越近，信号越接近一，反之，若没有探测到物体，信号为零。如果agent看到的物体距离为6倍半径，则信号为0.25而不是0.5，这里我为了模仿<a href="http://en.wikipedia.org/wiki/Inverse-square_law">光照密度模型</a>将结果进行了平方。</p><h2 id="如果Wayne-Gretzky在有孩子之前就遭遇了车祸会如何？"><a href="#如果Wayne-Gretzky在有孩子之前就遭遇了车祸会如何？" class="headerlink" title="如果Wayne Gretzky在有孩子之前就遭遇了车祸会如何？"></a>如果Wayne Gretzky在有孩子之前就遭遇了车祸会如何？</h2><p><em>[译者注]：Wayne Gretzky是著名的加拿大冰球运动员</em></p><p>我也给上面提到的训练算法进行了一点微调。</p><p>现在的一个问题是一些表现最好的agent可能会意外死亡，即使它们很厉害，但因为模拟中agent之间太拥挤了，它也会因为纯粹运气不好而死掉。上一代的一个顶尖的躲避墙的agent，起始位置可能是在人群的边缘，在模拟开始时就会被其它的几个agent意外的推到木板上面，这就不能把它的好基因传给下一代了。</p><p>我想了一下这个问题，想出了一个主意，在进化算法中加入一个“名人堂”部分，这将会记下那些达到了最佳记录分数的agent的基因。我也修改了我的<a href="https://github.com/hardmaru/convnetjs/tree/master/neuroevolution">进化库</a>来加入这个名人堂特性，以保留历来的十佳冠军。对于每一次模拟，名人堂都会加入被加入到当前的这一代。从这层意义上来说，每一代的agent都必须和历来最好的agent竞争。想象一下能够在每一个冰球赛季都和Wayne Gretzkey, Doug Gilmour及Tim Horton一起训练！</p><p>这个技术绝对极大提升了进化的结果，因为最好的基因都被强制加入到了种群中。如果这发生在现实生活中会很恐怖的（虽然我们可能很快就将达到这一步了……）。我认为我在进化计算的世界里发现了一个伟大的新技术，这是一个突破！然而，我发现名人堂技术<a href="http://www.cs.utexas.edu/users/nn/pages/research/ne-applications.html">已经在围棋领域中被用于</a>神经进化了。好吧，这对我不是好消息。</p><p>我想看看如果我重新进化一遍，agent是否会表现地完全不同，于是我花了几天训练了不同的几组agent，每一组都有一千代左右。事实证明大部分的agent最终都有相似的权值模式。为了知道每个agent的大脑看起来有何不同，我将表现最好的agent的“基因代码”画成了图，为了图中的效果我将四个权值作为一组合成了一个颜色（RGBA的四个通道）。</p><p><img src="/asset/images/2016-03-01-plank_boid_genes-1024x1024.png" alt=""><br><strong>每一行代表进化最成功的神经网络的权值</strong></p><p>可以看出表现最好的agent除了些许差别外似乎都差不多。然而，这可能会导致一个问题，即它们可能都被限制在一个局部优化状态。我可以想象在某些情境中，agent为了避开木板而趋向于发展出相同的次最优策略，而由于任务的难度的限制就不会有新的进展了。如果使用更高级的方法可以解决这一问题，但是我对现在用简单的<a href="http://blog.otoro.net/2015/02/06/conventional-neuroevolution-cne-trainer-part-ii/">卷积神经进化</a>生成的递归网络已经很满意了。我在demo中使用了最好的23个基因。最终的模拟将会利用从这个训练完成的组中随机挑选出的名人堂来进行初始化。</p><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>在经过约一千代的训练后，agent已经能不错地躲避障碍了。请看这个<a href="http://otoro.net/planks">demo</a>中的最终结果。Agent还远不够完美，但是它们展示出的像昆虫般的行为让我觉得很有趣。我很惊讶，即使它们被限制成只能全力左转或右转，它们仍然能够完成躲避木板的任务。在demo中，每个agent有一只手，用于显示它们转的方向。没有手则表示保持静止。我也很高兴的看到当agent想朝一个方向前进时，它能在空白区域摇摆向前，看来它们通过左转和右转间的切换发展出了某种模式。</p><p><img src="/asset/images/2016-03-01-planks_final_result1-1024x576.png" alt=""><br><strong>最终模拟——otoro.net/planks</strong></p><p>我也注意到它们倾向于和其它agent聚在一起并努力待在中间，我不确定原因。也许是因为在人群的中间，它可以等待其它agent死去从而增加自己存活的几率。我也考虑过在适应度函数中使用与种群平均值有关的<em>相对生命长度</em>，而不是绝对生命长度。也许在一个更复杂的网络中，这能够诱使agent变得邪恶且会计划杀死其他agent。</p><h2 id="繁殖"><a href="#繁殖" class="headerlink" title="繁殖"></a>繁殖</h2><p><img src="/asset/images/2016-03-01-planks_mating.png" alt=""><br><strong>带有父母双方基因的后代</strong></p><p>与其每一次都等着所有的agent死亡然后创造下一代，不如让demo更有趣些，于是我给agent添加了配对和产生后代的能力！在以后这可能会形成一个可供选择的让agent进化的代内方法，而不是将每一代的种群数量固定为常数。</p><p>它工作的原理是对于每个agent，如果它们能够生存某一个随机的时间（一般为30至60秒），它们将具有繁殖的能力。如果这样的两个agent相遇了，就会产生两个后代。后代初始时体积会小一点，在约30-60秒后会长到成年大小。父代agent的“激励时钟”重置为零，必须再等30-60秒才能产生下一代……</p><p><img src="/asset/images/2016-03-01-planks_crossover-1024x440.png" alt=""><br><strong>交叉算法（维基百科）</strong></p><p>两个后代将会继承父母双方的基因，这是通过很简单的一点<a href="http://en.wikipedia.org/wiki/Crossover_%28genetic_algorithm%29">交叉方法</a>。所以第一个孩子将会从第一个父代那里继承第一段神经网络的权值，剩下的来自第二个父代。如上图中描述的一样，截断点是随机的。我还额外地给每一个孩子增加了随机变异，所以它们将具有独特性。这个随机的变异对于鼓励创新和给种群的基因库添加新元素是很重要的。</p><p>从原理上说表现越好的agent有越高的生存几率，因此它们有更高的几率产生携带其基因的后代，反之较弱的个体会在拥有孩子之前死去。虽然有时很好的个体会因为不走运而死的太早，这对于它们确实不太好——这就是生活——生活是不公平的，而且生活很艰难！</p><h2 id="与agent互动——扮演上帝"><a href="#与agent互动——扮演上帝" class="headerlink" title="与agent互动——扮演上帝"></a>与agent互动——扮演上帝</h2><p>当使用demo时，你可以点击屏幕的空白部分来创建新的agent加入模拟。一个新的agent的初始基因是从最近的几个试图产生后代的agent中随机选择出的，如果所有的agent都未繁殖过，那就从名人堂最初的一组中选择。</p><p>如果你点击到了木板上，将会切换到下一个视觉模式，例如，X射线模式，无边框模式，没有手的纯粹生物模式等等。我用这些模式来评估不同的设计和总体的美感。我认为X射线模式看起来很酷，而且在较慢的机器上也能运行的更快。</p><p><img src="/asset/images/2016-03-01-planks_xray-300x300.png" alt=""><br><strong>X射线模式</strong></p><p>你也可以通过点击agent来给它们施加一个强大的推力。这模拟了一个暂时的风力效果，将它们从被点击的地方推开。</p><p>你也可以在屏幕上拖动画线来创建一块新的木板。依据所画的方向，木板会沿着其垂直方向向左或向右移动。你可以看到在你释放了一些木板去摧毁它们的文明时，agent是如何反应的。请善用这个新能力，我注意到在没有这个特性之前，用户会给小家伙们加油，但是知道了这个功能后，他们开始准备种族灭绝了！</p><h2 id="设计和开发的考虑"><a href="#设计和开发的考虑" class="headerlink" title="设计和开发的考虑"></a>设计和开发的考虑</h2><p>（这一部分暂未翻译）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是我去年看到的一个很有趣的项目，还试着模仿它的代码写一个类似的项目出来，不过一直没有完成。这里把原作者的一篇相关博客翻译过来，说不定有更多的人对此感兴趣。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目演示：&lt;a href=&quot;http://otoro.net/planks/&quot;&gt;原作者用JavaScript实现的demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;http://blog.otoro.net/2015/05/07/creatures-avoiding-planks/&quot;&gt;creatures avoiding planks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原作者的twitter地址：&lt;a href=&quot;https://twitter.com/hardmaru&quot;&gt;hardmaru’s twitter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原作者的另一个实验：&lt;a href=&quot;http://otoro.net/kanji/&quot;&gt;生成伪汉字的实验&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文地址：&lt;a href=&quot;http://noiron.github.io/2016/03/01/creatures-avoiding-planks/&quot;&gt;用神经网络实现能够自主避让障碍的生物&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;翻译：吴锴（noiron）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：原文中引用了一些墙外链接，请配合梯子食用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下为译文内容：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;/asset/images/2016-03-01-planks_blog.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;具有神经网络大脑的agent为了生存而进化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://otoro.net/planks/&quot;&gt;这里是javascript的演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近我看到了一个模拟&lt;a href=&quot;https://www.youtube.com/watch?v=fmSTNu0Zjh8&quot;&gt;视频&lt;/a&gt;，展示了使用进化技术来训练agent，让它们能够避开移动的障碍物。&lt;a href=&quot;https://www.reddit.com/r/gamedev/comments/31idqb/im_building_evolution_based_ai_toolkit_to/&quot;&gt;这里使用的方法&lt;/a&gt;似乎是&lt;a href=&quot;http://www.cs.ucf.edu/~kstanley/neat.html&quot;&gt;NEAT&lt;/a&gt;算法的变种。NEAT算法用于神经网络拓扑结构的进化，使其能够正确完成特定的任务。它是为了&lt;a href=&quot;http://en.wikipedia.org/wiki/Unity_(game_engine&quot;&gt;Unity 5&lt;/a&gt;游戏引擎而写的，想被整合进综合的游戏AI中，这引起了我的兴趣。&lt;/p&gt;
&lt;p&gt;这个结果很酷而且动起来似乎很优雅，所以我想试着用javascript实现一个类似的demo，这样就可以在浏览器中运行了。在玩了一下基本的实现后，我发现对于障碍躲避问题，一个简单的神经网络就可以高效的完成了，甚至于一个完全连接的神经网络都算是杀鸡用牛刀了。最后我也意识到就算是一个简单的类&lt;a href=&quot;http://upload.wikimedia.org/wikipedia/commons/3/31/Perceptron.svg&quot;&gt;感知器（perceptron）&lt;/a&gt;网络都能够很好地完成任务，而在之前提到的障碍躲避demo中，隐藏单元也并不能够增加多少好处。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/asset/images/2016-03-01-perceptron.png&quot; alt=&quot;perceptron&quot;&gt;&lt;br&gt;&lt;strong&gt;简单的感知器图解（维基百科）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为agent可以在探测到障碍物的瞬间自由地向任意方向移动，而且agent之间不会产生相互作用，因此这个任务变得太简单了，使用NEAT算法的杀伤力过大了。我们使用一个简单的类感知器网络（即单神经元网络），就能让agent有效地完成躲避障碍的任务了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="神经网络" scheme="http://www.wukai.me/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
