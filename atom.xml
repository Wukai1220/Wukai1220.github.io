<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴锴的博客</title>
  
  <subtitle>Life? Don&#39;t talk to me about life!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wukai.me/"/>
  <updated>2023-05-16T08:22:26.868Z</updated>
  <id>http://www.wukai.me/</id>
  
  <author>
    <name>noiron</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《深入理解计算机系统 CSAPP》Data Lab 记录</title>
    <link href="http://www.wukai.me/2023/05/16/csapp-datalab/"/>
    <id>http://www.wukai.me/2023/05/16/csapp-datalab/</id>
    <published>2023-05-15T16:00:00.000Z</published>
    <updated>2023-05-16T08:22:26.868Z</updated>
    
    <content type="html"><![CDATA[<p>《深入理解计算机系统CSAPP》这本书我已经买了很多年了，一直都只是翻翻而已，阅读进度常年在前两章。趁着最近有时间，再次拿出了这本书，准备好好学习一下。配套的几个lab 也试着做一下，这篇文章就是记录一下第一个 data lab 的过程。</p><h2 id="lab-的环境准备">Lab 的环境准备</h2><p>这是 CSAPP Lab 的<ahref="http://csapp.cs.cmu.edu/3e/labs.html">官方网站</a>，上面有各个 lab详细介绍和下载地址。</p><p>Lab 正常运行和测试需要安装相应的环境，利用 docker可以省去配置环境的环节，我使用的这个已经制作好的 docker 镜像：<ahref="https://github.com/XieGuochao/csapp">项目地址</a>。在安装 docker之后，按照项目 README 的步骤 clone项目并启动即可。这个项目中已经包含了所有的 lab文件，因此不需要额外下载了。</p><p>Docker 启动命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 7777:7777 -v <span class="string">&quot;<span class="variable">$PWD</span>/labs:/home/csapp/project&quot;</span> xieguochao/csapp</span><br></pre></td></tr></table></figure><p>然后在浏览器中打开 <code>http://localhost:7777</code> 即可。</p><span id="more"></span><p><code>-v</code> 参数是将本地的 <code>labs</code> 目录挂载到 docker容器中，容器内部的目录路径是 <code>/home/csapp/project</code>是容器内部的目录路径，这样在容器中修改的文件也会同步到本地。如果想再挂载一个目录，比如建立了一个和<code>labs</code> 目录同级的 <code>learn</code>目录，用于放置一些测试代码，可以再添加一个 <code>-v</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 7777:7777 -v <span class="string">&quot;<span class="variable">$PWD</span>/labs:/home/csapp/labs&quot;</span> -v <span class="string">&quot;<span class="variable">$PWD</span>/learn:/home/csapp/learn&quot;</span> xieguochao/csapp</span><br></pre></td></tr></table></figure><h2 id="data-lab-的目标">Data Lab 的目标</h2><p>Data Lab 要完成的目标可以查看它的文档：<ahref="http://csapp.cs.cmu.edu/3e/datalab.pdf">datalab</a>。</p><p>简要来说：这个 lab是考察你对各种位运算和数据表示的理解，<code>bits.c</code>中给出了一些函数，需要你在给定的限制下将函数实现补充完整。</p><p>改动 <code>bits.c</code> 文件后，通过以下命令来测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="comment"># 运行后能看到你的分数</span></span><br><span class="line">./btest</span><br><span class="line"><span class="comment"># 也可以单独测试一个函数</span></span><br><span class="line">./btest -f bitXor</span><br></pre></td></tr></table></figure><p>使用 <code>./dlc bits.c</code> 检查是否有不允许使用的运算符。</p><p>虽然我作为一个前端开发，在工作中直接使用位运算的情况并不多，但是这个lab 拿来练习并补充知识盲区是不错的。</p><h2 id="题目解析">题目解析</h2><h3 id="bitxor">bitXor</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(x &amp; y) &amp; (~(~x &amp; ~y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>异或运算 <code>^</code> 结果为真就是 <code>x</code> 和 <code>y</code>中有且有一个为真，<code>x ^ y = (x &amp; ~y) | (~x &amp; y)</code>。因为题目要求不允许使用<code>|</code>，所以需要使用德摩根定律转换一下，将表达式中的<code>|</code> 转换成 <code>&amp;</code>。</p><h3 id="tmin">tmin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>最小的补码数，就是最高位为 1，其余位为 0 的数，将 1 左移 31位即可。</p><h3 id="istmax">isTmax</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !~(x + <span class="number">1</span> + x) &amp; !!(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>最大的补码数，就是最高位为 0，其余位为 1 的数。</p><p>它与上一题的 <code>tmin</code>所有位均不同，如果将两个数异或，得到的应该是一个全 1 的位表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!~((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) ^ x);</span><br></pre></td></tr></table></figure><p>但是这一题中我们不能使用移位，所以需要换一个思路。</p><p>对于 <code>tmax</code> 可以计算 <code>x + 1 + x</code> 得到一个全 1的数，取反后得到全 0 的数。但是有一个特殊情况，就是 <code>x = -1</code>的时候（即所有的位均为 1），<code>x + 1 + x</code>会溢出，取反后它也会得到全 0 的表示，还需要排除这种情况。</p><h3 id="alloddbits">allOddBits</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = x &amp; (x &gt;&gt; <span class="number">8</span>) &amp; (x &gt;&gt; <span class="number">16</span>) &amp; (x &gt;&gt; <span class="number">24</span>);</span><br><span class="line">  <span class="keyword">int</span> mask = <span class="number">0xAA</span>;</span><br><span class="line">  <span class="keyword">return</span> !((y &amp; mask) ^ mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>A 的二进制表示为 1010，易得 <code>0xAAAAAAAA</code> 的所有奇数位都是1。如果 <code>x</code> 的所有奇数位都是1，将 <code>x</code> 与<code>0xAAAAAAAA</code> 进行与操作后，得到的结果应该是<code>0xAAAAAAAA</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mask = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line"><span class="keyword">return</span> (x &amp; mask) == mask;</span><br></pre></td></tr></table></figure><p>因为不允许使用 <code>==</code>来判断相等，可以改用异或来判断是否相等，一个数和它本身的异或结果为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mask = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line"><span class="keyword">return</span> !((x &amp; mask) ^ mask);</span><br></pre></td></tr></table></figure><p>改动之后仍然存在一个问题，我们允许定义的常量最大为<code>0xFF</code>，所以不能直接使用<code>0xAAAAAAAA</code>，可以定义常量<code>0xAA</code>，通过移位来判断每8位是否都符合要求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> y = x &amp; (x &gt;&gt; <span class="number">8</span>) &amp; (x &gt;&gt; <span class="number">16</span>) &amp; (x &gt;&gt; <span class="number">24</span>);</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">0xAA</span>;</span><br><span class="line"><span class="keyword">return</span> !((y &amp; mask) ^ mask);</span><br></pre></td></tr></table></figure><h3 id="negate">negate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p><code>~x + x</code> 一定是全 1 的表示，<code>+1</code> 后会溢出得到0，所以<code>x + (~x + 1) == 0</code>。可以得出补码数的相反数，就是取反加一。</p><h3 id="isasciidigit">isAsciiDigit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = <span class="number">0x1</span> &lt;&lt; <span class="number">31</span>; <span class="comment">// 获取int类型的最高位，即符号位</span></span><br><span class="line">  <span class="keyword">int</span> upperBound = ~(sign | <span class="number">0x39</span>); <span class="comment">// 上界，大于 0x39 的数与之相加后变为负数</span></span><br><span class="line">  <span class="keyword">int</span> lowerBound = ~<span class="number">0x30</span> + <span class="number">1</span>; <span class="comment">// 下界，-x，小于 0x30 的数与之相加后为负数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断x是否小于下界</span></span><br><span class="line">  <span class="keyword">int</span> isLessThanLowerBound = sign &amp; (lowerBound + x) &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断x是否大于上界</span></span><br><span class="line">  <span class="keyword">int</span> isGreaterThanUpperBound = sign &amp; (upperBound + x) &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !(isLessThanLowerBound | isGreaterThanUpperBound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>这道题的思路是找到数字范围对应的上下界。</p><p>数字中最大的值是<code>0x39</code>，它会有对应的一个上界，<code>0x39 + 上界</code>得到最大的正数（即除符号位外均为 1）。假如 <code>x &gt; 0x39</code>，则<code>x + 上界</code> 会溢出得到一个负数。 可以利用 <code>x</code>与上界相加后的符号位来判断。</p><p>数字中最小的值是<code>0x30</code>，它会有对应的一个下界，<code>0x30 + 下界</code> 得到0。假如 <code>x &lt; 0x30</code>，则 <code>x + 下界</code>会得到一个负数。 可以利用 <code>x</code>与下界相加后的符号位来判断。</p><p>以 4 位数字来举例说明，能表示的最大的正数是 <spanclass="math inline">\([0111]_2\)</span> ，想确定一个数字是否大于数字<span class="math inline">\(3 = [0011]_2\)</span> ，找出 3 对应的上界是<span class="math inline">\([0100]_2 = 4\)</span>，大于 4 的数与 3相加后都会变为负数。因为二者相加得到了除符号位外全 1的数字，所以要找到一个数字对应的上界只要将其除符号位的各位取反即可，符号位保持为0。</p><h3 id="conditional">conditional</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask= ~!x+<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> (y &amp; ~mask) | (z &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>返回的结果是 y 和 z 中的一个，表达式应该是这样的形式<code>(y op expr) | (z op expr)</code></p><p>我们需要这样的一个掩码值（表格中以16位为例）：</p><table><thead><tr class="header"><th>x</th><th>mask</th><th>y &amp; ~mask</th><th>z &amp; mask</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0xffff</td><td>0x0000</td><td>z</td></tr><tr class="even"><td>非0</td><td>0x0000</td><td>y</td><td>0x0000</td></tr></tbody></table><p>这个掩码值可以通过表达式 <code>~!x + 1</code> 根据 x的不同情况来求出：</p><table><thead><tr class="header"><th>x</th><th>!x</th><th>~!x</th><th>~!x + 1</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0x0001</td><td>0xfffe</td><td>0xffff</td></tr><tr class="even"><td>非0</td><td>0x0000</td><td>0xffff</td><td>0x0000</td></tr></tbody></table><h3 id="islessorequal">isLessOrEqual</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> diff = ~x + <span class="number">1</span> + y;</span><br><span class="line">  <span class="keyword">int</span> signD = diff &gt;&gt; <span class="number">31</span> &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> signX = x &gt;&gt; <span class="number">31</span> &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> signY = y &gt;&gt; <span class="number">31</span> &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> sameSign = !(signX ^ signY);</span><br><span class="line">  <span class="keyword">return</span> (sameSign &amp;&amp; !signD) | (!sameSign &amp; signX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>比较大小需要区分 <code>x</code> 和 <code>y</code>的符号是否相同。符号相同，比较差值；符号不同，需要满足<code>x &lt; 0</code>。</p><p>为什么要区分符号相同和符号不同的情况呢？假设是 8位二进制表示的数字，补码表示的范围是 [-128, 127]。<code>x</code> 和<code>y</code> 的值如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 0x80; // -128</span><br><span class="line">y = 0x7f; // 127</span><br></pre></td></tr></table></figure><p><code>y - x = 255</code>，这个值在 8 位二进制补码表示的是 -1，但是<code>y &gt; x</code>。所以需要区分符号相同和符号不同的情况。</p><p>当二者符号相同时，<code>x &lt;= y</code> 即<code>y - x &gt;= 0</code>，<code>y - x</code> 使用<code>~x + 1 + y</code> 来计算，如果符号位是 0 则表示满足。</p><h3 id="logicalneg">logicalNeg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = x | (~x + <span class="number">1</span>); <span class="comment">// x | -x</span></span><br><span class="line">  <span class="keyword">int</span> sign = a &gt;&gt; <span class="number">31</span>; <span class="comment">// 算术右移</span></span><br><span class="line">  <span class="keyword">return</span> sign + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>除了 0 以外，一个数和它的相反数一定是一正一负，因此利用<code>x</code> 和 <code>-x</code> 的符号位可以得到结果。</p><h3 id="howmanybits">howManyBits</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 对于正数保持不变，对于负数各位取反</span></span><br><span class="line">  <span class="keyword">int</span> y = x ^ sign;</span><br><span class="line">  <span class="comment">// 检查高16位是否有值，如果有的话，则至少需要16位。</span></span><br><span class="line">  <span class="comment">// 高16有值，设置 bit_16 = 16，右移16位，检查具体最高位在哪</span></span><br><span class="line">  <span class="comment">// 高16没有值，bit_16 = 0，无需右移，开始检查低16位</span></span><br><span class="line">  <span class="keyword">int</span> bit16 = !!(y &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  y = y &gt;&gt; bit16;</span><br><span class="line">  <span class="keyword">int</span> bit8 = !!(y &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  y = y &gt;&gt; bit8;</span><br><span class="line">  <span class="keyword">int</span> bit4 = !!(y &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  y = y &gt;&gt; bit4;</span><br><span class="line">  <span class="keyword">int</span> bit2 = !!(y &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  y = y &gt;&gt; bit2;</span><br><span class="line">  <span class="keyword">int</span> bit1 = !!(y &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  y = y &gt;&gt; bit1;</span><br><span class="line">  <span class="keyword">int</span> bit0 = y;</span><br><span class="line">  <span class="keyword">return</span> bit16 + bit8 + bit4 + bit2 + bit1 + bit0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>对于正数，符号位为0，关键在于找到最高位的1的位置，然后加上一个符号位。</p><p>对于负数，最高位一定是1，而最高位的若干个连续的1可以等价于1个单独的1（符号扩展）。</p><p>比如 <span class="math inline">\(1110_2 = -8 + 4 + 2 =-2\)</span>，它和 <span class="math inline">\(10_2 = -2\)</span>是相等的。</p><p>因此，关键在于找到最高位的零的位置，如果我们将负数各位取反，则思路和正数一致了，都是需要确定最高的1 的位置。</p><p>假设对于最大的正整数：<code>2^31-1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">0111 1111, 1111 1111, 1111 1111, 1111 1111</span><br><span class="line">↑                  ↑</span><br><span class="line">高16位有值 bit16 = 16</span><br><span class="line">将高16位移动至低16位</span><br><span class="line"></span><br><span class="line">0000 0000, 0000 0000, 0111 1111, 1111 1111</span><br><span class="line">                      ↑       ↑</span><br><span class="line">高8位有值，bit8 = 8</span><br><span class="line">将高8位移动至低8位</span><br><span class="line"></span><br><span class="line">0000 0000, 0000 0000, 0000 0000, 0111 1111</span><br><span class="line">                                 ↑  ↑</span><br><span class="line">高4位有值，bit4 = 4</span><br><span class="line">将高4位移动至低4位</span><br><span class="line"></span><br><span class="line">0000 0000, 0000 0000, 0000 0000, 0000 0111</span><br><span class="line">                                      ↑↑</span><br><span class="line">高2位有值，bit2 = 2</span><br><span class="line">将高2位移动至低2位</span><br><span class="line"></span><br><span class="line">0000 0000, 0000 0000, 0000 0000, 0000 0001</span><br><span class="line">                                        ↑</span><br><span class="line">高1位没有值，bit1 = 0</span><br><span class="line">不移动，检查最后一位</span><br><span class="line"></span><br><span class="line">0000 0000, 0000 0000, 0000 0000, 0000 0001</span><br><span class="line">                                         ↑</span><br><span class="line">bit0 = 1</span><br></pre></td></tr></table></figure><p>假设对于2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000 0000, 0000 0000, 0000 0000, 0000 0010</span><br><span class="line">↑                  ↑</span><br><span class="line">高16位没有值，bit16 = 0，不右移</span><br><span class="line"></span><br><span class="line">0000 0000, 0000 0000, 0000 0000, 0000 0010</span><br><span class="line">                      ↑       ↑</span><br><span class="line">高8位没有值，bit8 = 0，不右移</span><br><span class="line"></span><br><span class="line">0000 0000, 0000 0000, 0000 0000, 0000 0010</span><br><span class="line">                                 ↑  ↑</span><br><span class="line">高4位没有值，bit4 = 0，不右移</span><br><span class="line"></span><br><span class="line">0000 0000, 0000 0000, 0000 0000, 0000 0010</span><br><span class="line">                                      ↑↑</span><br><span class="line">高2位没有值，bit2 = 0，不右移</span><br><span class="line"></span><br><span class="line">0000 0000, 0000 0000, 0000 0000, 0000 0010</span><br><span class="line">                                        ↑</span><br><span class="line">高1位有值，bit1 = 1，右移1位</span><br><span class="line"></span><br><span class="line">0000 0000, 0000 0000, 0000 0000, 0000 0001</span><br><span class="line">                                         ↑</span><br><span class="line">bit0=1</span><br></pre></td></tr></table></figure><h3 id="floatfloat2int">floatFloat2Int</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> * for floating point argument f.</span></span><br><span class="line"><span class="comment"> * Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> * it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> * single-precision floating point value.</span></span><br><span class="line"><span class="comment"> * Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> * 0x80000000u.</span></span><br><span class="line"><span class="comment"> * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> * Max ops: 30</span></span><br><span class="line"><span class="comment"> * Rating: 4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> sign = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">exp</span> = uf &gt;&gt; <span class="number">23</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">     <span class="keyword">int</span> frac = uf &amp; <span class="number">0x7FFFFF</span>;</span><br><span class="line">     <span class="keyword">int</span> E = <span class="built_in">exp</span> - <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">255</span> || E &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">exp</span> || E &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">1</span> &lt;&lt; E; <span class="comment">// 在小数的开头加上一个1</span></span><br><span class="line">  <span class="keyword">if</span> (E &lt; <span class="number">23</span>) &#123;</span><br><span class="line">    result |= frac &gt;&gt; (<span class="number">23</span> - E); <span class="comment">// 舍去小数点右侧的数字 </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result |= frac &lt;&lt; (E - <span class="number">23</span>); <span class="comment">// 在小数右侧补零</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">    result = ~result + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>根据浮点数的表示依次处理符号位、指数部分、小数部分即可。</p><p>具体说明可以参考这一篇：<ahref="https://onestepcode.com/float-to-int-c/">Converting float to intin C</a></p><h3 id="floatpower2">floatPower2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &gt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>; <span class="comment">// 指数位均为1表示无穷大</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>; <span class="comment">// 把指数位放到正确的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>在浮点数表示中，指数部分就代表了是 2 的多少次幂，将 x加上偏置值得到指数部分，然后左移至正确位置即可。</p><h2 id="参考资料">参考资料</h2><p>我在完成这个 lab的时候参考了别人的实现方案，以下是一些给了我帮助的文章：</p><ul><li><p><ahref="https://wdxtub.com/csapp/thick-csapp-lab-1/2016/04/16/">【读厚CSAPP】I Data Lab</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/59534845">CSAPP 之DataLab详解，没有比这更详细的了</a></p></li><li><p><ahref="https://www.cnblogs.com/iwehdio/p/15679889.html">深入理解计算机原理（csapp第三版）——datalab</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入理解计算机系统
CSAPP》这本书我已经买了很多年了，一直都只是翻翻而已，阅读进度常年在前两章。趁着最近有时间，再次拿出了这本书，准备好好学习一下。配套的几个
lab 也试着做一下，这篇文章就是记录一下第一个 data lab 的过程。&lt;/p&gt;
&lt;h2 id=&quot;lab-的环境准备&quot;&gt;Lab 的环境准备&lt;/h2&gt;
&lt;p&gt;这是 CSAPP Lab 的&lt;a
href=&quot;http://csapp.cs.cmu.edu/3e/labs.html&quot;&gt;官方网站&lt;/a&gt;，上面有各个 lab
详细介绍和下载地址。&lt;/p&gt;
&lt;p&gt;Lab 正常运行和测试需要安装相应的环境，利用 docker
可以省去配置环境的环节，我使用的这个已经制作好的 docker 镜像：&lt;a
href=&quot;https://github.com/XieGuochao/csapp&quot;&gt;项目地址&lt;/a&gt;。在安装 docker
之后，按照项目 README 的步骤 clone
项目并启动即可。这个项目中已经包含了所有的 lab
文件，因此不需要额外下载了。&lt;/p&gt;
&lt;p&gt;Docker 启动命令如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -p 7777:7777 -v &lt;span class=&quot;string&quot;&gt;&amp;quot;&lt;span class=&quot;variable&quot;&gt;$PWD&lt;/span&gt;/labs:/home/csapp/project&amp;quot;&lt;/span&gt; xieguochao/csapp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在浏览器中打开 &lt;code&gt;http://localhost:7777&lt;/code&gt; 即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="csapp" scheme="http://www.wukai.me/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>我是如何管理笔记文件的</title>
    <link href="http://www.wukai.me/2022/08/01/how-to-manage-notes/"/>
    <id>http://www.wukai.me/2022/08/01/how-to-manage-notes/</id>
    <published>2022-07-31T16:00:00.000Z</published>
    <updated>2022-08-01T15:06:01.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="那些年使用过的笔记软件">那些年使用过的笔记软件</h2><p>这些年我换过许多笔记软件，最开始使用的是<strong>Evernote/印象笔记</strong>，因为可以实现电脑端和手机端的同步，加上方便的浏览器的剪藏扩展，成了我大学时期的主力应用。</p><p>后来我买了一台微软的 Surface3 平板，附赠一年的Office365，其中就包含了 <strong>OneNote</strong> 应用。OneNote笔记本的设置深得我心，搭配手写笔的体验很好，它的搜索功甚至能直接搜到图片上的文字。</p><p>虽然 OneNote 有着强大的格式功能，但是不原生支持 markdown格式，笔记中的代码格式一直是个问题。之后我切换到了 Mac 平台，接触到了<strong>Bear（熊掌记）</strong>，第一次使用的感觉很惊艳，支持markdown，内置了多款主题可供选择。为了获得设备间的同步功能，我选择了付费。Bear也成了我这几年最常用的笔记应用。</p><span id="more"></span><p>Bear最大的优点就是它的颜值高，能在文件任意位置添加标签也很方便。但是它也有一些缺点：只能在苹果平台使用；没有目录功能；不支持表格。</p><p>这几年间，Bear 几乎没有什么功能上的更新，多年前开发者就声称在开发的Web 编辑器也遥遥无期。</p><p>在这期间，我又试用过了<strong>Notion</strong>，功能的确强大，但当时使用的版本有几个缺陷：当时对免费用户能使用的 Block数量有所限制；搜索功能有欠缺；用着卡顿；需要翻墙。因为 Notion的强大功能，甚至会有专门针对 Notion的教程，让我开始思考我真的需要这么多功能吗。</p><p>我还面临一个问题，既然可以随手添加新笔记，当有了几百条没有整理过的笔记之后，查看起来也不方便，我的解决方案是换一个新的笔记应用，最后笔记分散在了多个不互通的应用中。</p><p>市场上有足够多的笔记应用了，包括收费的以及各种开源的。假如我需要功能1、功能2，但是可能应用A具有了功能1，而只有应用B有功能2，难道需要把两个应用都安装上。</p><p>我放弃了寻找一个完美的笔记应用，决定自己写一个笔记文件的管理应用，暂时将编辑功能放在一边，先专注于文件的管理。</p><h2 id="开发自己的管理工具">开发自己的管理工具</h2><p>我的笔记大部分是计算机相关的，有着大量的代码片段，markdown格式是必选的。我很喜欢 Bear 中添加标签的方式，只要标签是以<code>#</code> 开头即可，而市面上大部分给 markdown文件加标签的方式是使用 <code>yml</code> 配置。</p><p>我理了下我的需求： 1. 支持 markdown，尽量是标准的 markdown 1.支持文件夹管理 1. 支持标签管理（<code>#tag</code>的格式） 1.文件保存在本地，与应用分离 1. 可以用 git 来做版本的控制 1. 主题可自定义1. 可多端同步 1. ...</p><p>开发中我选择使用一个本地开启的 Node.js服务器来处理文件，在浏览器中进行 UI的展示，两者间通过接口通信。经过了一段时间的开发后，完成了我的笔记管理应用<ahref="https://github.com/noiron/knowledge-center">knowledge-center</a>。</p><figure><imgsrc="https://raw.githubusercontent.com/noiron/knowledge-center/d09407a0db45a80effc81930c2ef43dbaa6f3b36/screenshots/file-tree-20220127.png"alt="knowledge-center-文件夹展示" /><figcaption aria-hidden="true">knowledge-center-文件夹展示</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/noiron/knowledge-center/d09407a0db45a80effc81930c2ef43dbaa6f3b36/screenshots/tags-20220127.png"alt="knowledge-center-标签展示" /><figcaption aria-hidden="true">knowledge-center-标签展示</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/noiron/knowledge-center/d09407a0db45a80effc81930c2ef43dbaa6f3b36/screenshots/tag-cloud-20220127.png"alt="knowledge-center-标签云展示" /><figcaption aria-hidden="true">knowledge-center-标签云展示</figcaption></figure><p>在完成了基础功能之后，我就在平时开始了使用。这个应用专注于文件的管理，需要编辑功能时则由应用提供的快捷功能切换到VSCode 或者 Typora中完成。作为唯一用户的我也觉得不方便，考虑到这一点，基础的编辑功能不可少。</p><p>如果需要融合编辑器的功能，整个应用可能需要利用 electron技术来进行重构。在开始这么做之前，我问了自己一个问题：我开发的这个应用的编辑体验能超过Typora 吗？我估计了一下自己能投入的时间精力，得出的结论是不可能。</p><p>于是我换了一种思路，我对于 markdown 文件的编辑工作是用 VSCode 和Typora 完成的，既然如此，何不写一个 VSCode 的扩展来完成呢。</p><h2 id="将管理工具移植为-vscode-扩展">将管理工具移植为 VSCode 扩展</h2><p>借用 VSCode扩展的方式，我将不需要考虑文件的编辑、本地图片展示、文件中相对路径等等问题。在学习了<a href="https://code.visualstudio.com/api">VSCode的扩展开发</a>之后，我将 knowledge-center 工具改造成了扩展版<strong>KaiNotes</strong>。它提供了按标签将文件分类的功能。从下面可以获取使用地址和代码地址，或者直接在VSCode 中搜索 kainotes 安装使用。</p><ul><li><p><ahref="https://marketplace.visualstudio.com/items?itemName=noiron.kainotes">扩展市场地址</a></p></li><li><p><ahref="https://github.com/noiron/kainotes">源码地址</a></p></li></ul><figure><imgsrc="https://raw.githubusercontent.com/noiron/KaiNotes/27ce2bf36753e7c12905657105579661059cc3d2/screenshots/main.png"alt="kainotes" /><figcaption aria-hidden="true">kainotes</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/noiron/KaiNotes/27ce2bf36753e7c12905657105579661059cc3d2/screenshots/tag-cloud.png"alt="kainotes-tag-cloud" /><figcaption aria-hidden="true">kainotes-tag-cloud</figcaption></figure><p>扩展现在已经完成了基础功能的开发，自我感觉使用体验不错。</p><h2 id="我的笔记管理流程">我的笔记管理流程</h2><p>现在我的笔记流程是这样的： 1. 创建一个 git 仓库用于存放笔记文件 - Git自带了文件的编辑历史 - 只要将仓库同步至远端就相当于做了备份 2.编辑文件时使用 VSCode 或 Typora - 简单的编辑在 VSCode中在完成，突出一个方便快捷，预览功能可搭配 Markdown Preview Enhanced扩展 - 较复杂的编辑会选择Typora，所见即所得搭配可选择的主题会有很好的编辑体验 3.笔记文件的管理会在 VSCode 中使用我的 kainotes 扩展来完成 -按标签查看相关的笔记 - 利用标签词云来直观查看笔记数量 4.需要记录零散内容则使用备忘录或Bear -备忘录足够方便，多种设备均可输入，iPad 还可使用手写 - Bear 同步功能和markdown 输入不错，既然给 Bear 续了费，那就继续使用下去， -零散的内容根据需要整理到笔记仓库中</p><p>KaiNotes还有不少功能等着开发，比如重命名标签、收藏文件等功能，还会继续完善。</p><p>最近在更新了 Mac 系统后，发现苹果的备忘录应用也支持添加<code>#tag</code> 格式的标签了。如果备忘录能支持markdown，它就几乎能满足我的所有需求了。</p><p>现在还有双链笔记的概念，<strong>roam</strong>、<strong>logseq</strong>等应用我还没有尝试过。以后可能会取其所长整合到我的工具中去，或者更新我的笔记管理方式。</p><p>笔记工具太多了，在使用它们的过程中我一直在提醒自己不要本末倒置，工具是次要的，内容才重要。记下来的笔记也是需要复习整理的，才能从单纯的笔记转变为知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;那些年使用过的笔记软件&quot;&gt;那些年使用过的笔记软件&lt;/h2&gt;
&lt;p&gt;这些年我换过许多笔记软件，最开始使用的是
&lt;strong&gt;Evernote/印象笔记&lt;/strong&gt;，因为可以实现电脑端和手机端的同步，加上方便的浏览器的剪藏扩展，成了我大学时期的主力应用。&lt;/p&gt;
&lt;p&gt;后来我买了一台微软的 Surface3 平板，附赠一年的
Office365，其中就包含了 &lt;strong&gt;OneNote&lt;/strong&gt; 应用。OneNote
笔记本的设置深得我心，搭配手写笔的体验很好，它的搜索功甚至能直接搜到图片上的文字。&lt;/p&gt;
&lt;p&gt;虽然 OneNote 有着强大的格式功能，但是不原生支持 markdown
格式，笔记中的代码格式一直是个问题。之后我切换到了 Mac 平台，接触到了
&lt;strong&gt;Bear（熊掌记）&lt;/strong&gt;，第一次使用的感觉很惊艳，支持
markdown，内置了多款主题可供选择。为了获得设备间的同步功能，我选择了付费。Bear
也成了我这几年最常用的笔记应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vscode" scheme="http://www.wukai.me/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>利用 Gist 在博客中同步代码的一种方法</title>
    <link href="http://www.wukai.me/2022/02/28/gist-for-blog/"/>
    <id>http://www.wukai.me/2022/02/28/gist-for-blog/</id>
    <published>2022-02-27T16:00:00.000Z</published>
    <updated>2022-08-01T13:59:56.567Z</updated>
    
    <content type="html"><![CDATA[<p>如果想在博客中分享代码片段，我们可以直接把代码复制过来，也可以利用Github 的 Gist 代码片段来分享代码。</p><p>现在考虑这样一种情况，如果想分享的代码来自于一个 repo中的文件，博客中需要引用其中的代码。比如在我的上一篇文章<ahref="http://www.wukai.me/2022/02/27/nodejs-traverse-folder">使用 Nodejs遍历文件夹</a>中，所有的代码都来自于这个 repo: <ahref="https://github.com/noiron/traverse-folder">traverse-folder</a>。如果直接复制代码，则不能保证repo 和博客间的代码同步。当 repo中的文件发生改动时，除非手动编辑博客相应位置，否则博客中的就是旧的代码。而在博客中引用gist，虽然 gist 的更新会直接展示在博客中，但是仍然需要手动更新gist。</p><p>基于此，我们可以采用这样的一种思路，通过<em>某种方式</em>自动将 repo中的文件同步至 gist，然后在博客中引用 gist，从而保证更新了 repo中的文件后，博客中的代码也会自动更新。</p><span id="more"></span><h2 id="github-actions">Github Actions</h2><p>这里的<em>某种方式</em>就是用 <strong>Github Actions</strong>来实现的。Github Action提供了自动运行的工作流，可以在某些时机触发然后执行相应任务。我们要实现的功能可以在我们每次push 代码的时候触发，然后同步 gist。</p><p><a href="https://github.com/marketplace?type=actions">Github的市场</a>提供了很多官方及第三方的 action，可以从中挑选合适的 action来实现需求，以下的两个 action 都可以用于实现我们的目的：</p><ul><li><ahref="https://github.com/exuanbo/actions-deploy-gist">actions-deploy-gist</a></li><li><ahref="https://github.com/Popsiclestick/gist-sync-action">gist-sync-action</a></li></ul><p>以 <code>actions-deploy-gist</code> 为例，需要这么几步：</p><ol type="1"><li>先创建一个新的 gist</li><li>在<a href="https://github.com/settings/tokens">这里</a>创建一个新的token，scope 选择 gist。这里会拿到一个 类似于<code>ghp_3vDXRBAzjXA5rtDMyWMofSNeLwxL4W3*****</code> 的 accesstoken，会在下一步用到。</li><li>进入 repo 的 Settings &gt; Secrets -&gt; Actions 页面，添加一个secret，名称为<code>GIST_TOKEN</code>（名字可随意，只要与后面的配置文件保持一致），值为上面的token。</li><li>创建一个新的 action，编辑 action 的配置文件，填入相应的文件信息</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">exuanbo/actions-deploy-gist@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="comment"># 名字可以是 TOKEN 或 GIST_TOKEN 等等，只要和上面第三步中保持一致即可</span></span><br><span class="line">    <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">gist_id:</span> <span class="string">from_your_gist_url</span></span><br><span class="line">    <span class="attr">gist_description:</span> <span class="string">&#x27;foo bar&#x27;</span></span><br><span class="line">    <span class="attr">gist_file_name:</span> <span class="string">foo.bar</span></span><br><span class="line">    <span class="attr">file_path:</span> <span class="string">./dist/foo.bar</span></span><br></pre></td></tr></table></figure><p>完整的配置可参考我在这个项目中的<ahref="https://github.com/noiron/traverse-folder/blob/master/.github/workflows/main.yml">配置文件</a>：</p><script src="https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js?file=main.yml"></script><p>有趣的一点，注意到上面的这个 gist 引用中的内容就是 action的配置，而这个 gist本身就是靠其中的内容实现了同步，形成了一个<strong>“自指”</strong>。</p><p>因为我需要同步多个文件至一个 gist 中，所以我重复了<code>uses: exuanbo/actions-deploy-gist@v1.1.2</code>多次。（这里可能会有更佳的写法，待更新）</p><p>完成以上工作后，每次更新 repo，相应的 gist 就会改变了。</p><h2 id="gist-中多文件如何引用">Gist 中多文件如何引用</h2><p>接下来我们看下如何在博客中引用 gist：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 script 标签是通用的方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在使用 Hexo 建立的博客中还可以这样写 --&gt;</span></span><br><span class="line">&#123;% gist f6be6840739c7c0fc356659d64db96fc %&#125;</span><br></pre></td></tr></table></figure><p>这里有一个小问题，如果一个 gist中包含有多个文件，上面的方式会将所有的文件都展示出来，如果想只展示其中一个文件，可以加上文件名，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 url 上用 file 参数带上文件名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js?file=traverseFolderList.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 gist id 后面再加上文件名 --&gt;</span></span><br><span class="line">&#123;% gist f6be6840739c7c0fc356659d64db96fc traverseFolderList.js %&#125;</span><br></pre></td></tr></table></figure><p>如果文件名中有空格：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 %20 来代替空格，注意 encodeURIComponent(&#x27; &#x27;) == &#x27;%20&#x27; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js?file=Example%20File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Hexo 中可以选择用双引号包裹文件名 --&gt;</span></span><br><span class="line">&#123;% gist f6be6840739c7c0fc356659d64db96fc &quot;Example File&quot; %&#125;</span><br></pre></td></tr></table></figure><p>经过上面的操作后，就可以在博客中引用 repo 中的文件了，更新 repo后，博客中的文件也会保持同步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果想在博客中分享代码片段，我们可以直接把代码复制过来，也可以利用
Github 的 Gist 代码片段来分享代码。&lt;/p&gt;
&lt;p&gt;现在考虑这样一种情况，如果想分享的代码来自于一个 repo
中的文件，博客中需要引用其中的代码。比如在我的上一篇文章&lt;a
href=&quot;http://www.wukai.me/2022/02/27/nodejs-traverse-folder&quot;&gt;使用 Nodejs
遍历文件夹&lt;/a&gt;中，所有的代码都来自于这个 repo: &lt;a
href=&quot;https://github.com/noiron/traverse-folder&quot;&gt;traverse-folder&lt;/a&gt;。如果直接复制代码，则不能保证
repo 和博客间的代码同步。当 repo
中的文件发生改动时，除非手动编辑博客相应位置，否则博客中的就是旧的代码。而在博客中引用
gist，虽然 gist 的更新会直接展示在博客中，但是仍然需要手动更新
gist。&lt;/p&gt;
&lt;p&gt;基于此，我们可以采用这样的一种思路，通过&lt;em&gt;某种方式&lt;/em&gt;自动将 repo
中的文件同步至 gist，然后在博客中引用 gist，从而保证更新了 repo
中的文件后，博客中的代码也会自动更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="gist" scheme="http://www.wukai.me/tags/gist/"/>
    
  </entry>
  
  <entry>
    <title>使用 Nodejs 遍历文件夹</title>
    <link href="http://www.wukai.me/2022/02/27/nodejs-traverse-folder/"/>
    <id>http://www.wukai.me/2022/02/27/nodejs-traverse-folder/</id>
    <published>2022-02-27T10:41:52.000Z</published>
    <updated>2022-02-27T14:50:11.950Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一个管理 markdown 文件的工具 <ahref="https://github.com/noiron/knowledge-center">knowledge-center</a>，需要读取指定文件夹内所有markdown 文件。因此需要用 Node.js来实现遍历一个文件夹内所有文件的功能。</p><p>Node.js 中提供了这些有用的 API：</p><ul><li><code>fs.readdir</code>：异步读取文件夹</li><li><code>fs.readdirSync</code>：同步读取文件夹</li><li><code>fs.statSync</code>：同步获取文件属性</li></ul><span id="more"></span><h2 id="获取的文件列表为数组格式">获取的文件列表为数组格式</h2><p>对于遍历的结果，我们可以选择按列表或文件树来展示。先从最简单的情况看起，用同步方式处理，返回结果是一个列表。</p><script src="https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js?file=traverseFolderList.js"></script><p>先使用 <code>fs.readdirSync</code>获取文件列表，然后遍历文件列表，使用 <code>fs.statSync</code>获取列表中文件的状态，如果是文件，则添加到文件列表中，如果是文件夹，则递归调用<code>traverseFolderList</code> 函数，直到获取到所有文件。</p><h2 id="获取的文件列表为对象格式">获取的文件列表为对象格式</h2><p>如果我们想展示文件夹目录结构，那么列表格式的就不太方便了。假设有如下的文件夹结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./1</span><br><span class="line">├── 2</span><br><span class="line">│   ├── test2.txt</span><br><span class="line">│   └── test2_1.txt</span><br><span class="line">└── 3</span><br><span class="line">    ├── 4</span><br><span class="line">    │   └── test4.txt</span><br><span class="line">    └── test3.txt</span><br></pre></td></tr></table></figure><p>希望获取到的对象结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">root</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;./1&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;folder&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>],</span><br><span class="line">    <span class="attr">isRoot</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">2</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;folder&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [<span class="string">&#x27;2/test2.txt&#x27;</span>, <span class="string">&#x27;2/test2_1.txt&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">3</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;3&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;folder&#x27;</span>, <span class="attr">children</span>: [<span class="string">&#x27;3/4&#x27;</span>, <span class="string">&#x27;3/test3.txt&#x27;</span>] &#125;,</span><br><span class="line">  <span class="string">&#x27;2/test2.txt&#x27;</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;2/test2.txt&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;file&#x27;</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;2/test2_1.txt&#x27;</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;2/test2_1.txt&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;file&#x27;</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;3/4/test4.txt&#x27;</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;3/4/test4.txt&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;folder&#x27;</span>, <span class="attr">children</span>: [] &#125;,</span><br><span class="line">  <span class="string">&#x27;3/4&#x27;</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;3/4&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;folder&#x27;</span>, <span class="attr">children</span>: [<span class="string">&#x27;3/4/test4.txt&#x27;</span>] &#125;,</span><br><span class="line">  <span class="string">&#x27;3/test3.txt&#x27;</span>: &#123; <span class="attr">path</span>: <span class="string">&#x27;3/test3.txt&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;file&#x27;</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个对象以文件/文件夹相对于根目录的相对路径为key，每个节点包含了这些属性：</p><ul><li><code>type</code>：用于区分文件或文件夹类型</li><li><code>path</code>：相对路径</li><li><code>children</code>：如果是文件夹类型，则其中是子文件的相对路径</li></ul><script src="https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js?file=traverseFolderObj.js"></script><h2 id="异步方式">异步方式</h2><p>在上面的实现中，都是使用了同步的方式来处理，即<code>fs.readdirSync</code> 方法，可以使用异步方式来处理吗？</p><p>可以选择 <code>fs.readdir</code> 来异步读取文件夹,但是回调函数的调用方式不太方便。在 Node 10+ 中提供了<code>fs.promises</code>API，其中提供了一些文件系统的方法，它们返回的是一个 Promise对象，而非使用回调函数。这里可以从 <code>fs.promises</code> 中引入<code>readdir</code> 方法，从而可以使用方便的 <code>async/await</code>语法来进行异步处理，避免了回调函数的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readdir &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).promises; </span><br></pre></td></tr></table></figure><p>将上面的 <code>traverseFolderList</code> 方法重写为异步格式：</p><script src="https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js?file=asyncTraverseFolderList.js"></script><h2 id="比较同步和异步两种方案">比较同步和异步两种方案</h2><p><code>traverseFolderList</code> 和<code>asyncTraverseFolderList</code>返回的结果都是列表格式，我们可以写一个测试脚本来比较下二者的运行时间：</p><script src="https://gist.github.com/noiron/f6be6840739c7c0fc356659d64db96fc.js?file=index.js"></script><p>分别用两个函数遍历了同一个文件夹十次后，统计结果如下，异步方式比同步方式减少了约18%的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步 - 平均耗时：1217.1ms</span><br><span class="line">异步 - 平均耗时：1025.7ms</span><br></pre></td></tr></table></figure><p>注意一点，本文中的代码都是没有做错误处理的，实际上读取文件时可能会出错，因此将相应的代码使用<code>try...catch</code> 包起来是一个合理的做法。</p><h2 id="参考资料">参考资料</h2><blockquote><p>https://stackoverflow.com/a/45130990</p><p><ahref="https://nodejs.org/dist/latest-v10.x/docs/api/fs.html#fs_fs_promises_api">fs.promisesAPI</a></p><p>https://javascript.info/promisify</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写一个管理 markdown 文件的工具 &lt;a
href=&quot;https://github.com/noiron/knowledge-center&quot;&gt;knowledge-center&lt;/a&gt;，需要读取指定文件夹内所有
markdown 文件。因此需要用 Node.js
来实现遍历一个文件夹内所有文件的功能。&lt;/p&gt;
&lt;p&gt;Node.js 中提供了这些有用的 API：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fs.readdir&lt;/code&gt;：异步读取文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.readdirSync&lt;/code&gt;：同步读取文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.statSync&lt;/code&gt;：同步获取文件属性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="node.js" scheme="http://www.wukai.me/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>如何解数独</title>
    <link href="http://www.wukai.me/2022/02/16/sudoku/"/>
    <id>http://www.wukai.me/2022/02/16/sudoku/</id>
    <published>2022-02-15T16:00:00.000Z</published>
    <updated>2022-02-27T04:19:27.767Z</updated>
    
    <content type="html"><![CDATA[<p>数独游戏的规则很简单，在9x9的矩阵中，每行、每列、每个九宫格中都需要填入1~9共九个数字，且不重复。</p><p>Peter Norvig 的这篇文章 <ahref="https://norvig.com/sudoku.html">Solving Every Sudoku Puzzle</a>详细介绍了一种解数独的方法。文中的代码基于 Python2 实现，我将其改写成了JavaScript 的版本，项目可见 <ahref="https://github.com/noiron/sudoku">noiron/sudoku</a>。</p><p>这篇文章中记录了我的理解而非原文的翻译，如果需要更详情的解释，可以查看原文。</p><span id="more"></span><h2 id="数据的表示">数据的表示</h2><p>首先需要考虑的是如何表示数据，数独的行使用 A-I 的字母表示，列使用 1-9的数字表示。代码中用到了以下的术语/变量：</p><ul><li><code>square</code> 所有81个格子的标记<code>['A1', 'A2', 'A3', ... , 'I7', 'I8', 'I9']</code></li><li><code>unit</code> 一个格子所在的行、列或九宫格</li><li><code>unitList</code> 包含9行、9列、9个九宫格，共27个 unit</li><li><code>peers</code> 格子所在三个 unit 中的其他格子，共20个</li><li><code>grid</code> 使用文本格式来表示数独的初始状态，1~9代表数字，0或.代表此处未填入</li><li><code>values</code> 一个以 square 为 key 的map，给出每个格子的可能值，eg.<code>&#123;'A1':'12349', 'A2':'8', ...&#125;</code></li></ul><p>对于数独的初始状态使用文本格式来表示，如下所示的三种格式代表的是同一个数独：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......</span><br><span class="line"></span><br><span class="line">400000805</span><br><span class="line">030000000</span><br><span class="line">000700000</span><br><span class="line">020000060</span><br><span class="line">000080400</span><br><span class="line">000010000</span><br><span class="line">000603070</span><br><span class="line">500200000</span><br><span class="line">104000000</span><br><span class="line"></span><br><span class="line">4 . . |. . . |8 . 5 </span><br><span class="line">. 3 . |. . . |. . . </span><br><span class="line">. . . |7 . . |. . . </span><br><span class="line">------+------+------</span><br><span class="line">. 2 . |. . . |. 6 . </span><br><span class="line">. . . |. 8 . |4 . . </span><br><span class="line">. . . |. 1 . |. . . </span><br><span class="line">------+------+------</span><br><span class="line">. . . |6 . 3 |. 7 . </span><br><span class="line">5 . . |2 . . |. . . </span><br><span class="line">1 . 4 |. . . |. . . </span><br></pre></td></tr></table></figure><p>这部分的 JS 代码实现可以看代码：<ahref="https://github.com/noiron/sudoku/blob/master/base.js">data.js</a></p><p>开始时，每个格子都可以是 1~9的任何数字，然后从初始状态开始给每个格子填入相应的数字。解数独的过程就是在减少每个格子可以填入的数字，直到所有格子都能且只能填入1个数字。这里需要用到两种方法：<strong>约束传播（ConstraintPropagation）</strong>和<strong>搜索（Search）</strong>。</p><h2 id="约束传播constraint-propagation">约束传播（ConstraintPropagation）</h2><p>在处理数独的初始状态时用了 <code>parseGrid()</code> 函数，其中调用了<code>assign(values, square, digit)</code> 方法，即将 digit 填入square。</p><p>解数独有两个重要策略：</p><ol type="1"><li>如果一个格子只有唯一的可选数字，则从它的 peers 中删除这个数字</li><li>如果一个 unit中只有一个格子可以填入某一个数字，则将这个数字填入这个格子</li></ol><p>这里需要使用 <code>assign()</code> 和 <code>eliminate()</code>两个函数，代码见：<ahref="https://github.com/noiron/sudoku/blob/master/solve.js">solve.js</a></p><p>经过这个过程后一些简单的数独就可以得出解了，但对复杂的数独并非如此。所以需要使用<strong>搜索（Search）</strong>来进一步处理。</p><h2 id="搜索search">搜索（Search）</h2><p>这里的搜索指的是系统地尝试所有的可能性，直到找到解。对于数独来说就是对于每个未确定的格子，尝试填入一个可能的数字，然后继续搜索。如果出现了矛盾，就换一个数字。这是一个递归的过程，即深度优先搜索（depth-firstsearch）。</p><p><code>search()</code> 函数的具体代码见：<ahref="https://github.com/noiron/sudoku/blob/master/solve.js">solve.js</a></p><h2 id="整体流程">整体流程</h2><p>整体的流程图如下：</p><pre class="mermaid" style="text-align: center;">            flowchart TB            %% init(初始化)开始 --> gridValues("gridValues()\n将字符串表示转换为map");gridValues --> assign("assign()"\n给特定格子分配一个数字);assign --> canAssign{分配过程\n没有矛盾?};canAssign -- 无法分配 ----> 无解canAssign-- 可以分配 --> eliminate("eliminate()\n进行约束传播");eliminate --> onlyOne{发现某个格子只有\n唯一的可能性}onlyOne -- 是的 --> assignonlyOne -- 否 --> search("search()\n依次尝试可能的数字\nDFS递归处理");search --> found{每个格子都能\n分配唯一的数字?}found -- 不行 --> 无解 --> 结束found -- 可以 --> 找到答案 --> 结束          </pre><p>至此就完成了数独的解法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数独游戏的规则很简单，在9x9的矩阵中，每行、每列、每个九宫格中都需要填入1~9共九个数字，且不重复。&lt;/p&gt;
&lt;p&gt;Peter Norvig 的这篇文章 &lt;a
href=&quot;https://norvig.com/sudoku.html&quot;&gt;Solving Every Sudoku Puzzle&lt;/a&gt;
详细介绍了一种解数独的方法。文中的代码基于 Python2 实现，我将其改写成了
JavaScript 的版本，项目可见 &lt;a
href=&quot;https://github.com/noiron/sudoku&quot;&gt;noiron/sudoku&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这篇文章中记录了我的理解而非原文的翻译，如果需要更详情的解释，可以查看原文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://www.wukai.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="sudoku" scheme="http://www.wukai.me/tags/sudoku/"/>
    
  </entry>
  
  <entry>
    <title>一个 styled-components 的问题（props or css variables）</title>
    <link href="http://www.wukai.me/2021/12/22/styled-components-props-or-css-variables/"/>
    <id>http://www.wukai.me/2021/12/22/styled-components-props-or-css-variables/</id>
    <published>2021-12-21T16:00:00.000Z</published>
    <updated>2022-02-16T13:57:16.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题的起因">问题的起因</h2><p>最近需要实现这么一个功能，通过拖动来改变窗口左侧的文件列表栏的宽度。我选择了用<code>styled-components</code>来实现这个功能，并写了如下的样式组件，其中将边栏当前的宽度<code>width</code> 作为属性传入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StyledFileList = styled.div&lt;&#123; <span class="attr">width</span>: <span class="built_in">number</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  position: absolute;</span></span><br><span class="line"><span class="string">  top: 0;</span></span><br><span class="line"><span class="string">  left: 0;</span></span><br><span class="line"><span class="string">  width: <span class="subst">$&#123;props =&gt; props.width + <span class="string">&#x27;px&#x27;</span>&#125;</span>;</span></span><br><span class="line"><span class="string">  height: 100%;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>但是当我快速拖动边栏时，<code>width</code>变化得非常频繁，在控制台中展示了如下的 Warning。</p><figure><img src="/asset/images/2021-12-22-sc-console.png"alt="控制台warning" /><figcaption aria-hidden="true">控制台warning</figcaption></figure><span id="more"></span><p>大意是仅为这一个组件就生成了超过 200 个class。利用开发者工具的查找元素，改变 <code>width</code>时可以观察到元素上的 class 名称一直在变化。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">width</span>=<span class="string">&quot;270&quot;</span> <span class="attr">class</span>=<span class="string">&quot;sc-bdvvtL ckAtiw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">width</span>=<span class="string">&quot;271&quot;</span> <span class="attr">class</span>=<span class="string">&quot;sc-bdvvtL bBcytR&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以确定 <code>styled-components</code> 给每一个不同的<code>width</code> 属性都生成了一个 class。如果在 html 中搜索相应的class 名称（如上面的代码中是 <code>ckAtiw</code> 和<code>bBcytR</code>），可以在 <code>&lt;head&gt;</code> 的<code>&lt;style&gt;</code>标签中找到它们对应的样式内容，稍加比较就可以发现除了 <code>width</code>以外的部分都是相同的。</p><p><code>styled-components</code>处理样式的过程是这样的：属性改变 -&gt;重新生成样式 -&gt; 插入到 <code>&lt;head&gt;</code>中，这个过程如果重复很多次，会产生大量的 CSS内容冗余，很有可能造成性能问题。而我们可以通过使用 CSS变量来解决这个问题。</p><h2 id="使用-css-变量">使用 CSS 变量</h2><p>我是在这篇文章 <ahref="https://www.joshwcomeau.com/css/styled-components/#css-variables"><em>Thestyled-components Happy Path</em></a> 中学到了在<code>styled-components</code> 中使用 CSS 变量（CSSvariable）的技巧。</p><h3 id="什么是-css-变量">什么是 CSS 变量</h3><p>CSS 变量是以 <code>--</code>开头的属性名称，它们的值可以是任何类型的值，使用<code>var(--your-variable-name)</code> 来应用样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--your-awesome-<span class="attribute">color</span>: darkcyan;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--your-awesome-color);</span><br><span class="line"></span><br><span class="line">--this-<span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="built_in">var</span>(--this-padding);</span><br></pre></td></tr></table></figure><p style="  --your-awesome-color: darkcyan;  color: var(--your-awesome-color);  --this-padding: 20px;  padding-left: var(--this-padding);">这一行文字就是应用了上面的 CSS，你可以在控制台中修改样式并观察变化。</p><h3 id="改写原代码">改写原代码</h3><p>对于之前的边栏组件，我们可以换一个写法来解决，不再使用<code>props</code> 来传入宽度，而是使用 CSS 变量，组件代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;StyledFileList</span><br><span class="line">  <span class="comment">// 这里定义了 --width 这个 CSS 变量，width 是一个 number</span></span><br><span class="line">  style=&#123;&#123; <span class="string">&#x27;--width&#x27;</span>: width + <span class="string">&#x27;px&#x27;</span>&#125; <span class="keyword">as</span> CSSProperties&#125;</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StyledFileList = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  position: absolute;</span></span><br><span class="line"><span class="string">  top: 0;</span></span><br><span class="line"><span class="string">  left: 0;</span></span><br><span class="line"><span class="string">  // 这里应用了 CSS 变量</span></span><br><span class="line"><span class="string">  width: var(--width);</span></span><br><span class="line"><span class="string">  height: 100%;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时再改变左侧边栏的宽度，可发现元素的 class 名称是固定的，只有 style在变化。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sc-bdvvtL jGeOyv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--width:210px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sc-bdvvtL jGeOyv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--width:250px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="/asset/images/2021-12-22-sc-style.png" alt="CSS变量样式" /><figcaption aria-hidden="true">CSS变量样式</figcaption></figure><p>如果检查 <code>&lt;head&gt;</code> 中的内容，会看到在<code>&lt;style&gt;</code>标签中相应的样式内容也只出现了一次，从而解决了样式冗余的问题。</p><h2 id="参考资料">参考资料</h2><blockquote><p><ahref="https://www.joshwcomeau.com/css/styled-components/#css-variables">Thestyled-components Happy Path</a> <ahref="https://www.joshwcomeau.com/react/demystifying-styled-components/">Demystifyingstyled-components</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题的起因&quot;&gt;问题的起因&lt;/h2&gt;
&lt;p&gt;最近需要实现这么一个功能，通过拖动来改变窗口左侧的文件列表栏的宽度。我选择了用
&lt;code&gt;styled-components&lt;/code&gt;
来实现这个功能，并写了如下的样式组件，其中将边栏当前的宽度
&lt;code&gt;width&lt;/code&gt; 作为属性传入。&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; StyledFileList = styled.div&amp;lt;&amp;#123; &lt;span class=&quot;attr&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt; &amp;#125;&amp;gt;&lt;span class=&quot;string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  position: absolute;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  top: 0;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  left: 0;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  width: &lt;span class=&quot;subst&quot;&gt;$&amp;#123;props =&amp;gt; props.width + &lt;span class=&quot;string&quot;&gt;&amp;#x27;px&amp;#x27;&lt;/span&gt;&amp;#125;&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  height: 100%;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是当我快速拖动边栏时，&lt;code&gt;width&lt;/code&gt;
变化得非常频繁，在控制台中展示了如下的 Warning。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/asset/images/2021-12-22-sc-console.png&quot;
alt=&quot;控制台warning&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;控制台warning&lt;/figcaption&gt;
&lt;/figure&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://www.wukai.me/tags/css/"/>
    
      <category term="react" scheme="http://www.wukai.me/tags/react/"/>
    
      <category term="styled-components" scheme="http://www.wukai.me/tags/styled-components/"/>
    
  </entry>
  
  <entry>
    <title>Puppeteer 的使用记录</title>
    <link href="http://www.wukai.me/2021/05/22/puppeteer-notes/"/>
    <id>http://www.wukai.me/2021/05/22/puppeteer-notes/</id>
    <published>2021-05-21T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.547Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Headless Browser</strong>指的是没有图形用户界面（GUI）而是由程序控制的浏览器。<strong>Puppeteer</strong>就是由 Google 推出的一种 headless browser。从 <ahref="https://github.com/puppeteer/puppeteer">Puppeteer的官方文档</a>中可以看到它能做的事有很多：</p><blockquote><ul><li>Generate screenshots and PDFs of pages.</li><li>Crawl a SPA (Single-Page Application) and generate pre-renderedcontent (i.e. "SSR" (Server-Side Rendering)).</li><li>Automate form submission, UI testing, keyboard input, etc. ...</li></ul></blockquote><p>几乎所有能手动在 Chrome 进行的操作现在都可以用 Puppeteer 来完成。</p><p>我之前在工作中就用到了 Puppeteer做了一些页面爬取的工作，这里把使用到或者玩过的一些功能做了下总结和记录。这篇文章并不是一个全面的Puppeteer 的使用教程，毕竟 Puppeteer 的大部分 API 我也没有使用过🙂。</p><span id="more"></span><h2 id="puppeteer-的安装">Puppeteer 的安装</h2><p>Puppeteer 的使用就是如同一个普通的 npm package 一样，使用<code>npm init</code> 新建一个项目后，使用<code>npm install puppeteer</code> 即可。如果安装过程中卡在了下载Chromium 的过程中，可以考虑使用 <code>puppeteer-core</code>来代替，具体可见</p><p><ahref="https://github.com/puppeteer/puppeteer/blob/main/docs/api.md#puppeteer-vs-puppeteer-core">puppeteer-vs-puppeteer-core</a></p><h2 id="打开页面">打开页面</h2><p>先由最基础的打开页面功能开始，新建一个 <code>index.js</code>文件，写入下方的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.close();</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>现在运行<code>node index.js</code>，如果成功运行，你将会看到什么也没有发生😕。这是因为，Puppeteer默认是在 <code>headless</code>模式下运行的，为了能看到确实打开了页面，可以在打开浏览器时加入参数<code>&#123; headless: false &#125;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这里将 headless 设置了为 false，表示打开图形界面</span></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.close();</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>一个典型的流程如下：打开浏览器 -&gt; 打开新页面 -&gt; 去往指定页面-&gt; 关闭页面（可省略） -&gt; 关闭浏览器。</p><h3 id="timeout-问题的解决">Timeout 问题的解决</h3><p>运行上面的代码，可能会出现 <code>TimeoutError</code>的出错提示，这是因为访问指定页面的速度较慢导致了超时。你可以将<code>pageUrl</code> 换成任意国内地址重试。</p><p>默认情况下 Puppeteer 的超时时间为 30s，如果在 30s之内没能打开页面，会有 timeout 的出错提示。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnhandledPromiseRejectionWarning: TimeoutError: Navigation timeout of 30000 ms exceeded</span><br></pre></td></tr></table></figure></p><p>可以通过如下设置解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"><span class="comment">// 将超时时间改为了 60s，如果参数为0，则代表不做限制</span></span><br><span class="line">page.setDefaultNavigationTimeout(<span class="number">60000</span>);</span><br><span class="line"><span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="操作页面">操作页面</h2><h3 id="截图">截图</h3><p>Puppeteer 提供了 <code>screenshot</code>API，可以将页面截图保存下来。运行下面的代码将会在 js文件所在的路径下保存一张名为 <code>screenshot.png</code>的图片文件。这里有一点需要注意，在之前的代码中，我们没有设置窗口的大小，Puppeteer默认打开的是 <code>800*600</code>尺寸的窗口，截图的大小也为<code>800*600</code>（即使是在 <code>headless</code>模式下也是如此）。可以通过 <code>setViewport</code>来改变窗口的大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="comment">// 设置窗口的大小，可以注释下方的一行查看截图的区别</span></span><br><span class="line">  <span class="keyword">await</span> page.setViewport(&#123; <span class="attr">width</span>: <span class="number">1000</span>, <span class="attr">height</span>: <span class="number">500</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;screenshot.png&#x27;</span>),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.close();</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="生成-pdf">生成 PDF</h3><p>同样也可以将页面保存成一个 PDF 文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.pdf(&#123; </span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;page-pdf.pdf&#x27;</span>), </span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;A4&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.close();</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>注意一点，保存为 PDF 的时候，必须在 <code>headless</code>模式下进行。</p><h2 id="模拟设备">模拟设备</h2><p>平时我们浏览的网站可能针对不同的设备会有不同的展示效果，区分移动端和PC端、Android或 iOS 等。Puppeteer 就提供了模拟设备的功能。</p><h3 id="使用已有的设备列表">使用已有的设备列表</h3><p>可以使用 <code>page.emulate(options)</code>来模拟设备，可以在这个文件中看到支持的设备列表：<ahref="https://github.com/puppeteer/puppeteer/blob/main/src/common/DeviceDescriptors.ts">puppeteer/DeviceDescriptors.tsat main · puppeteer/puppeteer · GitHub</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"><span class="comment">// 这里将模拟一台 iPhone XR 设备</span></span><br><span class="line"><span class="keyword">const</span> iPhone = puppeteer.devices[<span class="string">&#x27;iPhone XR&#x27;</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.emulate(iPhone);</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="添加自定义的-useragent">添加自定义的 UserAgent</h3><p>也可以添加自己的 UserAgent的方式来模拟列表中没有的设备。下面的代码中以 iPad Pro 为例，说明如何设置UserAgent（其实 iPad Pro是存在于上面的设备列表中的，这里只是举了个例子）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.setViewport(&#123; <span class="attr">width</span>: <span class="number">1024</span>, <span class="attr">height</span>: <span class="number">1366</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.setUserAgent(</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="监听-response">监听 response</h2><p>考虑一下这样的场景，如何获取到页面上的所有的图片。当然我们可以拿到整个页面，然后使用<code>document.querySelector()</code> 筛选出所有的 <code>img</code>标签。这样会有一点小问题，如果图片是以 CSS 的<code>background-image</code> 形式引入的，查找 <code>img</code>标签是无法找到的。如果图片地址是由 js动态改变的，可能也会缺失部分图片。</p><p>另一种可选的方式是通过监听 <code>response</code>的方式来处理。可以认为在 Chrome 开发工具的 Network Tab 下能看到的每一个response 都可以在这里拿到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pageUrl = <span class="string">&#x27;https://github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">  page.on(<span class="string">&#x27;response&#x27;</span>, <span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> request = response.request();</span><br><span class="line">    <span class="keyword">const</span> resourceType = request.resourceType();</span><br><span class="line">    <span class="keyword">const</span> contentType = response.headers()[<span class="string">&#x27;content-type&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceType === <span class="string">&#x27;image&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> url = response.url();</span><br><span class="line">      <span class="built_in">console</span>.log(contentType, url);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> page.goto(pageUrl, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>通过 <code>response.headers</code> 可以获取响应的 header信息。如果有需要也可将响应保存成本地的文件。</p><hr /><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Headless Browser&lt;/strong&gt;
指的是没有图形用户界面（GUI）而是由程序控制的浏览器。&lt;strong&gt;Puppeteer&lt;/strong&gt;
就是由 Google 推出的一种 headless browser。从 &lt;a
href=&quot;https://github.com/puppeteer/puppeteer&quot;&gt;Puppeteer
的官方文档&lt;/a&gt;中可以看到它能做的事有很多：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Generate screenshots and PDFs of pages.&lt;/li&gt;
&lt;li&gt;Crawl a SPA (Single-Page Application) and generate pre-rendered
content (i.e. &quot;SSR&quot; (Server-Side Rendering)).&lt;/li&gt;
&lt;li&gt;Automate form submission, UI testing, keyboard input, etc. ...&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;几乎所有能手动在 Chrome 进行的操作现在都可以用 Puppeteer 来完成。&lt;/p&gt;
&lt;p&gt;我之前在工作中就用到了 Puppeteer
做了一些页面爬取的工作，这里把使用到或者玩过的一些功能做了下总结和记录。这篇文章并不是一个全面的
Puppeteer 的使用教程，毕竟 Puppeteer 的大部分 API 我也没有使用过🙂。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://www.wukai.me/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="node.js" scheme="http://www.wukai.me/tags/node-js/"/>
    
      <category term="puppeteer" scheme="http://www.wukai.me/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>2019年总结</title>
    <link href="http://www.wukai.me/2020/01/24/2019-annual-summary/"/>
    <id>http://www.wukai.me/2020/01/24/2019-annual-summary/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>很多年前在学校的时候，中二期的我和朋友讨论过如果穿越到古代想去哪个朝代。我说去三国吧，和刘关张结义，一统天下，岂不美哉。朋友指出，这三人都比你年纪大，你去了只能做小弟。额，这点倒没想到，于是穿越计划无疾而终。去年又翻了下《三国演义》，在第一章桃园三结义中看到了这句“及刘焉发榜招军时，玄德年已二十八岁矣”，哦，看来我再也不用担心穿越到三国时期的年龄问题了。刘备二十八岁时就已经开始匡扶汉室了，而我二十八岁时还在写代码╮(╯_╰)╭。</p><span id="more"></span><h2 id="看过的书">看过的书</h2><p>19年仍然看了大约二十本的新书，数量上和以前差不多。</p><p>小说类： - Flowers for Algernon - 鞑靼人沙漠 - 上帝的图书馆 -日本合众国 - 了不起的盖茨比 - 挪威的森林 - 环界（1-4)</p><p>非虚构类： - 程序员修炼之道 - 黑客与画家 - 影响力 - 未来简史 - 经度 -阅读是一座随身携带的避难所 - 那些科学家们彻夜忧虑的问题 - 量子物理史话 -怪诞行为学1：可预测的非理性</p><h2 id="玩过的游戏">玩过的游戏</h2><p>19年初买了任天堂的 Switch，于是从 Steam 那里省下的金钱和时间又花在了Switch 的游戏上。下面每个游戏都花了十几小时到上百小时不等。</p><ul><li>塞尔达传说</li><li>神界：原罪2</li><li>暗黑破坏神3</li><li>Guns Gore and Cannoli 2</li><li>Dead Cells</li><li>Bastion</li><li>...</li></ul><h2 id="新技能">新技能</h2><p>下半年买了《三十天学会绘画》，没能像书名里写的那样在三十天里看完，用了大约半年终于在12月看完了这本书。按照书里的教程画了一遍之后，很明显，还没有学会绘画。于是又买了本《素描的诀窍》，准备在2020年继续画下去。</p><hr /><p>虽然我知道自己定了新年计划，也是不会去完成的。但希望自己在2020年多看点计算机类的书籍，多写点博客做点记录。2019年的年度总结没赶上元旦完成，今天就祝所有人春节平安快乐吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多年前在学校的时候，中二期的我和朋友讨论过如果穿越到古代想去哪个朝代。我说去三国吧，和刘关张结义，一统天下，岂不美哉。朋友指出，这三人都比你年纪大，你去了只能做小弟。额，这点倒没想到，于是穿越计划无疾而终。去年又翻了下《三国演义》，在第一章桃园三结义中看到了这句“及刘焉发榜招军时，玄德年已二十八岁矣”，哦，看来我再也不用担心穿越到三国时期的年龄问题了。刘备二十八岁时就已经开始匡扶汉室了，而我二十八岁时还在写代码
╮(╯_╰)╭。&lt;/p&gt;
    
    </summary>
    
    
      <category term="年度总结" scheme="http://www.wukai.me/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>从插入图片功能的实现来介绍 Draft.js 富文本编辑器</title>
    <link href="http://www.wukai.me/2019/07/21/draftjs-editor-tutorial-1/"/>
    <id>http://www.wukai.me/2019/07/21/draftjs-editor-tutorial-1/</id>
    <published>2019-07-20T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>在前段时间的工作中，我遇到了一个在桌面端和移动端进行图文混排编辑的需求。虽然如果只需要编辑纯文本和图片，不一定要使用富文本编辑器来实现。但是为了以后方便扩展，比如文本会有样式要求，我还是用Draft.js 实现了一个功能较基础的富文本编辑器。</p><p>我将代码开源在了<ahref="https://github.com/noiron/draft-editor">这个项目 draft-editor</a>中，也可以<ahref="http://www.wukai.me/draft-editor/">在这里在线预览</a>。本文中我将介绍一下一些关于Draft.js 的基础知识，并由此扩展到如何在 Draft.js编辑器中插入图片功能的实现。</p><span id="more"></span><h2 id="从一个基本的编辑器开始">从一个基本的编辑器开始</h2><p>Draft.js 是 Facebook 推出的用于 React的富文本编辑器框架，初始化一个最基本的 Draft.js 的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> ‘react’;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> ‘react-dom’;</span><br><span class="line"><span class="keyword">import</span> &#123;Editor, EditorState&#125; <span class="keyword">from</span> ‘draft-js’;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEditor</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">editorState</span>: EditorState.createEmpty()&#125;;</span><br><span class="line">    <span class="built_in">this</span>.onChange = <span class="function">(<span class="params">editorState</span>) =&gt;</span> <span class="built_in">this</span>.setState(&#123;editorState&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Editor</span> <span class="attr">editorState</span>=<span class="string">&#123;this.state.editorState&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.onChange&#125;</span> /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以<ahref="https://codesandbox.io/s/basic-draft-editor-gzver">在这里查看</a>。这里给<code>Editor</code> 传入一个 <code>editorState</code> 属性，并绑定一个<code>onChange</code>事件，当发生编辑操作时，返回一个新的<code>editorState</code>。这样我们就得到了一个可以进行基本的文本操作的编辑器了。</p><h2 id="immutable.js-数据结构">Immutable.js 数据结构</h2><p>在说明什么是 <code>EditorState</code> 及 Draft.js对于数据的存储方式之前，需要简略介绍一下<strong>Immutables.js</strong>。</p><p>Draft.js 是利用 <ahref="https://github.com/immutable-js/immutable-js">Immutable.js</a>来保存数据的，正如其名，这是一种不可变的数据结构。对于一个Immutable的对象，你无法修改它本身，若想修改其值，只会返回一个新的修改后的对象。将这一点应用在编辑器上，用户的每一次修改都会生成一个最新的状态快照，就很容易实现撤销功能了。</p><p>在 Draft.js 的使用过程中，可能会遇到下面这些数据结构。</p><p><strong><code>Map</code></strong> 类似于 js 中的对象，用<code>.set()</code> 和 <code>.get()</code> 方法进行写和读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Immutable = require(‘immutable’);</span><br><span class="line">const framework = Immutable.Map(&#123; name: &#x27;React&#x27;, age: 6 &#125;);</span><br><span class="line">const newFramework = client.set(&#x27;name&#x27;, &#x27;Vue&#x27;);</span><br><span class="line">console.log(framework.get(&#x27;name&#x27;));</span><br></pre></td></tr></table></figure><p><strong><code>OrderedMap</code></strong> 混合了 <code>object</code>和 <code>array</code> 的特点。通过使用<code>orderedMap.get(‘key’)</code> 和<code>orderedMap.set(‘key’, newValue)</code>这两个方法，可以将它当成一个普通的 <code>object</code> 来使用。但和<code>Map</code> 的不同点在于其中的 key 是按照被加入时的顺序排序的。</p><p><strong><code>Record</code></strong> 也类似于<code>Map</code>，但有一些不同之处。 - 一个 <code>record</code>一旦被初始化，就不能再添加新的 key 了 - 你可以给一个 <code>record</code>实例添加默认值</p><p>还有一点，immutable 的对象，提供了<code>toJS()</code>方法，可将其转成普通的 js对象，这一方法在想查看其内部内容时非常有用。</p><blockquote><p>Immutable.js 参考文章：<ahref="https://blog.jscrambler.com/immutable-data-immutable-js/">ImmutableData with Immutable.js | Jscrambler Blog</a></p></blockquote><h2 id="draft-是如何存储数据的">Draft 是如何存储数据的</h2><h3 id="什么是-editorstate">什么是 EditorState</h3><p>在创建基本的编辑器的时候，我们用到了 <code>EditorState</code>。<code>EditorState</code> 是编辑器最顶层的状态对象，它是一个 ImmutableRecord对象，保存了编辑器中全部的状态信息，包括文本状态、选中状态等。</p><p>调用 <code>editorState.toJS()</code> 可将 immutable record转换成一个普通的 object，打印出来如下： <imgsrc="/asset/images/2019-07-21-draft-editor-01.png" /></p><p>简单地来看下其中的部分内容： - <code>currentContent</code> 是一个<code>ContentState</code> 对象，存放的是当前编辑器中的内容 -<code>selection</code> 中是当前选中的状态 - <code>redoStack</code> 和<code>undoStack</code> 就是撤销/重做栈，它是一个数组，存放的是<code>ContentState</code> 类型的编辑器状态 - <code>decorator</code>会寻找特定的模式，并用特定的组件渲染出来</p><h3 id="什么是-contentstate">什么是 ContentState</h3><p>既然编辑器中的内容是存储在一个 <code>ContentState</code>对象中，那么这个 <code>ContentState</code> 又是什么？</p><p><code>ContentState</code> 也是一个 Immutable Record对象，其中保存了编辑器里的全部内容和渲染前后的两个选中状态。可以通过<code>EditorState.getCurrentContent()</code> 来获取当前的<code>ContentState</code>，同样调用 <code>.toJS()</code>后将它打印出来看下： <imgsrc="/asset/images/2019-07-21-draft-editor-02.png" /></p><p><code>blockMap</code> 和 <code>entityMap</code>里放置的就是编辑器中的 <code>block</code> 和<code>entity</code>，它们是构建 Draft 编辑器的砖瓦。</p><h3 id="什么是-contentblock-和-entity">什么是 ContentBlock 和Entity</h3><p>一个 <code>ContentBlock</code> 表示一个编辑器内容中的一个独立的block，即视觉上独立的一块。</p><p>以下图的编辑器作为一个例子，图中的四个红框标出的部分都是block。在平时阅读文章时，内容是以段落为单位的，在编辑器中每个段落就是一个block，如第一个和最后一个红框中的文字内容。第二个红框中是一张图片，它也是一个block，但显示方式不同于普通的block，为了自定义它的显示方式还需要额外做一些工作，后面会加以详细说明。</p><p>还有一点需要稍作说明，第三个红框中虽然是空白，但它也是一个block，只不过其中的文本为空而已。 <imgsrc="/asset/images/2019-07-21-draft-editor-03.png" /></p><p>此时，输出一下 <code>convertToRaw(currentContent)</code>，看看其中的内容。注意这里的输出结构与上面的<code>currentContent.toJS()</code> 略有所区别，这里只有<code>blocks</code> 和 <code>entityMap</code> 这两项。 <imgsrc="/asset/images/2019-07-21-draft-editor-04.png" /> 可以看到<code>blocks</code> 这个数组中依次存放了各个 <code>block</code>的信息，每一个 <code>block</code> 都是一个 <code>contentBlock</code>对象。</p><p>每个 <code>contentBlock</code> 都有如下的几个属性值： -<code>key</code>: 标识出这是哪一个 block - <code>type</code>:这是何种类型的 block - <code>text</code>: 其中的文字 - ……</p><p>Draft.js 中 <code>block</code> 的 <code>type</code> 有unstyled，paragraph，header-one，atomic …… 等值，在 Draft.js 的文档中<code>atomic</code> 类型对应的是 <code>&lt;figure /&gt;</code>元素，我们也选取了它来实现插入图片的功能。</p><p>图中的这些 block 的除了第三个 key = “1u22q” 的 block 的 type 值是<code>atomic</code> 外，其余的值都是<code>“unstyled”</code>。再仔细看下这个 <code>atomic</code> 类型的block： <img src="/asset/images/2019-07-21-draft-editor-05.png" /></p><p>除了 <code>key</code>，<code>text</code>，<code>type</code>等值之外，在 <code>entityRanges</code> 这一项中保存它保存了使用到的<code>entity</code> 的信息：offset 和 length 确定了 <code>entity</code>在 block 中的范围，而 key 则能让我们去取出对应的<code>entity</code>。</p><p>回到上面的打印出的 <code>contentState</code>的内容，除了<code>blocks</code> 数组外还有一个 <code>entityMap</code>对象。它是以<code>entity</code> 的 <code>key</code>作为键值的对象，里面保存了图片、链接等种类的 <code>entity</code>信息，从中就可获得 <code>blocks</code> 所需要的<code>entity</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entityMap: &#123;</span><br><span class="line"><span class="number">0</span>: &#123; <span class="attr">type</span>: <span class="string">&quot;image&quot;</span>, <span class="attr">mutability</span>: <span class="string">&quot;IMUTABLE&quot;</span>, <span class="attr">data</span>: &#123;&#125; &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>以上介绍了 Draft.js是如何对编辑器中的数据进行存储的，接下来会从代码实现的角度来说明插入图片是如何实现的。</p><h2 id="插入图片的实现">插入图片的实现</h2><h3 id="如何插入图片">如何插入图片</h3><p>插入图片有着这样的流程：首先为图片创建一个<code>entity</code>，然后创建一个带有这个 <code>entity</code> 的新<code>EditorState</code>，然后更新即可。以下是关键部分的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AtomicBlockUtils &#125; <span class="keyword">from</span> <span class="string">&#x27;draft.js&#x27;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> editorState = <span class="built_in">this</span>.state.editorState;</span><br><span class="line"><span class="keyword">const</span> contentState = editorState.getCurrentContent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `contentState.createEntity` 创建一个 `entity`，指定其 `type` 为 `image`</span></span><br><span class="line"><span class="keyword">const</span> contentStateWithEntity = contentState.createEntity(</span><br><span class="line">  ‘image’,</span><br><span class="line">  ‘IMMUTABLE’,</span><br><span class="line">  &#123; src &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取新创建的 `entity` 的 key</span></span><br><span class="line"><span class="keyword">const</span> entityKey = contentStateWithEntity.getLastCreatedEntityKey();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 `EditorState.set()`  来建立一个带有这个 `entity` 的新的 EditorState </span></span><br><span class="line"><span class="keyword">const</span> newEditorState = EditorState.set(</span><br><span class="line">  editorState,</span><br><span class="line">  &#123; <span class="attr">currentContent</span>: contentStateWithEntity &#125;,</span><br><span class="line">  ‘create-entity’</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用`AtomicBlockUtils.insertAtomicBlock` 来插入一个新的 `block`</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  <span class="attr">editorState</span>: AtomicBlockUtils.insertAtomicBlock(newEditorState, entityKey, ‘ ‘)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="如何使用-blockrendererfn-来渲染图片">如何使用 blockRendererFn来渲染图片</h3><p>上面我们已经见到了，一张图片是作为一个 <code>atomic</code> 类型的block 插入的。Draft.js 提供了<code>blockRendererFn</code>让我们可以自定义 <code>ContentBlock</code>的渲染方式，给它传入一个函数后，由该函数来判断这个 block 的<code>type</code> 是什么，然后决定如何渲染。</p><p>以下的这段代码来自 <ahref="https://draftjs.org/docs/advanced-topics-block-components">Draft.js的官方文档</a>，展示了如何处理一个 type 为 <code>atomic</code> 的<code>ContentBlock</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBlockRenderer</span>(<span class="params">contentBlock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = contentBlock.getType();</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;atomic&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">component</span>: MediaComponent,</span><br><span class="line">      <span class="attr">editable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then...</span></span><br><span class="line"><span class="keyword">import</span> &#123;Editor&#125; <span class="keyword">from</span> <span class="string">&#x27;draft-js&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorWithMedia</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Editor</span> <span class="attr">...</span> <span class="attr">blockRendererFn</span>=<span class="string">&#123;myBlockRenderer&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里传递了一个 <code>props</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">component: MediaComponent,</span><br><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>结果等同于<code>&lt;MediaComponent foo='bar' /&gt;</code>，可以利用这里的<code>props</code> 传入所需要的其他数据。</p><p>这里我们就可以定义一个自己的 <code>MediaComponent</code>来决定展现方式。因为不管是图片还是视频等其它的媒体类型，它们的<code>type</code> 都是 <code>atomic</code>。在<code>MediaComponent</code> 里就需要通过 <code>entity</code> 的<code>type</code> 来确定其种类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> entity = props.contentState.getEntity(props.block.getEntityAt(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">const</span> &#123; src &#125; = entity.getData();<span class="comment">// 取出图片的地址</span></span><br><span class="line"><span class="keyword">const</span> type = entity.getType();  <span class="comment">// 判断 entity 的 type 的</span></span><br></pre></td></tr></table></figure><p>当 <code>entity</code> 的 <code>type</code> 是我们自定义的<code>image</code> 时就可以返回 <code>&lt;Image /&gt;</code>组件了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Image src=&#123;src&#125; /&gt; <span class="comment">// 自定义的图片组件 &lt;Image /&gt;</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/noiron/draft-editor/blob/master/src/components/entities/mediaBlockRenderer.js">完整代码可见此文件</a></p><h3 id="如何删除一张图片">如何删除一张图片</h3><p>既然已经插入了图片，那么如何删除它呢？当然我们可以按键盘上的Backspace 键来删除。也可以在图片的右上角加入一个 “X”的图标，点击后删除该图片，实现方式如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">deleteImage = <span class="function">(<span class="params">block</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> editorState = <span class="built_in">this</span>.state.editorState;</span><br><span class="line">  <span class="keyword">const</span> contentState = editorState.getCurrentContent();</span><br><span class="line">  <span class="keyword">const</span> key = block.getKey();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> selection = editorState.getSelection();</span><br><span class="line">  <span class="keyword">const</span> selectionOfAtomicBlock = selection.merge(&#123;</span><br><span class="line">    <span class="attr">anchorKey</span>: key,</span><br><span class="line">    <span class="attr">anchorOffset</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">focusKey</span>: key,</span><br><span class="line">    <span class="attr">focusOffset</span>: block.getLength(),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写 entity 数据，将其从 block 中移除，防止这个 entity 还被其它的 block 引用</span></span><br><span class="line">  <span class="keyword">const</span> contentStateWithoutEntity = Modifier.applyEntity(contentState, selectionOfAtomicBlock, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> editorStateWithoutEntity = EditorState.push(editorState, contentStateWithoutEntity, ‘apply-entity’);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除 block</span></span><br><span class="line">  <span class="keyword">const</span> contentStateWithoutBlock = Modifier.removeRange(contentStateWithoutEntity, selectionOfAtomicBlock, ‘backward’);</span><br><span class="line">  <span class="keyword">const</span> newEditorState =  EditorState.push(editorStateWithoutEntity, contentStateWithoutBlock, ‘remove-range’,);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.onChange(newEditorState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，对图片的相关操作就完成了。</p><h2 id="总结与其他">总结与其他</h2><p>在本文中，介绍了 Draft.js 的基本功能，它是如何进行数据的存储的，及<code>EditorState</code>、<code>ContentState</code>、<code>ContentBlock</code>、<code>Entity</code>等对象间的关系。并以此为基础说明了如何在编辑器中对图片进行操作。</p><p>当然关于 Draft.js还有很多内容没有在本文中提及，如修改行内文本的样式，利用<code>decorators</code> 来插入与渲染链接等等。这些就需要读者探索下Draft.js 的官方文档和其他人的分享并亲自尝试下了。</p><h2 id="参考文章及资源">参考文章及资源</h2><blockquote><p><ahref="https://github.com/noiron/draft-editor">本文所基于的编辑器项目：draft-editor</a></p></blockquote><blockquote><p><ahref="https://medium.com/@rajaraodv/how-draft-js-represents-rich-text-data-eeabb5f25cf2#.q7vpkxmog">HowDraft.js Represents Rich Text Data</a> <ahref="https://medium.com/@siobhanpmahoney/building-a-rich-text-editor-with-react-and-draft-js-part-2-4-persisting-data-to-server-cd68e81c820">Buildinga Rich Text Editor with React and Draft.js, Part 2.4: EmbeddingImages</a> <a href="https://zhuanlan.zhihu.com/p/24951621">Draft.js在知乎的实践</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前段时间的工作中，我遇到了一个在桌面端和移动端进行图文混排编辑的需求。虽然如果只需要编辑纯文本和图片，不一定要使用富文本编辑器来实现。但是为了以后方便扩展，比如文本会有样式要求，我还是用
Draft.js 实现了一个功能较基础的富文本编辑器。&lt;/p&gt;
&lt;p&gt;我将代码开源在了&lt;a
href=&quot;https://github.com/noiron/draft-editor&quot;&gt;这个项目 draft-editor&lt;/a&gt;
中，也可以&lt;a
href=&quot;http://www.wukai.me/draft-editor/&quot;&gt;在这里在线预览&lt;/a&gt;。本文中我将介绍一下一些关于
Draft.js 的基础知识，并由此扩展到如何在 Draft.js
编辑器中插入图片功能的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编辑器" scheme="http://www.wukai.me/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="draft.js" scheme="http://www.wukai.me/tags/draft-js/"/>
    
  </entry>
  
  <entry>
    <title>2018年总结</title>
    <link href="http://www.wukai.me/2019/01/01/2018-annual-summary/"/>
    <id>http://www.wukai.me/2019/01/01/2018-annual-summary/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>到了2018年快要结束的时候，才发现这一年什么也没做啊😂，上一篇博客还是3月份写的。感觉做这个总结就是在提醒自己荒废了一年，虽然不想这么做，但还是来写点什么吧。</p><span id="more"></span><p>今年做的最重要的事应该是换了份工作吧，也换了座城市，4月份从南京来到了上海。</p><p>来到了更大的公司，见识了不同的工作流程，比起以前只有几个开发的小公司正规了不少。工作比以前更忙了些，也尝试了一些新的技术，大部分还是浅尝辄止。</p><h2 id="技术">技术</h2><p>今年在一个工作项目中第一次使用了 React Native开发，了解了RN的一点皮毛，体会了下多端融合开发。</p><p>今年的开发中碰到了不少移动端的兼容性问题，要考虑页面在各种手机、APP、各种版本的webview 中打开的情况，有了一些零散的经验。</p><p>似乎没有正经地看什么技术书籍。</p><h2 id="阅读">阅读</h2><p>看的新书没有多少，倒是在空闲时又翻了翻以前看过的书作为消遣。</p><h3 id="小说类">小说类</h3><ul><li>搏击俱乐部</li><li>基督山伯爵（小学时看过简写本，今年才看完全本）</li><li>占星术杀人魔法</li><li>哈利的十五次人生</li><li>它</li><li>死了七次的男人</li><li>射雕英雄传（国庆节假期时重温了一遍，没想到没多久金庸就去世了）</li></ul><h3 id="自然科学类">自然科学类</h3><p>看了两本科普的小册子，还有《费曼物理学讲义》只看了十章</p><ul><li>七堂极简物理课</li><li>宇宙的最后三分钟</li></ul><h3 id="人文类">人文类</h3><ul><li>他改变了中国（曰_曰）</li><li>南明史 上</li></ul><h3 id="英语原著类">英语原著类</h3><ul><li>Harry Potter and the Order of thePhoenix（把17年剩的半本看完了）</li><li>The Old Man and the Sea</li></ul><p>哦，还有把45卷的《哆啦A梦》漫画作为睡前读物看完了（上一次看哆啦A梦漫画的时候是十几年前名字还叫做机器猫小叮当）。</p><h2 id="运动">运动</h2><p>今年可以算是没怎么运动过吧，一共跑了20次，102.5公里。如果给自己找个借口，就是周围的环境太差，没有跑步的想法。还是承认自己太懒算了。</p><h2 id="电影">电影</h2><p>去电影院看了10部电影，4部国产，6部国外。仍然看了很多连名字也记不起的影视剧。</p><hr /><p>反思2018年，应该是花了太多的时间在网上看各种段子和无聊图吧，导致脑子里装满了各种烂梗，挤占了留给技术的地方╮(╯_╰)╭。</p><p>2019年应该多花点时间在看书上，包括技术书和其他类型的书。</p><p>再见，2018。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到了2018年快要结束的时候，才发现这一年什么也没做啊😂，上一篇博客还是3月份写的。感觉做这个总结就是在提醒自己荒废了一年，虽然不想这么做，但还是来写点什么吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="年度总结" scheme="http://www.wukai.me/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Minimax 和 Alpha-beta 剪枝算法简介，及以此实现的井字棋游戏（Tic-tac-toe）</title>
    <link href="http://www.wukai.me/2018/03/04/minimax-alpha-beta-pruning-and-tic-tac-toe/"/>
    <id>http://www.wukai.me/2018/03/04/minimax-alpha-beta-pruning-and-tic-tac-toe/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间用 React 写了个<ahref="https://github.com/noiron/react-2048">2048游戏</a>来练练手，准备用来回顾下 React相关的各种技术，以及试验一下新技术。在写这个2048的过程中，我考虑是否可以在其中加入一个AI 算法来自动进行游戏，于是我找到了这篇文章：<ahref="http://blog.codinglabs.org/articles/2048-ai-analysis.html">2048-AI程序算法分析</a>，文中介绍了minimax 算法和 alpha-beta剪枝算法。于是我决定先学习下这两种算法，并以此写了这个 tic-tac-toe游戏：<ahref="https://tic-tac-toe-js-app.herokuapp.com/">tic-tac-toe-js</a>（<ahref="https://github.com/noiron/tic-tac-toe-js">代码见此处</a>）。本文将说明如何用JavaScript 来简单地实现算法，并将其运用到 tic-tac-toe 游戏中。</p><span id="more"></span><h2 id="minimax-算法简介">Minimax 算法简介</h2><p>我觉得要解释 minimax算法的原理，需要用示意图来解释更清晰，以下的几篇文章都对原理说的足够清楚。</p><blockquote><ol type="1"><li><ahref="http://blog.codinglabs.org/articles/2048-ai-analysis.html">2048-AI程序算法分析</a></li><li><ahref="https://www.neverstopbuilding.com/blog/2013/12/13/tic-tac-toe-understanding-the-minimax-algorithm13/">TicTac Toe: Understanding the Minimax Algorithm</a></li><li><ahref="http://www.flyingmachinestudios.com/programming/minimax/">AnExhaustive Explanation of Minimax, a Staple AI Algorithm</a></li></ol></blockquote><p>其中后面的两篇文章都是以 tic-tac-toe 游戏为例，并用 Ruby 实现。</p><p>以棋类游戏为例来说明 minimax算法，每一个棋盘的状态都会对应一个分数。双方将会轮流下棋。轮到我方下子时，我会选择分数最高的状态；而对方会选择对我最不利的状态。可以这么认为，每次我都需要从对手给我选择的最差（min）局面中选出最好（max）的一个，这就是这个算法名称<strong>minimax</strong> 的意义。</p><p><img src="/asset/images/2018-03-04-data-tree.png"alt="minimax tree" /> （图片来自于http://web.cs.ucla.edu/~rosen/161/notes/alphabeta.html）</p><p>我们接下来会解决这样一个问题，如上图所示，正方形的节点对应于我的决策，圆形的节点是对手的决策。双方轮流选择一个分支，我的目标是让最后选出的数字尽可能大，对方的目标是让这个数字尽可能小。</p><h2 id="minimax-算法的实现">Minimax 算法的实现</h2><p>为了简单起见，对于这个特定的问题，我用了一个嵌套的数组来表示状态树。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataTree = [</span><br><span class="line">    [</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">3</span>, <span class="number">17</span>], [<span class="number">2</span>, <span class="number">12</span>]</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">15</span>], [<span class="number">25</span>, <span class="number">0</span>]</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">3</span>]</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">2</span>, <span class="number">14</span>]</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>图中的节点分为两种类型：</p><ol type="1"><li><strong>Max节点</strong>：图中的正方形节点，对应于我的回合，它会选取所有子节点中的最大值作为自身的值</li><li><strong>Min节点</strong>：图中的圆形节点，对应于对手的回合，它会选取所有子节点中的最小值作为自身的值</li></ol><p>先定义一个 <code>Node</code> 类，<code>constructor</code> 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">data, type, depth</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">    <span class="built_in">this</span>.type = type; <span class="comment">// 区分此节点的种类是 max 或 min</span></span><br><span class="line">    <span class="built_in">this</span>.depth = depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根节点的 <code>depth</code> 为0，以下的每一层 <code>depth</code>依次加一。最底层的节点 <code>depth</code> 为4，其 <code>data</code>是写在图中的数字，其它层节点的 <code>data</code> 均是一个数组。</p><p>接下来考虑如何给每个节点打分，可能会出现这样的几种情况：</p><ol type="1"><li>最底层的节点，直接返回本身的数字</li><li>中间层的 max 节点，返回子节点中的最大分数</li><li>中间层的 min 节点，返回子节点中的最小分数</li></ol><p>为方便描述，我们按照由上到下、由左到右的顺序给图中节点进行标号。节点1是max节点，从节点2和节点3中选择较大值；而对于节点2来说，需要从节点4，5中选取较小值。很显然，我们这里要用递归的方法来实现，当搜索到最底层的节点时，递归过程开始返回。</p><figure><img src="/asset/images/2018-03-04-data-tree-mark.png"alt="minimax tree mark" /><figcaption aria-hidden="true">minimax tree mark</figcaption></figure><p>以下是打分函数 <code>score</code> 的具体代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">score</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 到达了最大深度后，此时的 data 是数组最内层的数字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.depth &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 max 节点，返回的是子节点中的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.type === <span class="string">&#x27;max&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxScore = -<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> d = <span class="built_in">this</span>.data[i];</span><br><span class="line">            <span class="comment">// 生成新的节点，子节点的 type 会和父节点不同</span></span><br><span class="line">            <span class="keyword">const</span> childNode = <span class="keyword">new</span> Node(d, changeType(<span class="built_in">this</span>.type), <span class="built_in">this</span>.depth + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归获取其分数</span></span><br><span class="line">            <span class="keyword">const</span> childScore = childNode.score();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (childScore &gt; maxScore) &#123;</span><br><span class="line">                maxScore = childScore;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxScore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 min 节点，返回的是子节点中的最小值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.type === <span class="string">&#x27;min&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 与上方代码相似，省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://github.com/noiron/tic-tac-toe-js/blob/master/algorithms/minimax.js">完整的minimax 算法代码</a></p></blockquote><h2 id="alpha-beta-剪枝算法简介">Alpha-beta 剪枝算法简介</h2><p>Alpha-beta 剪枝算法可以认为是 minimax算法的一种改进，在实际的问题中，需要搜索的状态数量将会非常庞大，利用alpha-beta 剪枝算法可以去除一些不必要的搜索。</p><p>关于 alpha-beta 算法的具体解释可以看这篇文章 <ahref="http://web.cs.ucla.edu/~rosen/161/notes/alphabeta.html">Minimaxwith Alpha BetaPruning</a>。我们在前文中考虑的那张图就来自这篇文章，之后我们会用alpha-beta 剪枝算法来改进之前的解决方案。</p><p>剪枝算法中主要有这么些概念：</p><p>每一个节点都会由 alpha 和 beta 两个值来确定一个范围 [alpha,beta]，alpha 值代表的是下界，beta代表的是上界。每搜索一个子节点，都会按规则对范围进行修正。</p><p>Max 节点可以修改 alpha 值，min 节点修改 beta 值。</p><p>如果出现了 beta &lt;= alpha的情况，则不用搜索更多的子树了，未搜索的这部分子树将被忽略，这个操作就被称作<strong>剪枝（pruning）</strong>。</p><p>接下来我会尽量说明为什么剪枝这个操作是合理的，省略了一部分节点为什么不会对结果产生影响。用原图中以4号节点（第三层的第一个节点）为根节点的子树来举例，方便描述这里将他们用A - G 的字母来重新标记。</p><figure><img src="/asset/images/2018-03-04-subtree.png" alt="子树" /><figcaption aria-hidden="true">子树</figcaption></figure><p>从 B 节点看起，B 是 min 节点，需要在 D 和 E 中寻找较小值，因此 B取值为3，同时 B 的 beta 值也设置为 3。假设 B还有更多值大于3的子节点，但因为已经出现了 D 这个最小值，所以不会对 B产生影响，即这里的 beta = 3 确定了一个上界。</p><p>A 是 max 节点，需要在 B 和 C 中找到较大值，因为子树 B 已经搜索完毕，B的值确定为 3，所以 A 的值至少为 3，这样确定了 A 的下界 alpha = 3。在搜索C 子树之前，我们<strong>希望 C 的值大于3</strong>，这样才会对 A 的下界alpha 产生影响。于是 C 从 A 这里获得了下界 alpha = 3 这个限制条件。</p><p>C 是 min 节点，要从 F 和 G 里找出较小值。F 的值为2，所以 C的值一定小于等于 2，更新 C 的上界 beta = 2。此时 C 的 alpha = 3, beta =2，这是一个空区间，也就是说即使继续考虑 C 的其它子节点，也<strong>不可能让 C 的值大于 3</strong>，所以我们不必再考虑 G 节点。G节点就是被剪枝的节点。</p><p>重复这样的过程，会有更多的节点因为剪枝操作被忽略，从而对 minimax算法进行了优化。</p><h2 id="alpha-beta-剪枝算法的实现">Alpha-beta 剪枝算法的实现</h2><p>接下来讨论如何修改前面实现的 minimax 算法，使其变为 alpha-beta剪枝算法。</p><p>第一步在 constructor 中加入两个新属性，alpha、beta。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">data, type, depth, alpha, beta</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">    <span class="built_in">this</span>.type = type; <span class="comment">// 区分此节点的种类是 max 或 min</span></span><br><span class="line">    <span class="built_in">this</span>.depth = depth;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.alpha = alpha || -<span class="literal">Infinity</span>;</span><br><span class="line">    <span class="built_in">this</span>.beta = beta || <span class="literal">Infinity</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后每次都搜索会视情况更新 alpha, beta 的值，以下的代码片段来自于搜索max 节点的过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alphabeta.js 中的 score() 函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.data.length; i++) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childScore &gt; maxScore) &#123;</span><br><span class="line">        maxScore = childScore;</span><br><span class="line">        <span class="comment">// 相对于 minimax 算法，alpha-beta 剪枝算法在这里增加了一个更新 alpha 值的操作</span></span><br><span class="line">        <span class="built_in">this</span>.alpha = maxScore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果满足了退出的条件，我们不需要继续搜索更多的节点了，退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.alpha &gt;= <span class="built_in">this</span>.beta) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>相对应的是在 min 节点中，我们更新的将是 beta值。好了，只需要做这么些简单的改变，就将 minimax 算法改变成了 alpha-beta剪枝算法了。</p><p>最后看看如何将算法应用到 tic-tac-toe 游戏中。</p><blockquote><p><ahref="https://github.com/noiron/tic-tac-toe-js/blob/master/algorithms/alphabeta.js">完整的alpha-beta 剪枝算法代码</a></p></blockquote><h2 id="tic-tac-toe-游戏中的应用">Tic-tac-toe 游戏中的应用</h2><p>Tic-tac-toe，即井字棋游戏，规则是在双方轮流在 3x3的棋盘上的任意位置下子，率先将三子连成一线的一方获胜。</p><p>这就是一个非常适合用 minimax来解决的问题，即使在不考虑对称的情况，所有的游戏状态也只有 9! = 362880种，相比于其它棋类游戏天文数字般的状态数量已经很少了，因而很适合作为算法的示例。</p><p>我在代码中将棋盘的状态用一个长度为9的数组来表示，然后利用 canvas绘制出一个简易的棋盘，下子的过程就是修改数组的对应位置然后重绘画面。</p><p>现在我们已经有了现成的 minimax 和 alpha-beta剪枝算法，只要加上一点儿细节就能完成这个游戏了😀。</p><p>先来定义一个 <code>GameState</code>类，其中保存了游戏的状态，对应于之前分析过程中的节点，其<code>constructor</code> 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">board, player, depth, alpha, beta</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.board = board;</span><br><span class="line">    <span class="comment">// player 是用字符 X 和 O 来标记当前由谁下子，以此来判断当前是 max 还是 min 节点</span></span><br><span class="line">    <span class="built_in">this</span>.playerTurn = player;</span><br><span class="line">    <span class="built_in">this</span>.depth = depth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存分数最高或最低的状态，用于确定下一步的棋盘状态</span></span><br><span class="line">    <span class="built_in">this</span>.choosenState = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.alpha = alpha || -<span class="literal">Infinity</span>;</span><br><span class="line">    <span class="built_in">this</span>.beta = beta || <span class="literal">Infinity</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为进行游戏，首先需要一个 <code>checkFinish</code>函数，检查游戏是否结束，结束时返回胜利者信息。搜索的过程是在<code>getScore</code>函数中完成的，每次搜索先检查游戏是否结束，平局返回零分，我们的算法是站在AI 的角度来考虑的，因此 AI 胜利时返回10分，AI 失利时返回-10分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alphabeta.js 中的 getScore() 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winner = <span class="built_in">this</span>.checkFinish();</span><br><span class="line"><span class="keyword">if</span> (winner) &#123;</span><br><span class="line">    <span class="keyword">if</span> (winner === <span class="string">&#x27;draw&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (winner === aiToken) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是对 max 和 min 节点的分类处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alphabeta.js 中的 getScore() 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得所有可能的位置，利用 shuffle 加入随机性</span></span><br><span class="line"><span class="keyword">const</span> availablePos = _.shuffle(<span class="built_in">this</span>.getAvailablePos());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 max 节点，返回的是子节点中的最大值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.playerTurn === aiToken) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxScore = -<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">let</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; availablePos.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> pos = availablePos[i];</span><br><span class="line">        <span class="comment">// 在给定的位置下子，生成一个新的棋盘</span></span><br><span class="line">        <span class="keyword">const</span> newBoard = <span class="built_in">this</span>.generateNewBoard(pos, <span class="built_in">this</span>.playerTurn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个新的节点</span></span><br><span class="line">        <span class="keyword">const</span> childState = <span class="keyword">new</span> GameState(newBoard, changeTurn(<span class="built_in">this</span>.playerTurn), <span class="built_in">this</span>.depth + <span class="number">1</span>, <span class="built_in">this</span>.alpha, <span class="built_in">this</span>.beta);</span><br><span class="line">        <span class="comment">// 这里开始递归调用 getScore() 函数</span></span><br><span class="line">        <span class="keyword">const</span> childScore = childState.getScore();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (childScore &gt; maxScore) &#123;</span><br><span class="line">            maxScore = childScore;</span><br><span class="line">            maxIndex = i;</span><br><span class="line">            <span class="comment">// 这里保存产生了最大的分数的节点，之后会被用于进行下一步</span></span><br><span class="line">            <span class="built_in">this</span>.choosenState = childState;</span><br><span class="line">            <span class="built_in">this</span>.alpha = maxScore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.alpha &gt;= <span class="built_in">this</span>.beta) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxScore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// min 节点的处理与上面类似</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>完整代码见<ahref="https://github.com/noiron/tic-tac-toe-js/blob/master/src/alphabeta.js">alphabeta.js</a></p><h2 id="总结">总结</h2><p>这样就简单地介绍了 minimax 算法和 alpha-beta算法，并分别给出了一个简单的实现，然后在 tic-tac-toe游戏中应用了算法。</p><p>文章中所提到的所有代码可见此项目：<ahref="https://github.com/noiron/tic-tac-toe-js">Tic-tac-toe-js</a>。其中的<code>algorithms</code> 文件夹中是两种算法的简单实现，<code>src</code>文件中是游戏的代码。</p><p>文章开头说到了这篇文章起源于写2048游戏项目的过程中，之后我将 minimax算法应用到了2048游戏的 AI 中，不过对于局面的评估函数尚不完善，现在 AI只能勉强合成1024😢， 还有很大的改进空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间用 React 写了个&lt;a
href=&quot;https://github.com/noiron/react-2048&quot;&gt;2048
游戏&lt;/a&gt;来练练手，准备用来回顾下 React
相关的各种技术，以及试验一下新技术。在写这个2048的过程中，我考虑是否可以在其中加入一个
AI 算法来自动进行游戏，于是我找到了这篇文章：&lt;a
href=&quot;http://blog.codinglabs.org/articles/2048-ai-analysis.html&quot;&gt;2048-AI程序算法分析&lt;/a&gt;，文中介绍了
minimax 算法和 alpha-beta
剪枝算法。于是我决定先学习下这两种算法，并以此写了这个 tic-tac-toe
游戏：&lt;a
href=&quot;https://tic-tac-toe-js-app.herokuapp.com/&quot;&gt;tic-tac-toe-js&lt;/a&gt;（&lt;a
href=&quot;https://github.com/noiron/tic-tac-toe-js&quot;&gt;代码见此处&lt;/a&gt;）。本文将说明如何用
JavaScript 来简单地实现算法，并将其运用到 tic-tac-toe 游戏中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="minimax" scheme="http://www.wukai.me/tags/minimax/"/>
    
      <category term="alpha-beta pruning" scheme="http://www.wukai.me/tags/alpha-beta-pruning/"/>
    
      <category term="游戏" scheme="http://www.wukai.me/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="算法" scheme="http://www.wukai.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2017年总结</title>
    <link href="http://www.wukai.me/2018/01/01/2017-annual-summary/"/>
    <id>http://www.wukai.me/2018/01/01/2017-annual-summary/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>活了二十多年，从来没有做过年终总结，但年岁渐长，总觉得有点时间的压力，应该记录点什么，就让2017年的总结作为第一次。</p><span id="more"></span><h2 id="技术">技术</h2><p>技术方面，继续写了一年的 React，还试着用了下Vue，学了许多前端库，但是却没有什么完整的项目。</p><p>写了一个塔防游戏，待改的 Bug 比待实现的 feature 多，等着 2018继续完善。</p><p>在 Coursera 上听了算法课，最后一周的作业没交，所以课程也没完成。</p><p>非前端的技术方面，看了本《C程序设计语言》，《深入理解计算机系统》只看到第二章，《Algorithms》也依旧没看完。重新开始学习线性代数了。</p><p>前端的书也没看多少，大多数情况下都在网上看资料。记得的书只有《你不知道的JavaScript（上）》和《深入理解 ES6》。</p><p>总的来说，技术水平比起2016年有一点长进，但是也没有什么量化的指标，只是JavaScript写的更熟练了。唯一有所记录的是2017年在这里写了7篇博客，无论质量如何，聊胜于无。</p><h2 id="阅读">阅读</h2><p>读书方面，因为从来不会去数自己读了多少本。只能去翻翻订单记录和在豆瓣上的标记，除去技术类的书籍外，看了以下书籍：-科幻书籍：《盲视》《让时间停止的女孩》《基地系列七部曲》（补上了后面几本）-三本村上春树：《没有色彩的多崎作和他的巡礼之年》《奇鸟形状录》《东京奇谭集》- 三本伊坂幸太郎：《摩登时代》《魔王》《死神的精确度》 -古龙的《小李飞刀：多情剑客无情剑》和《欢乐英雄》 - 苏童的《武则天》 -莫言的《檀香刑》 - 马尔克斯的《一桩事先张扬的凶杀案》 -燕垒生的《天行健》全集 - 罗斯·特里尔的《毛泽东传》 - 杨绛的《我们仨》 -《亮剑》 - 《阿城精选集》 - 《易中天中华史》部分大概就这些书了吧，还有一本哲学书《大问题》尚未翻完。</p><p>想看英语原版书来着，不过还没找到什么感兴趣的，于是又去看哈利波特了：- Holes - Hyperion （半本） - Harry Potter and the Sorcerer's Stone -Harry Potter and the Chamber of Secrets - Harry Potter and the Prisonerof Azkaban - Harry Potter and the Goblet of Fire （目前为止看了46%）</p><h2 id="电影">电影</h2><p>17年去电影院看了12部电影，以《降临》为始，以《妖猫传》为终，其它电影不提也罢。至于各种乱七八糟的美剧、英剧、日剧，看了就忘，没有记录。</p><h2 id="锻炼">锻炼</h2><p>17年每次跑步几乎都用悦跑圈做了记录，总的次数是43次，一共377公里，差不多一天一公里。</p><h2 id="其它的技能">其它的技能</h2><p>上半年买了日语的教材，又一次停在了五十音图。</p><p>下半年买了把吉他，还在练习中，也许应该快要入门了吧。</p><hr /><p>2017年大概就做了这些事吧。最后，新的一年已经来了，依旧是单身狗，没有变秃，也没有变强。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;活了二十多年，从来没有做过年终总结，但年岁渐长，总觉得有点时间的压力，应该记录点什么，就让2017年的总结作为第一次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="年度总结" scheme="http://www.wukai.me/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>不到200行 JavaScript 代码如何实现富文本编辑器</title>
    <link href="http://www.wukai.me/2017/12/31/rich-text-editor-in-less-than-200-lines-javascript/"/>
    <id>http://www.wukai.me/2017/12/31/rich-text-editor-in-less-than-200-lines-javascript/</id>
    <published>2017-12-30T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.546Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在寻找一些关于富文本编辑器的资料，然后发现了这个名为 <ahref="https://github.com/jaredreich/pell">Pell</a>的项目，它是一个所见即所得（WYSIWYG）的文本编辑器，虽然它的功能很简单，但是令人吃惊的是它只有1kb 大小。而项目最核心的文件 <ahref="https://github.com/jaredreich/pell/blob/master/src/pell.js">pell.js</a>只有130行，即使加上其它部分，总的 js数量也不到200行。这引起了我的兴趣，决定看看它的源码是如何做到这一点的。</p><span id="more"></span><p>项目的主要代码在 <code>pell.js</code>文件中，其结构很简单，主要功能的实现依赖于以下的几个部分</p><ul><li><code>actions</code> 对象</li><li><code>exec()</code> 函数</li><li><code>init()</code> 函数</li></ul><h2 id="document.execcommand">Document.execCommand()</h2><p>先从最简单的部分看起， <code>exec()</code> 函数只有下面三行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> exec = <span class="function">(<span class="params">command, value = <span class="literal">null</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.execCommand(command, <span class="literal">false</span>, value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它将 <code>document.execCommand()</code> 进行了一个简单的包装，<ahref="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand">Document.execCommand()</a>就是这个编辑器的核心，其语法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool = <span class="built_in">document</span>.execCommand(aCommandName, aShowDefaultUI, aValueArgument)</span><br></pre></td></tr></table></figure><ul><li><code>aCommandName</code> 是表示想执行的命令的字符串，比如：加粗'bold'，创建链接 'createLink'，改变字体大小 'fontSize' 等等</li><li><code>aShowDefaultUI</code> 是否显示默认的用户界面</li><li><code>aValueArgument</code>有些命令需要额外的输入，如插入图片、链接时需要给出地址</li></ul><p>注：经过我的试验，在 Chrome 下改变 aShowDefaultUI的值并未发现影响，<ahref="https://stackoverflow.com/questions/38188015/what-is-the-the-default-user-interface-referred-to-by-the-ashowdefaultui-param">这个stackoverflow 的问题</a>中提到这是一个来自于旧版 IE的参数，所以这里设置为默认的 false 即可。</p><h2 id="actions-对象">actions 对象</h2><p>文件中定义了一个名为 <code>actions</code>的对象，对应的是下图工具栏上的这一行按钮， <code>actions</code>中的每个子对象都保存了一个按钮的属性。</p><figure><img src="/asset/images/2017-12-29-pell-editor-toobar.png"alt="2017-12-29-pell-editor-toobar.png" /><figcaptionaria-hidden="true">2017-12-29-pell-editor-toobar.png</figcaption></figure><p>部分代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="attr">bold</span>: &#123;</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;&lt;b&gt;B&lt;/b&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Bold&#x27;</span>,</span><br><span class="line">        <span class="attr">result</span>: <span class="function">() =&gt;</span> exec(<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">italic</span>: &#123;</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;&lt;i&gt;I&lt;/i&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Italic&#x27;</span>,</span><br><span class="line">        <span class="attr">result</span>: <span class="function">() =&gt;</span> exec(<span class="string">&#x27;italic&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">underline</span>: &#123;</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;&lt;u&gt;U&lt;/u&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Underline&#x27;</span>,</span><br><span class="line">        <span class="attr">result</span>: <span class="function">() =&gt;</span> exec(<span class="string">&#x27;underline&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中显示了名为<code>bold</code>，<code>italic</code>，<code>underline</code>的三个对象属性，对应于工具栏中前方的<strong>加粗</strong>、<em>斜体</em>、下划线按钮，可以看出它们的结构是相同的，都有下列三个属性：</p><ul><li><code>icon</code>: 如何在工具栏中显示</li><li><code>title</code>: 就是 title 啦</li><li><code>result</code>:一个函数，会赋给按钮作为点击事件，调用之前所提到的 <code>exec()</code>函数来对文本进行操作</li></ul><p>现在已有了 <code>actions</code> 对象，那么如何使用它呢？这就要看看<code>init()</code> 函数了，它会根据一定的规则从 <code>actions</code>对象中选出元素组成一个数组，数组的每一项都会生成一个按钮。下面代码中的<code>settings.actions</code>即为此数组，其中的每个元素都对应一个显示在工具栏上的按钮。<code>settings.actions</code>的生成规则会在后面进行解释。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pell.js 中的 init() 函数</span></span><br><span class="line">settings.actions.forEach(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 新建一个按钮元素</span></span><br><span class="line">    <span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">    <span class="comment">// 给按钮加上 css 样式</span></span><br><span class="line">    button.className = settings.classes.button</span><br><span class="line">    <span class="comment">// 把 icon 属性作为内容显示出来</span></span><br><span class="line">    button.innerHTML = action.icon</span><br><span class="line">    button.title = action.title</span><br><span class="line">    <span class="comment">// 把 result 属性赋给按钮作为点击事件</span></span><br><span class="line">    button.onclick = action.result</span><br><span class="line">    <span class="comment">// 将创建的按钮添加到工具栏上</span></span><br><span class="line">    actionbar.appendChild(button)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样数组中的每个元素就都生成了一个工具栏上的按钮了。</p><h2 id="init-初始化函数">init() 初始化函数</h2><p>想使用 pell 编辑器时，只要调用 <code>init()</code>函数来初始化一个编辑器即可。它接收一个 <code>setting</code>对象作为参数，其中包含这样的一些属性：</p><ul><li><code>element</code>: 编辑器的 DOM 元素</li><li><code>styleWithCSS</code>: 设置为 true 时，将会用<code>&lt;span style="font-weight: bold;"&gt;&lt;/span&gt;</code> 代替<code>&lt;b&gt;&lt;/b&gt;</code></li><li><code>actions</code></li><li><code>onChange</code></li></ul><p>其中最重要的是<code>actions</code>，它是一个数组，包含了你想在工具栏显示的按钮列表。</p><p><code>actions</code> 数组中可以有这几种元素： - 一个字符串 - 一个有<code>name</code> 属性的对象 - 一个对象，没有 <code>name</code>属性，但有生成一个按钮的必需属性 <code>icon</code>，<code>result</code>等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">actions: [</span><br><span class="line">  <span class="string">&#x27;bold&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;underline&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;italic&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">    <span class="attr">result</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> url = <span class="built_in">window</span>.prompt(<span class="string">&#x27;Enter the image URL&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (url) <span class="built_in">window</span>.pell.exec(<span class="string">&#x27;insertImage&#x27;</span>, ensureHTTP(url))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在 <code>init()</code> 函数中会把这个 <code>actions</code>参数 和pell.js 中定义的 <code>actions</code>对象组合起来，可以将<code>actions</code> 对象当作一个默认设置，看以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pell.js 中的 init() 函数</span></span><br><span class="line">settings.actions = settings.actions</span><br><span class="line">    ? settings.actions.map(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> actions[action]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果参数中传入的 action 已经在默认设置中存在，用传入的参数覆盖默认设置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (actions[action.name]) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; ...actions[action.name], ...action &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    &#125;)</span><br><span class="line">    : <span class="built_in">Object</span>.keys(actions).map(<span class="function"><span class="params">action</span> =&gt;</span> actions[action])</span><br></pre></td></tr></table></figure><p>如果参数对象 <code>setting</code> 中不包含 <code>actions</code> 数组,则会默认使用之前定义的 <code>actions</code> 对象来初始化。</p><p>init()函数里还有一个重要的部分，就是创建一个可编辑区域，这里创建了一个<code>div</code> 元素，将其 <code>contentEditable</code> 属性设为<code>true</code>，从而可以在这里使用之前提到的<code>document.execCommand()</code> 命令了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建编辑区域的元素</span></span><br><span class="line">settings.element.content = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="comment">// 让 div 成为可编辑状态</span></span><br><span class="line">settings.element.content.contentEditable = <span class="literal">true</span></span><br><span class="line">settings.element.content.className = settings.classes.content</span><br><span class="line"><span class="comment">// 当用户输入时，更新页面的相应部分</span></span><br><span class="line">settings.element.content.oninput = <span class="function"><span class="params">event</span> =&gt;</span> </span><br><span class="line">    settings.onChange(event.target.innerHTML)</span><br><span class="line">settings.element.content.onkeydown = preventTab</span><br><span class="line">settings.element.appendChild(settings.element.content)</span><br></pre></td></tr></table></figure><h2 id="流程整理">流程整理</h2><p>最后以“插入链接”为例来梳理下整个编辑器的流程：</p><p>一、在调用 <code>init()</code> 函数时，在参数对象的<code>action</code> 数组中加入以下一项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;link&#x27;</span>,</span><br><span class="line">    <span class="attr">result</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="built_in">window</span>.prompt(<span class="string">&#x27;Enter the link URL&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (url) <span class="built_in">window</span>.pell.exec(<span class="string">&#x27;createLink&#x27;</span>, ensureHTTP(url))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、在 <code>init()</code> 的运行过程中，会检查已定义的<code>actions</code> 对象中是否有 <code>link</code>这个属性。经检查属性确实存在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">link: &#123;</span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;&amp;#128279;&#x27;</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;Link&#x27;</span>,</span><br><span class="line">    <span class="attr">result</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="built_in">window</span>.prompt(<span class="string">&#x27;Enter the link URL&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (url) exec(<span class="string">&#x27;createLink&#x27;</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为传入的参数中有 <code>result</code> 这一项，所以用传入的<code>result</code> 来代替 <code>link</code>对象中的默认值，然后将修改过的 <code>link</code> 对象放入<code>settings.actions</code> 数组中。</p><p>三、对 <code>settings.actions</code>数组进行一次迭代来生成工具栏，<code>link</code>对象作为其中的一项生成了一个“插入链接”的按钮。<code>result</code>属性成为其点击事件。</p><p>四、点击“插入链接”的按钮后，会让你输入一个 url，然后调用<code>exec('createLink', url)</code> 在编辑区域插入该链接。</p><p>编辑器其它按钮的功能流程也类似。</p><p>这样 Pell编辑器的大部分内容就讲解完毕了，剩余部分还需要自己去看源码。毕竟项目的代码不长，以此作为文本编辑器的入门倒不错。</p><hr /><p>2017年的最后一篇文章了，再见，2017。</p><p><ahref="http://www.wukai.me/2017/12/31/rich-text-editor-in-less-than-200-lines-javascript/">本文原地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间在寻找一些关于富文本编辑器的资料，然后发现了这个名为 &lt;a
href=&quot;https://github.com/jaredreich/pell&quot;&gt;Pell&lt;/a&gt;
的项目，它是一个所见即所得（WYSIWYG）的文本编辑器，虽然它的功能很简单，但是令人吃惊的是它只有
1kb 大小。而项目最核心的文件 &lt;a
href=&quot;https://github.com/jaredreich/pell/blob/master/src/pell.js&quot;&gt;pell.js&lt;/a&gt;
只有130行，即使加上其它部分，总的 js
数量也不到200行。这引起了我的兴趣，决定看看它的源码是如何做到这一点的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="编辑器" scheme="http://www.wukai.me/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>用 JavaScript 画光：基础</title>
    <link href="http://www.wukai.me/2017/12/10/light-2d-javascript/"/>
    <id>http://www.wukai.me/2017/12/10/light-2d-javascript/</id>
    <published>2017-12-09T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Any application that <strong>can</strong> be written in JavaScript,<strong>will</strong> eventually be written in JavaScript. -- Atwood'sLaw</p></blockquote><p>本文来源于我在看了 Milo Yip 在知乎专栏里的这篇文章：<ahref="https://zhuanlan.zhihu.com/p/30745861">《用 C语言画光（一）：基础》</a>之后的一个想法，能不能将原文中 C语言版本程序改成 JavaScript版本的。动手之后发现出乎意料的顺利，我只需要把 C语言中变量的类型通通去掉就可以了😀，Amazing！</p><span id="more"></span><p>最终结果可见此CodePen：https://codepen.io/noiron/pen/aVgYMB?editors=1010</p><p data-height="400" data-theme-id="0" data-slug-hash="aVgYMB" data-default-tab="result" data-user="noiron" data-embed-version="2" data-pen-title="aVgYMB" class="codepen">See the Pen <a href="https://codepen.io/noiron/pen/aVgYMB/">aVgYMB</a>by wu kai (<a href="https://codepen.io/noiron"><span class="citation"data-cites="noiron">@noiron</span></a>) on<a href="https://codepen.io">CodePen</a>.</p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>在本文中，我主要解释一下 JavaScript如何将图像输出，以及我对这个画光程序的一点理解。更多有关图形学原理部分的内容，建议还是看Milo Yip 的原文。</p><h2 id="如何输出图像">如何输出图像</h2><p>Milo Yip 在他的系列文章中使用了一个自己写的 <ahref="https://zhuanlan.zhihu.com/p/26525083">svpng()</a>函数，能够根据得到的图形数据生成 <code>png</code> 格式的图片。而使用JavaScript 可以方便地在 <code>canvas</code> 元素上绘制出图形。</p><p>为了能够记录下图片的信息，需要记录每一个像素点的 <code>RGB</code>值，对于一张宽度为 W，高度为 H 的图片，其像素点数量为<code>W * H</code>，而每个像素点分别用三个数来表示其 R、G、B值，所以记录下整张图片的数据，需要一个长度为 <code>W * H * 3</code>的数组。如果图片带有 alpha 通道，需要记录 <code>RGBA</code>值，则数组长度为<code>W * H * 4</code>。这里有一个可以简化的地方，因为绘制的是一张黑白的图片，对于黑/白/灰色来说R = G = B，所以用长度 <code>W * H</code> 的数组即可。</p><p>假设我们现在已经有了一个记录图片信息的数组<code>p</code>，那么如何将其显示出来？这里需要用到<code>getImageData</code>, <code>putImageData</code> 方法。</p><p>可以利用 <code>getImageData()</code> 方法来获得 ImageData对象，从中得到图像的像素点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取 ImageData 对象</span></span><br><span class="line"><span class="keyword">const</span> imageData = ctx.getImageData(x, y, width, height)</span><br></pre></td></tr></table></figure><p><code>ImageData</code> 对象的 <code>data</code>属性是一个数组，包含有每个像素点的 <code>RGBA</code>，其总长度为<code>W * H * 4</code>。所以我们将记录图片信息的数组 <code>p</code>中的值依序赋给 <code>data</code>，再利用 <code>putImageData</code>方法即可将图片绘制到 canvas 上了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processImageData</span>(<span class="params">imageData, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = imageData.data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = p[i / <span class="number">4</span>];</span><br><span class="line">        data[i] = value;</span><br><span class="line">        data[i + <span class="number">1</span>] = value;</span><br><span class="line">        data[i + <span class="number">2</span>] = value;</span><br><span class="line">        data[i + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData(imageData, p);</span><br><span class="line">ctx.putImageData(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="如何获得一个点的光照强度">如何获得一个点的光照强度</h2><p>现在我们考虑的是单色光，RGB 中的三个值是相等的，当光照越强时，RGB值越大，图像的颜色也越白。</p><p>坐标为 (x, y)的一个点，它获得的光来自于各个方向上的光的叠加，即是一个对角度的积分：</p><p><span class="math display">\[F\left( x,y\right) =\int ^{2\pi}_{0}L\left( x,y,\theta \right) d\theta\]</span></p><p>其中 <span class="math inline">\(L\left( x,y,\theta \right)\)</span>代表在二维坐标 (x, y) 在 <span class="math inline">\(\theta\)</span>方向有多少光经过。</p><p>由于无法直接计算出这个积分的值，需要用<strong>蒙特卡罗积分法</strong>来进行采样。利用N 个方向的采样平均值作为这一点的光强。</p><p>那么 (x, y) 点在 <span class="math inline">\(\theta\)</span>方向上能获得多少光照？我们现在只有一个处于画面中央的圆形光源，可考虑从(x, y) 为起点的一条线段，如果它足够长，那只有两种可能性：</p><ul><li>终结于光源的表面，则 (x, y) 点在 <spanclass="math inline">\(\theta\)</span> 方向能获得光照</li><li>与光源无交点，则此方向上无光照</li></ul><p>但我们需要对这条线段的长度加以限制，所以逐步加长线段的长度，如果线段终点在光源的表面或内部，则获得光照。当步数达到<code>MAX_STEP</code> 或距离达到<code>MAX_DISTANCE</code>，停止计算，在此方向上获得的光照为0。</p><p>这里需要利用<strong>带符号距离场（signed distance field,SDF）</strong>来表示出当前的点与场景的最近距离，每次步进此距离能保证不会进入光源的内部。如下图中，每个圆的半径均为圆心和图中形状的最近距离，则按P0 -&gt; P1 -&gt; P2 -&gt; ...的顺序前进能保证不会和图中的形状相交。</p><p><img src="/asset/images/2017-12-10-sphere-tracing.jpg"alt="sphere-tracing" />（图源：https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter08.html）</p><p>此即原文中提到的<strong>光线步进（raymarching）</strong>方法（又称为<strong>球体追踪／spheretracing</strong>）。</p><h2 id="javascript-的实现">JavaScript 的实现</h2><p>利用 <code>sample()</code> 函数计算并保存所有坐标点的光照：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>, i = <span class="number">0</span>; y &lt; HEIGHT; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; WIDTH; x++) &#123;</span><br><span class="line">        <span class="comment">// x / W, y / H 其值被限制在 [0, 1] 之间</span></span><br><span class="line">        p[i++] = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.min(sample(x / WIDTH, y / HEIGHT) * <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用蒙特卡罗积分法进行 N 次采样取平均值获得 (x, y)处的光照强度，其中的 <code>trace()</code> 函数代表的是从 <spanclass="math inline">\(\theta\)</span> 方向获取的光强。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sample</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">// 以下为三种不同的采样方式</span></span><br><span class="line">        <span class="comment">// const theta = Math.PI * 2 * Math.random();           // 随机采样</span></span><br><span class="line">        <span class="comment">// const theta = Math.PI * 2 * i / N;                   // 分层采样（stratified sampling）</span></span><br><span class="line">        <span class="keyword">const</span> theta = <span class="built_in">Math</span>.PI * <span class="number">2</span> * (i + <span class="built_in">Math</span>.random()) / N;    <span class="comment">// 抖动采样（jittered sampling）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// trace() 所返回的值是点 (x, y) 从 theta 方向获取的光</span></span><br><span class="line">        sum += trace(x, y, <span class="built_in">Math</span>.cos(theta), <span class="built_in">Math</span>.sin(theta));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>circleSDF</code> 为带符号距离场（signed distance field,SDF），值为负时，表示在光源的内部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">circleSDF</span>(<span class="params">x, y, cx, cy, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ux = x - cx;</span><br><span class="line">    <span class="keyword">const</span> uy = y - cy;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(ux * ux + uy * uy) - r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是 <code>trace()</code>方法，用<strong>光线步进</strong>来计算出 (ox, oy) 沿单位向量 (dx, dy)方向上获得的光照。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>(<span class="params">ox, oy, dx, dy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> MAX_STEP = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> MAX_DISTANCE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> EPSILON = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0.0</span>;    <span class="comment">// t 为步进的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; MAX_STEP &amp;&amp; t &lt; MAX_DISTANCE; i++) &#123;</span><br><span class="line">        <span class="comment">// 光源中心为 (sourceX, sourceY) </span></span><br><span class="line">        <span class="comment">// 沿单位向量 (dx, dy) 方向前进，t 表示前进的距离</span></span><br><span class="line">        <span class="keyword">const</span> sd = circleSDF(ox + dx * t, oy + dy * t, sourceX, sourceY, <span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时已到达发光的圆形表面</span></span><br><span class="line">        <span class="keyword">if</span> (sd &lt; EPSILON) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续增加步进的距离</span></span><br><span class="line">        t += sd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我还在代码添加了一个点击事件，可以改变光源位置来查看不同的效果。</p><h2 id="参考资料">参考资料</h2><p><a href="https://github.com/YIXUNFE/blog/issues/12">Canvas操作图像像素</a></p><hr /><p>[<strong>2018-01-01 更新</strong>] 在 GitHub上建立了一个项目，准备将《用C语言画光》系列文章中的代码都移植到JavaScipt 中来。 项目地址：<ahref="https://github.com/noiron/light2d-javascript">light2d-javascript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Any application that &lt;strong&gt;can&lt;/strong&gt; be written in JavaScript,
&lt;strong&gt;will&lt;/strong&gt; eventually be written in JavaScript. -- Atwood&#39;s
Law&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文来源于我在看了 Milo Yip 在知乎专栏里的这篇文章：&lt;a
href=&quot;https://zhuanlan.zhihu.com/p/30745861&quot;&gt;《用 C
语言画光（一）：基础》&lt;/a&gt;之后的一个想法，能不能将原文中 C
语言版本程序改成 JavaScript
版本的。动手之后发现出乎意料的顺利，我只需要把 C
语言中变量的类型通通去掉就可以了😀，Amazing！&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="计算机图形学" scheme="http://www.wukai.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>塔防游戏中的敌人如何沿路径前进 (JavaScript 实现)</title>
    <link href="http://www.wukai.me/2017/12/09/boid-path-following/"/>
    <id>http://www.wukai.me/2017/12/09/boid-path-following/</id>
    <published>2017-12-08T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<p>如果开发一个塔防游戏，很自然的会遇上这么两个名字很像的问题：</p><ul><li><strong>Path-finding</strong>:如果知道起点和终点，如何在其间找到一条路径</li><li><strong>Path-following</strong>:已知从起点到终点的路径，物体如何才能沿着它行进</li></ul><p>本文将要讨论的是第二个问题 <strong>pathfollowing</strong>，给定一条路径，看物体如何沿着它从起点运行至终点。为了方便描述，接下来的内容中，用单词<a href="https://en.wikipedia.org/wiki/Boids">Boid</a>来表示行进的物体或塔防中的敌人。</p><p>接下来会用一种简单的方法来解决这一问题，最终完成的代码库可见 GitHub:<ahref="https://github.com/noiron/boid-path-following">boid-path-following</a>，repo的多个分支对应了文中的不同步骤。</p><span id="more"></span><h2 id="准备工作">准备工作</h2><p>先来看看如何标识出画面中的位置，首先画面被一系列的横纵线分成了许多网格，对于地图范围内的一个点，它会有自己的像素坐标(x, y)，同时它所处的格子也有自己的坐标 (col, row) 或 (xIndex,yIndex)，表示所处的列和行。</p><p><img src="/asset/images/2017-12-09-path-following-map.png" /></p><p>为了区分，下文中提到<strong>像素坐标</strong>即为用像素表示的坐标，<strong>网格坐标</strong>表示点在网格中的列和行。</p><p>在这种表示方法下，还需要一个工具函数<code>index2Px(col, row)</code>，用于计算格子中心的像素坐标。</p><p>接下来给出路径的坐标，路径是如下的一个二维数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = [[<span class="number">0</span>, <span class="number">1</span>], [COLS - <span class="number">4</span>, <span class="number">1</span>], [COLS - <span class="number">4</span>, <span class="number">4</span>], [<span class="number">6</span>, <span class="number">4</span>], [<span class="number">6</span>, <span class="number">7</span>], <span class="comment">/* 部分省略 */</span>]</span><br></pre></td></tr></table></figure><p>每一项都是路径上一个点的网格坐标，将这些点用直线连接起来后就得到了boid 行进的路径。我们的目标就是要让 boid能够从路径第一个坐标移动至最后一个坐标。</p><h2 id="boid-如何沿直线前进">Boid 如何沿直线前进</h2><p>先考虑最简单的问题，如何让 Boid 沿着一条直线行进。</p><p>物体的移动需要位置和速度，为了表示其像素坐标，<code>boid</code> 需要<code>x</code>, <code>y</code> 属性；其速度需要 <code>speed</code>属性，同时还需要一个<code>angle</code>，以便计算出速度在两个方向上的分量 <code>vx</code>,<code>vy</code>。</p><p>动画效果的实现需要用 <code>requestAnimationFrame</code>函数，每一秒为60帧，每一帧中都会执行一次循环，在其中改变位置：</p><pre><code>下一时刻的位置 = 当前时刻的位置 + 速度</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示意代码</span></span><br><span class="line"><span class="comment">// Boid 类的 step() 方法</span></span><br><span class="line"><span class="function"><span class="title">step</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> speed = <span class="built_in">this</span>.speed;</span><br><span class="line">    <span class="keyword">const</span> angle = <span class="built_in">Math</span>.PI / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.vx = <span class="built_in">Math</span>.cos(angle) * speed;</span><br><span class="line">    <span class="built_in">this</span>.vy = <span class="built_in">Math</span>.sin(angle) * speed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 vx, vy 不变化，则会沿一条直线前进</span></span><br><span class="line">    <span class="built_in">this</span>.x += <span class="built_in">this</span>.vx;</span><br><span class="line">    <span class="built_in">this</span>.y += <span class="built_in">this</span>.vy; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每一个循环中，boid 的位置都会发生变化，在新的位置上将其画出即可看到boid 沿直线运动的效果。</p><p>这一部分可在示例代码库的 <code>demo01/go-straight</code>分支上查看：</p><pre><code>git checkout demo01/go-straightnpm run demo01</code></pre><p>现在 boid已经动起来了，但是却没法停止，这就是我们接下来需要考虑的问题。</p><h2 id="如何让-boid-在目标点处停止">如何让 boid 在目标点处停止</h2><p>要让 boid能够知道自己到达了目标点，则在每一次循环过程中，需要计算出此刻离目标点的距离分量<code>dx</code>，<code>dy</code>，据此算出距离<code>dist</code>，将其与速度 <code>speed</code> 进行比较。如果<code>dist &gt; speed</code>，说明物体离目标点还挺远，继续将速度加到位置上即可。反之则表明物体将要到达终点，此时若直接加上速度，boid可能会越过目标点，因此需要一点不同的处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示意代码</span></span><br><span class="line"><span class="function"><span class="title">step</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reachDest) &#123;</span><br><span class="line">        <span class="comment">// 已到达终点，可根据实际需要进行操作            </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> speed = <span class="built_in">this</span>.speed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与目标点的距离</span></span><br><span class="line">    <span class="built_in">this</span>.dx = target.x - <span class="built_in">this</span>.x;</span><br><span class="line">    <span class="built_in">this</span>.dy = target.y - <span class="built_in">this</span>.y;</span><br><span class="line">    <span class="built_in">this</span>.dist = <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.dx * <span class="built_in">this</span>.dx + <span class="built_in">this</span>.dy * <span class="built_in">this</span>.dy);</span><br><span class="line">    <span class="built_in">this</span>.angle = <span class="built_in">Math</span>.atan2(<span class="built_in">this</span>.dy, <span class="built_in">this</span>.dx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 速度分量</span></span><br><span class="line">    <span class="built_in">this</span>.vx = <span class="built_in">Math</span>.cos(<span class="built_in">this</span>.angle) * speed;</span><br><span class="line">    <span class="built_in">this</span>.vy = <span class="built_in">Math</span>.sin(<span class="built_in">this</span>.angle) * speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.dist &gt; speed) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x += <span class="built_in">this</span>.vx;</span><br><span class="line">        <span class="built_in">this</span>.y += <span class="built_in">this</span>.vy; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时刻的位置加上速度后超过了当前目标点</span></span><br><span class="line">        <span class="comment">// 物体下一时刻将处于当前目标点的位置</span></span><br><span class="line">        <span class="built_in">this</span>.x = target.x;</span><br><span class="line">        <span class="built_in">this</span>.y = target.y;</span><br><span class="line">        <span class="built_in">this</span>.reachDest = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分可在示例代码库的 <code>demo01/stop</code> 分支上查看：</p><pre><code>git checkout demo01/stopnpm run demo01</code></pre><p>此时，到达了终点的 boid 被清除而不再显示。</p><h2 id="如何让-boid-能够转向">如何让 boid 能够转向</h2><p>前面叙述中为了简化，路径中只有起点和终点，所以 boid没有机会转向，那当路径变复杂了之后，boid 该如何运动？</p><p>前面已经提到过，<code>path</code>是一个记录了路径网格坐标的数组，boid会从中取一个坐标作为自己的当前目标点，然后一直向前行进，到达了这个目标点之后，它会从<code>path</code>数组中取出下一个坐标，继续移动至该位置。循环以上过程，直到 boid 到达<code>path</code> 中的最后一个坐标。</p><p>上面的代码中，我们的目标点 <code>target</code> 固定为<code>path</code> 的最后一个坐标，而现在每一次转向时 <code>target</code>都会变化，所以加入这样的两个变量：</p><ul><li><code>waypoint</code> 表示<strong>当前</strong>目标点的索引</li><li><code>angleFlag</code> 记录是否需要转向。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Boid 的 step() 中的部分示意代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每次转向后目标点需要重新计算 */</span></span><br><span class="line"><span class="keyword">const</span> waypoint = path[<span class="built_in">this</span>.waypoint];   <span class="comment">// 当前目标点的网格坐标</span></span><br><span class="line"><span class="keyword">const</span> target = index2Px(...waypoint);   <span class="comment">// 当前目标点的像素坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要转向，如果需要转向，则重新计算角度</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.angleFlag) &#123;</span><br><span class="line">    <span class="built_in">this</span>.angle = <span class="built_in">Math</span>.atan2(<span class="built_in">this</span>.dy, <span class="built_in">this</span>.dx);</span><br><span class="line">    <span class="built_in">this</span>.angleFlag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次到达一个目标点之后，都要检查是否为终点</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.waypoint + <span class="number">1</span> &gt;= path.length) &#123;</span><br><span class="line">    <span class="comment">// 到达终点</span></span><br><span class="line">    <span class="built_in">this</span>.reachDest = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.waypoint++;</span><br><span class="line">    <span class="built_in">this</span>.angleFlag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分可在示例代码库的 <code>demo01/steering</code>分支上查看：</p><pre><code>git checkout demo01/steeringnpm run demo01</code></pre><p>结果可见下图： <imgsrc="/asset/images/2017-12-09-path-following-1.png" /></p><p>到此为止，这种 boid 沿路径行进的方法已经讲解完毕了。建议读者查看一下repo 中的代码，自己修改部分代码，比如更改路径，看结果会有何不同。</p><h2 id="其它的方法">其它的方法</h2><p>这一种方法中的确实现了沿路径移动的效果，但是有点儿单调，boid只能在路径的中轴线上移动，而且它们之间也没有交互的效果。<ahref="http://natureofcode.com/book/">The Nature of Code</a>这本书的第六章 <ahref="http://natureofcode.com/book/chapter-6-autonomous-agents/">AutonomousAgents</a> 中介绍了另一种稍微复杂的方法来实现 path following。</p><p>我之前参考他人的代码实现了<ahref="http://www.wukai.me/html-demo/path-following/">这种方法的一个演示版本</a>，其代码在<ahref="https://github.com/noiron/html-demo/tree/master/path-following">此处</a>。</p><p>(也许之后会补一篇博客来介绍 <em>The Nature of Code</em>中的实现，但谁知道会不会写呢🤔)</p><h2 id="结语">结语</h2><p>最后，<ahref="https://github.com/noiron/tower-defense-js">我最近在写的这个塔防游戏</a>中就使用了本文介绍的path following 方法。虽然游戏还没完成，但点进去看看再给个 star又不费电😀。</p><hr /><p><ahref="http://www.wukai.me/2017/12/09/boid-path-following/">本文地址：塔防游戏中的敌人如何沿路径前进(JavaScript 实现)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果开发一个塔防游戏，很自然的会遇上这么两个名字很像的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Path-finding&lt;/strong&gt;:
如果知道起点和终点，如何在其间找到一条路径&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Path-following&lt;/strong&gt;:
已知从起点到终点的路径，物体如何才能沿着它行进&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将要讨论的是第二个问题 &lt;strong&gt;path
following&lt;/strong&gt;，给定一条路径，看物体如何沿着它从起点运行至终点。为了方便描述，接下来的内容中，用单词
&lt;a href=&quot;https://en.wikipedia.org/wiki/Boids&quot;&gt;Boid&lt;/a&gt;
来表示行进的物体或塔防中的敌人。&lt;/p&gt;
&lt;p&gt;接下来会用一种简单的方法来解决这一问题，最终完成的代码库可见 GitHub:
&lt;a
href=&quot;https://github.com/noiron/boid-path-following&quot;&gt;boid-path-following&lt;/a&gt;，repo
的多个分支对应了文中的不同步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="游戏开发" scheme="http://www.wukai.me/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>React Router v4 之代码分割：从放弃到入门</title>
    <link href="http://www.wukai.me/2017/09/25/react-router-v4-code-splitting/"/>
    <id>http://www.wukai.me/2017/09/25/react-router-v4-code-splitting/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍">背景介绍</h2><p>React Router v4推出已有六个月了，网络上因版本升级带来的哀嚎仿佛就在半年前。我在使用这个版本的React Router时，也遇到了一些问题，比如这里所说的代码分割，所以写了这篇博客作为总结，希望能对他人有所帮助。</p><h2 id="什么是代码分割code-splitting">什么是代码分割（codesplitting）</h2><p>在用户浏览我们的网站时，一种方案是一次性地将所有的 JavaScript代码都下载下来，可想而知，代码体积会很可观，同时这些代码中的一部分可能是用户此时并不需要的。另一种方案是按需加载，将JavaScript代码分成多个块（chunk），用户只需下载当前浏览所需的代码即可，用户进入到其它页面或需要渲染其它部分时，才加载更多的代码。这后一种方案中用到的就是所谓的<strong>代码分割（codesplitting）</strong>了。</p><span id="more"></span><p>当然为了实现代码分割，仍然需要和 webpack 搭配使用，先来看看 webpack的文档中是如何介绍的。</p><p><a href="https://webpack.js.org/guides/code-splitting/">Webpack文档的 code splitting 页面</a>中介绍了三种方法：</p><ol type="1"><li>利用 webpack 中的 <code>entry</code> 配置项来进行手动分割</li><li>利用 <code>CommonsChunkPlugin</code> 插件来提取重复 chunk</li><li>动态引入（Dynamic Imports）</li></ol><p>你可以读一下此篇文档，从而对 webpack是如何进行代码分割的有个基本的认识。本文后面将提到的方案就是基于上述的第三种方法。</p><h2 id="react-router-中如何进行代码分割">React Router中如何进行代码分割</h2><p>在 v4 之前的版本中，一般是利用 <code>require.ensure()</code>来实现代码分割的，而在 v4 中又是如何处理的呢？</p><h3 id="使用-bundle-loader-的方案">使用 bundle-loader 的方案</h3><p>在 React Router v4 官方给出的<ahref="https://reacttraining.com/react-router/web/guides/code-splitting">文档</a>中，使用了名为<ahref="https://github.com/webpack-contrib/bundle-loader"><code>bundle-loader</code></a>的工具来实现这一功能。</p><p>其主要实现思路为创建一个名为 <code>&lt;Bundle&gt;</code>的组件，当应用匹配到了对应的路径时，该组件会动态地引入所需模块并将自身渲染出来。</p><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> loadSomething <span class="keyword">from</span> <span class="string">&#x27;bundle-loader?lazy!./Something&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;Bundle load=&#123;loadSomething&#125;&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">mod</span>) =&gt;</span> (</span><br><span class="line">    <span class="comment">// do something w/ the module</span></span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/Bundle&gt;</span><br></pre></td></tr></table></figure><p>更多关于 <code>&lt;Bundle&gt;</code>组件的实现可参见上面给出的文档地址。</p><h3 id="使用-bundle-loader-方法存在的不足之处">使用 bundle-loader方法存在的不足之处</h3><p>这里提到的两个缺点我们在实际开发工作中遇到的，与我们的项目特定结构相关，所以你可能并不会遇上。</p><p>一、 代码丑陋</p><p>由于我们的项目是从 React Router v2, v3升级过来的，在之前的版本中对于异步加载的实现采用了集中配置的方案，即项目中存在一个<code>Routes.js</code>文件，整个项目的路径设置都放在了该文件中，这样方便集中管理。</p><p>但是在 React Router v4 版本中，由于使用了 <code>bundle-loader</code>来实现代码分割，必须使用以下写法来引入组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> loadSomething <span class="keyword">from</span> <span class="string">&#x27;bundle-loader?lazy!./Something&#x27;</span></span><br></pre></td></tr></table></figure><p>而我们的 <code>reducer</code> 和 <code>saga</code>文件也需要使用此种方法引入，导致 <code>Routes.js</code>文件顶端将会出现一长串及其冗长的组件引入代码，不易维护。如下所示：</p><p><img src="/asset/images/2017-08-14-bundle-loader.png" /></p><p>当用这种方法引入的模块数量过多时，文件将会不忍直视。</p><p>二、 存在莫名的组件生命周期Bug</p><p>在使用了这种方案后，在某些页面中会出现这样的一个Bug：应用中进行页面跳转时，上一个页面的组件会在<code>unmount</code>之后重新创建一次。表现为已经到了下一页面，但是会调用存在于跳转前页面中的组件的<code>componentDidMount</code> 方法。</p><p>当然，这个Bug只与我自己的特定项目有关，错误原因可能与<code>bundle-loader</code>并无太大关联。不过因为一直无法解决这一问题，所以决定换一个方案来代替<code>bundle-loader</code>。</p><h2 id="使用-import-的新方案">使用 import() 的新方案</h2><p>Dan Abramov 在这个 create-react-app 的 issue 中给出了<code>bundle-loader</code> 的替代方案的链接：<ahref="http://serverless-stack.com/chapters/code-splitting-in-create-react-app.html">CodeSplitting in Create ReactApp</a>，可以参考该篇文章来实现我们项目中的代码分割功能。</p><h3 id="代码分割和-react-router-v4">代码分割和 React Router v4</h3><p>一个常规的 React Router 项目结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码出处：</span></span><br><span class="line"><span class="comment">// http://serverless-stack.com/chapters/code-splitting-in-create-react-app.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Import the components */</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./containers/Home&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Posts <span class="keyword">from</span> <span class="string">&#x27;./containers/Posts&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">&#x27;./containers/NotFound&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use components to define routes */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/posts/:id&quot;</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">&#123;Posts&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;NotFound&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>首先根据我们的 route 引入相应的组件，然后将其用于定义相应的<code>&lt;Route&gt;</code>。</p><p>但是，不管匹配到了哪一个route，我们这里都一次性地引入所有的组件。而我们想要的效果是当匹配了一个route，则只引入与其对应的组件，这就需要实现代码分割了。</p><h3 id="创建一个异步组件async-component">创建一个异步组件（AsyncComponent）</h3><p>异步组件，即只有在需要的时候才会引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncComponent</span>(<span class="params">importComponent</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AsyncComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        <span class="attr">component</span>: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">default</span>: component &#125; = <span class="keyword">await</span> importComponent();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        <span class="attr">component</span>: component</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> C = <span class="built_in">this</span>.state.component;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> C</span><br><span class="line">        ? <span class="xml"><span class="tag">&lt;<span class="name">C</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">        : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> AsyncComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>asyncComponent</code> 接收一个 <code>importComponent</code>函数作为参数，<code>importComponent()</code>在被调用时会动态引入给定的组件。</p><p>在 <code>componentDidMount()</code>中，调用传入的<code>importComponent()</code>，并将动态引入的组件保存在 state 中。</p><h3 id="使用异步组件async-component">使用异步组件（AsyncComponent）</h3><p>不再使用如下静态引入组件的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./containers/Home&#x27;</span>;</span><br></pre></td></tr></table></figure><p>而是使用 <code>asyncComponent</code> 方法来动态引入组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncHome = asyncComponent(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./containers/Home&#x27;</span>));</span><br></pre></td></tr></table></figure><p>此处的 <code>import()</code> 来自于新的 ES 提案，其结果是一个Promise，这是一种动态引入模块的方法，即上文 webpack文档中提到的第三种方法。更多关于 <code>import()</code>的信息可以查看这篇文章：<ahref="http://2ality.com/2017/01/import-operator.html">ES proposal:import() – dynamically importing ES modules</a>。</p><p>注意这里并没有进行组件的引入，而是传给了 <code>asyncComponent</code>一个函数，它将在 <code>AsyncHome</code>组件被创建时进行动态引入。同时，这种传入一个函数作为参数，而非直接传入一个字符串的写法能够让webpack 意识到此处需要进行代码分割。</p><p>最后如下使用这个 <code>AsyncHome</code> 组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/&quot;</span> exact component=&#123;AsyncHome&#125; /&gt;</span><br></pre></td></tr></table></figure><h3 id="对于-reducer-和-saga-文件的异步加载">对于 reducer 和 saga文件的异步加载</h3><p>在上面的这篇文章中，只给出了对于组件的异步引入的解决方案，而在我们的项目中还存在将<code>reducer</code> 和 <code>saga</code> 文件异步引入的需求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">processReducer</span>(<span class="params">reducer</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(reducer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all(reducer.map(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">this</span>.processReducer(r)));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">Object</span>.keys(reducer)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> reducer[key]().then(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">            injectAsyncReducer(key, x.default);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将需要异步引入的 reducer 作为参数传入，利用 Promise来对其进行异步处理。在 <code>componentDidMount</code> 方法中等待 reducer处理完毕后在将组件保存在 state 中，对于 saga 文件同理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// componentDidMount 中做如下修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">default</span>: component &#125; = <span class="keyword">await</span> importComponent();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.all([<span class="built_in">this</span>.processReducer(reducers),</span><br><span class="line">            <span class="built_in">this</span>.processSaga(sagas)]).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            component</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面对 <code>reducer</code>文件进行处理时，使用了这样的一行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">injectAsyncReducer(key, x.default);</span><br></pre></td></tr></table></figure><p>其作用是利用 Redux 中的 <code>replaceReducer()</code> 方法来修改reducer，具体代码见下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducerList 是你当前的 reducer 列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReducer</span>(<span class="params">asyncReducers</span>) </span>&#123;</span><br><span class="line">    asyncReducers</span><br><span class="line">    &amp;&amp; !reducersList[<span class="built_in">Object</span>.keys(asyncReducers)[<span class="number">0</span>]]</span><br><span class="line">    &amp;&amp; (reducersList = <span class="built_in">Object</span>.assign(&#123;&#125;, reducersList, asyncReducers));</span><br><span class="line">    <span class="keyword">return</span> combineReducers(reducersList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectAsyncReducer</span>(<span class="params">name, asyncReducer</span>) </span>&#123;</span><br><span class="line">    store.replaceReducer(createReducer(&#123; [name]: asyncReducer &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的 asyncComponent 代码可见以下gist，注意一点，为了能够灵活地使用不同的<code>injectAsyncReducer</code>, <code>injectAsyncSaga</code>函数，代码中使用了高阶组件的写法，你可以直接使用内层的<code>asyncComponent</code> 函数。</p><script src="https://gist.github.com/noiron/7f774dea55bcc52921e5bc5a50c2aa10.js"></script><h2 id="asynccomponent-方法与-react-router-v4-的结合使用">asyncComponent方法与 React Router v4 的结合使用</h2><h3 id="组件reducersaga-的异步引入">组件、reducer、saga 的异步引入</h3><p>考虑到代码可读性，可在你的 <code>route</code> 目录下新建一个<code>asyncImport.js</code> 文件，将需要异步引入的模块写在该文件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入前面所写的异步加载函数</span></span><br><span class="line"><span class="keyword">import</span> asyncComponent <span class="keyword">from</span> <span class="string">&#x27;route/AsyncComponent&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只传入第一个参数，只需要组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AsyncHomePage = asyncComponent(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./homepage/Homepage&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入三个参数，分别为 component, reducer, saga</span></span><br><span class="line"><span class="comment">// 注意这里的第二个参数 reducer 是一个对象，其键值对应于redux store中存放的键值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AsyncArticle = asyncComponent(</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./market/Common/js/Container&#x27;</span>),</span><br><span class="line">    &#123; <span class="attr">market</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./market/Common/js/reducer&#x27;</span>) &#125;,</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./market/Saga/watcher&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer 和 saga 参数可以传入数组</span></span><br><span class="line"><span class="comment">// 当只有 saga，而无 reducer 参数时，第二项参数传入空数组 []</span></span><br><span class="line"><span class="keyword">const</span> UserContainer = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./user/Common/js/Container&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> userReducer = &#123; <span class="attr">userInfo</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./user/Common/js/userInfoReducer&#x27;</span>) &#125;;</span><br><span class="line"><span class="keyword">const</span> userSaga = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./user/Saga/watcher&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AsyncUserContainer = asyncComponent(</span><br><span class="line">    UserContainer,</span><br><span class="line">    [userReducer, createReducer],</span><br><span class="line">    [userSaga, createSaga]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后在项目的 <code>Router</code> 组件中引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// route/index.jsx</span></span><br><span class="line">&lt;Route path=<span class="string">&quot;/user&quot;</span> component=&#123;AsyncArticle&#125; /&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/user/:userId&quot;</span> <span class="attr">component</span>=<span class="string">&#123;AsyncUserContainer&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>根据 React Router v4 的哲学，React Router中的一切皆为组件，所以不必在一个单独的文件中统一配置所有的路由信息。建议在你最外层的容器组件，比如我的<code>route/index.jsx</code>文件中只写入<strong>对应一个单独页面的容器组件</strong>，而页面中的子组件在该容器组件中异步引入并使用。</p><del>在 React Router v5 发布之前完成了本文，可喜可贺👏</del><h2 id="参考资料">参考资料</h2><blockquote><p><ahref="http://serverless-stack.com/chapters/code-splitting-in-create-react-app.html">CodeSplitting in Create React App</a> <ahref="http://2ality.com/2017/01/import-operator.html">ES proposal:import() – dynamically importing ES modules</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;React Router v4
推出已有六个月了，网络上因版本升级带来的哀嚎仿佛就在半年前。我在使用这个版本的
React Router
时，也遇到了一些问题，比如这里所说的代码分割，所以写了这篇博客作为总结，希望能对他人有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;什么是代码分割code-splitting&quot;&gt;什么是代码分割（code
splitting）&lt;/h2&gt;
&lt;p&gt;在用户浏览我们的网站时，一种方案是一次性地将所有的 JavaScript
代码都下载下来，可想而知，代码体积会很可观，同时这些代码中的一部分可能是用户此时并不需要的。另一种方案是按需加载，将
JavaScript
代码分成多个块（chunk），用户只需下载当前浏览所需的代码即可，用户进入到其它页面或需要渲染其它部分时，才加载更多的代码。这后一种方案中用到的就是所谓的&lt;strong&gt;代码分割（code
splitting）&lt;/strong&gt;了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://www.wukai.me/tags/webpack/"/>
    
      <category term="react-router" scheme="http://www.wukai.me/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>利用 socket.io 实现消息实时推送</title>
    <link href="http://www.wukai.me/2017/08/27/push-message-with-socketio/"/>
    <id>http://www.wukai.me/2017/08/27/push-message-with-socketio/</id>
    <published>2017-08-26T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目背景介绍">项目背景介绍</h2><p>最近在写的项目中存在着社交模块，需要实现这样的一个功能：当发生了用户被点赞、评论、关注等操作时，需要由服务器向用户实时地推送一条消息。最终完成的项目地址为：<ahref="https://github.com/noiron/socket-message-push">socket-message-push</a>，这里将介绍一下实现的思路及部分代码。</p><p>项目的流程中存在着这样的几个对象：</p><ul><li>用 Java 实现的后端服务器</li><li>用 Node.js 实现的消息推送服务器</li><li>用户进行操作的客户端</li></ul><p>事件处理的流程如下：</p><ol type="1"><li>用户进行点赞操作时，后端服务器会进行处理，并向 Node.js消息推送服务器发送一条消息</li><li>Node.js消息推送服务器接收到后端发送的消息后，处理数据，并确定向哪个用户进行推送</li><li>用户的客户端接收到由 Node.js服务器推送来的消息后，即可进行通知的显示。</li></ol><p>上面的流程中，Java后端服务器是如何实现的不在此篇文章的讨论范围内，本文将主要介绍如何使用Node.js 来实现这个消息推送服务器。</p><span id="more"></span><p>考虑消息推送服务器上必须记录下当前在线用户的信息，这样才能向特定的用户推送消息。所以当用户登录时，必须将自身的用户信息发到Node.js 服务器上。为了达到这种双向的实时消息传递，很明显地考虑用WebSocket 来实现。既然我们在消息推送服务器上使用了Node.js，我们就有了一个很方便的选项：socket.io。</p><h2 id="socket.io-介绍">Socket.io 介绍</h2><p><a href="https://socket.io">Socket.io</a>是一个用 JavaScript实现的实时双向通信的库，利用它来实现我们的功能会很简单。</p><p><code>socket.io</code> 包含两个部分：</p><ul><li>服务器端（server）：运行在 Node.js 服务器上</li><li>客户端（client）：运行在浏览器中</li></ul><p>可以看看如下的 <code>socket.io</code> 的示例代码，它给出了<code>socket.io</code> 发出及监听事件的基本用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">  socket.emit(<span class="string">&#x27;request&#x27;</span>, <span class="comment">/* */</span>); <span class="comment">// emit an event to the socket</span></span><br><span class="line">  io.emit(<span class="string">&#x27;broadcast&#x27;</span>, <span class="comment">/* */</span>); <span class="comment">// emit an event to all connected sockets</span></span><br><span class="line">  socket.on(<span class="string">&#x27;reply&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* */</span> &#125;); <span class="comment">// listen to the event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于 Socket.io 还有一点需要注意：Socke.io 并不完全是 WebSocket的实现。</p><blockquote><p>Note: Socket.IO is not a WebSocket implementation. Although Socket.IOindeed uses WebSocket as a transport when possible, it adds somemetadata to each packet: the packet type, the namespace and the ack idwhen a message acknowledgement is needed.</p></blockquote><p>接下来我们需要用 Express.js 来建立一个服务器端程序，并在其中引入Socket.io。</p><h2 id="node.js-服务器的搭建">Node.js 服务器的搭建</h2><h3 id="利用-express.js-搭建基础服务器">利用 Express.js搭建基础服务器</h3><p>我们使用了 Express.js 来搭建 Node.js消息推送服务器，先利用一个简要的例子来浏览其功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).Server(app);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">4001</span>;</span><br><span class="line"></span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">&#x27;public&#x27;</span>)));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.sendFile(__dirname + <span class="string">&#x27;/public/index.html&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/api&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.listen(port, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`listening on port:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将上面的代码保存为 <code>server.js</code>，新建一个<code>public</code> 文件夹，在其中放入 <code>index.html</code>文件。运行以下命令：</p><pre><code>node server.js</code></pre><p>现在即可在 <code>localhost:4001</code> 查看效果了。</p><h3 id="引入-socket.io">引入 socket.io</h3><p>现在已经有了一个基础的 Express 服务器，接下来需要将 Socket.io加入其中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>)(http);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a user connected&#x27;</span>);</span><br><span class="line">    socket.broadcast.emit(<span class="string">&#x27;new_user&#x27;</span>, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>io</code> 监听 <code>connection</code> 事件，当<code>client</code> 与 <code>server</code>建立了连接之后，这里的回调函数会被调用（<code>client</code>中的代码将在下一节介绍）。</p><p>函数的参数 <code>socket</code> 代表的是当前的 <code>client</code> 和<code>server</code> 间建立的这个连接。可在 <code>client</code>程序中将这个建立的 socket 连接打印出来，如下图所示：</p><p><img src="/asset/images/2017-08-16-socket-attribute.png" /></p><p>其中的 <code>id</code> 属性可以用于标识出这一连接，从而<code>server</code> 可以向特定的用户发送消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.broadcast.emit(<span class="string">&#x27;new_user&#x27;</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure><p>这一行代码表示 <code>socket</code> 将向当前所有与 <code>server</code>建立了连接的 <code>client</code>（不包括自己） 广播一条名为<code>new_user</code> 的消息。</p><h3 id="后端推送消息的处理流程">后端推送消息的处理流程</h3><ol start="0" type="1"><li><p>在 Node 服务器建立一个用户信息和 socket id的映射表，因为同一用户可能打开了多个页面，所以他的 socket id可能存在多个值。当用户建立连接时，往其中添加值；用户断开连接后，删除相应值。</p></li><li><p>当 Java 后台存在需要推送的消息时，会向 Node 服务器的<code>/api</code> 路径 post 一条消息，其中包括用于标识用户的 tokenId和其它数据。</p></li><li><p>Node 服务器接收到 post 请求后，对请求内容进行处理。根据 tokenId找出与该用户对应的 socket id，socket.io 会根据 id来向用户推送消息。</p></li></ol><h3 id="对用户信息的处理">对用户信息的处理</h3><p>方便起见，这里只用一个数组保存用户信息，实际工作中可以根据需要放入数据库中保存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">global</span>.users = []; <span class="comment">// 记录下登录用户的tokenId, socketId</span></span><br></pre></td></tr></table></figure><p>当用户登录时，<code>client</code> 会向 <code>server</code> 发送<code>user_login</code> 事件，服务器接收到后会做如下操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">&#x27;user_login&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; tokenId, userId, socketId &#125; = info;</span><br><span class="line">    addSocketId(users, &#123; tokenId, socketId, userId &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>addSocketId()</code> 会向 <code>users</code>数组中添加用户信息，不同用户通过 tokenId 进行区分，每个用户有一个<code>socketIds</code> 数组，保存可能存在的多个<code>socketId</code>。该函数的具体代码可见 <code>src/utils.js</code>文件。</p><p>同理，还有一个 <code>deleteSocketId()</code>函数用于删除用户信息，代码可见同一文件。</p><p>在获取了用户的 tokenId 之后，就需要找到对应的socketId，然后向特定用户推送消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只向 id = socketId 的这一连接发送消息 </span></span><br><span class="line">io.sockets.to(socketId).emit(<span class="string">&#x27;receive_message&#x27;</span>, &#123;</span><br><span class="line">    entityType,</span><br><span class="line">    data</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>服务器的思路大致如此，接下来介绍客户端中是如何进行相应的处理的。</p><h2 id="客户端">客户端</h2><h3 id="socket.io-的初始化">Socket.io 的初始化</h3><p>首先在 html 文件中引入 Socket.io 的 client 端文件，例如通过 CDN引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其它的引入方式:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io-client&#x27;</span>);</span><br><span class="line"><span class="comment">// or with import syntax</span></span><br><span class="line"><span class="keyword">import</span> io <span class="keyword">from</span> <span class="string">&#x27;socket.io-client&#x27;</span>;</span><br></pre></td></tr></table></figure><p>引入 Socket.io 后就获得了 <code>io</code>函数，通过它来与消息推送服务器建立连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设你将 Node 服务器部署后的地址为：https://www.example.com/ws</span></span><br><span class="line"><span class="comment">// 则： WS_HOST = &#x27;https://www.example.com&#x27;</span></span><br><span class="line"><span class="keyword">const</span> msgSocket = io(<span class="string">`<span class="subst">$&#123;WS_HOST&#125;</span>`</span>, &#123;</span><br><span class="line">    <span class="attr">secure</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/ws/socket.io&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果监听本地：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msgSocket = io(<span class="string">&#x27;http://localhost:4001&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这里如果写成 <code>io('https://www.example.com/ws')</code>会出现错误，需要将 <code>/ws</code> 写入path中。</p><p>为了能在其它文件使用这一变量，可将 <code>msgSocket</code>作为一个全局变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.msgSocket = msgSocket;</span><br></pre></td></tr></table></figure><h3 id="用户建立连接">用户建立连接</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户登录时，向服务器发送用户的信息。服务器会在收到信息后建立 socket 与用户的映射。</span></span><br><span class="line">msgSocket.emit(<span class="string">&#x27;user_login&#x27;</span>, &#123;</span><br><span class="line">    userId,</span><br><span class="line">    <span class="attr">socketId</span>: msgSocket.id,</span><br><span class="line">    tokenId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="接收到推送的消息后的处理">接收到推送的消息后的处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebSocket 连接建立后，监听名为 receive_message 的事件 </span></span><br><span class="line">msgSocket.on(<span class="string">&#x27;receive_message&#x27;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    store.dispatch(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;NEW_SOCKET_MSG&#x27;</span>,</span><br><span class="line">        <span class="attr">payload</span>: msg</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当 WebSocket 服务器向客户端推送了消息之后，客户端需要监听<code>receive_message</code> 事件，接收到的参数中有相应待处理的信息。由于使用了 Redux 进行数据的处理，所以这里 dispatch 了一个<code>NEW_SOCKET_MSG</code> action，后续则是常规的 redux处理流程了。</p><h2 id="项目的使用">项目的使用</h2><p>GitHub 上的项目地址：<ahref="https://github.com/noiron/socket-message-push">socket-message-push</a></p><pre><code>npm run dev</code></pre><p>即可在 devlopment环境下进行测试，现在你就有了一个运行在4001端口的消息推送服务器了。</p><p>但是这里并没有后端的服务器来向我们发送消息，所以我们将利用 Postman来模拟发送消息。</p><p>为了展示程序的功能，在项目的 client 文件夹下放置了一个<code>index.html</code>文件。注意这个文件并不能用在实际的项目中，只是用来显示消息推送的效果而已。</p><p>在开启了服务器之后，打开<code>client/index.html</code>，根据提示随意输入一个 tokenId 即可。</p><p>现在利用 Postman 向 <code>localhost:4001/api</code> post如下的一条信息：</p><pre><code>&#123;    // tokens 数组表示你想向哪个用户推送消息    &quot;tokens&quot;: [&quot;1&quot;, &quot;2&quot;],    &quot;data&quot;: &quot;You shall not pass!!!&quot;&#125;</code></pre><figure><img src="/asset/images/2017-08-27-postman-post-msg.png"alt="postman-post-a-message" /><figcaption aria-hidden="true">postman-post-a-message</figcaption></figure><p>至此，如果一切顺利，你应该能够在 client的控制台中看到收到的消息了。</p><figure><img src="/asset/images/2017-08-27-client-receive-msg.png"alt="client-message" /><figcaption aria-hidden="true">client-message</figcaption></figure><p>你可以打开多个 client 页面，输入不同的tokenId，然后检查消息是否发送给了正确的用户。</p><h2 id="参考资料">参考资料</h2><blockquote><p>https://github.com/socketio/socket.io/tree/master/examples/chathttps://socket.io/docs/</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目背景介绍&quot;&gt;项目背景介绍&lt;/h2&gt;
&lt;p&gt;最近在写的项目中存在着社交模块，需要实现这样的一个功能：当发生了用户被点赞、评论、关注等操作时，需要由服务器向用户实时地推送一条消息。最终完成的项目地址为：&lt;a
href=&quot;https://github.com/noiron/socket-message-push&quot;&gt;socket-message-push&lt;/a&gt;，这里将介绍一下实现的思路及部分代码。&lt;/p&gt;
&lt;p&gt;项目的流程中存在着这样的几个对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 Java 实现的后端服务器&lt;/li&gt;
&lt;li&gt;用 Node.js 实现的消息推送服务器&lt;/li&gt;
&lt;li&gt;用户进行操作的客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件处理的流程如下：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;用户进行点赞操作时，后端服务器会进行处理，并向 Node.js
消息推送服务器发送一条消息&lt;/li&gt;
&lt;li&gt;Node.js
消息推送服务器接收到后端发送的消息后，处理数据，并确定向哪个用户进行推送&lt;/li&gt;
&lt;li&gt;用户的客户端接收到由 Node.js
服务器推送来的消息后，即可进行通知的显示。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面的流程中，Java
后端服务器是如何实现的不在此篇文章的讨论范围内，本文将主要介绍如何使用
Node.js 来实现这个消息推送服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="socket.io" scheme="http://www.wukai.me/tags/socket-io/"/>
    
      <category term="node.js" scheme="http://www.wukai.me/tags/node-js/"/>
    
      <category term="express.js" scheme="http://www.wukai.me/tags/express-js/"/>
    
  </entry>
  
  <entry>
    <title>如何用 html 和 css 画一拳超人</title>
    <link href="http://www.wukai.me/2017/04/16/draw-one-punch-man-with-html-and-css/"/>
    <id>http://www.wukai.me/2017/04/16/draw-one-punch-man-with-html-and-css/</id>
    <published>2017-04-15T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇博客的起因是我看了Medium上的这篇文章：<ahref="https://blog.prototypr.io/how-i-started-drawing-css-images-3fd878675c89">HowI started drawing CSSImages</a>，然后哇哦😦，同样是前端开发，这区别怎么这么大呢？这位作者和我完全点了不同的技能点啊！</p><p>看了几个她在codepen上的作品，比如这个<ahref="http://codepen.io/sashatran/pen/VmwmJO">皮卡丘</a>，发现用到的技术也并不多，于是我也想试试。</p><p>不过有哪个动漫中的人物足够简单，能够用几个基本的几何图形就画出来呢？我想到了一个人，于是我决定画一个《一拳超人》中的<del>卤蛋</del>，不对，是<del>秃头披风侠</del>——琦玉老师。</p><span id="more"></span><p>结果展示：</p><p data-height="450" data-theme-id="dark" data-slug-hash="oZKgMJ" data-default-tab="html,result" data-user="noiron" data-embed-version="2" data-pen-title="One punch man" class="codepen">See the Pen <a href="http://codepen.io/noiron/pen/oZKgMJ/">One punchman</a> by wu kai (<a href="http://codepen.io/noiron"><spanclass="citation" data-cites="noiron">@noiron</span></a>) on<a href="http://codepen.io">CodePen</a>.</p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h2 id="技术概述">技术概述</h2><p>从html文件中你可以看到这张图片实际上全部是由<code>div</code>元素组合而成的，一共用到了15个div。在给一个div元素加上适当的css样式后，就形成了脸上的一个部位。</p><p>在绘制琦玉的头像时，最重要的一个css属性就是<code>border-radius</code>，我们用它可以画出圆形、椭圆及各种变体。图中的脸部轮廓、眼睛、耳朵的形状都是由<code>border-radius</code>来实现的，稍后将介绍其使用方法。</p><p>另一个需要说明的css属性是<code>transform</code>，可以实现平移和旋转。</p><h2 id="border-radius-介绍">border-radius 介绍</h2><p>之前我对<code>border-radius</code>的认识只局限于可以给元素加上圆角，以及将其值设为50%可以让矩形显示为圆形。查了些资料后，才发现可以用它画出许多图形。</p><p><code>border-radius</code>是以下四个属性的简写，每一个属性用于设置一个角的形状：</p><pre><code>border-top-left-radiusborder-top-right-radiusborder-bottom-right-radiusborder-bottom-left-radius</code></pre><figure><img src="https://developer.mozilla.org/files/3638/border-radius-sh.png"alt="border-radius" /><figcaption aria-hidden="true">border-radius</figcaption></figure><p>图片来自<ahref="https://developer.mozilla.org/en/docs/Web/CSS/border-radius">MDN</a></p><p>从上图可以看出当只设置一个值或设置两个相同的值时，显示为圆；设置两个不同的值时，显示为椭圆。以<code>border-top-left-radius</code>为例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the corner is a circle */</span></span><br><span class="line"><span class="comment">/* border-top-left-radius: radius */</span></span><br><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">3px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the corner is an ellipsis */</span></span><br><span class="line"><span class="comment">/* border-top-left-radius: horizontal vertical */</span></span><br><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">0.5em</span> <span class="number">1em</span>;</span><br></pre></td></tr></table></figure><p>若是简写形式，则写成如下格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">48%</span> <span class="number">48%</span> <span class="number">50%</span> <span class="number">50%</span> / <span class="number">42%</span> <span class="number">42%</span> <span class="number">54%</span> <span class="number">54%</span>;</span><br></pre></td></tr></table></figure><p>'/'之前的四个值表示水平轴的长度，'/'之后的四个值表示垂直轴的长度，当水平轴的长度和垂直轴的长度相等时，可以省略'/'及之后的这一组值。</p><p>对于同一组的四个数值，也有简写方式。方法与 padding 和 margin的简写类似，第一个值与第三个值相同或第二个值与第四个值相同时，可以只写一遍。</p><p>在了解了<code>border-radius</code>的用法后，通过给<code>div</code>元素合适的宽高比，在调整四个圆角的半径，就能够获得你想要的形状了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 以下的样式能够画出琦玉的脸部形状</span><br><span class="line">// 在调整<span class="attribute">width</span>, <span class="attribute">height</span>, <span class="attribute">border-radius</span> 后，可画出眼、鼻、嘴的形状</span><br><span class="line"><span class="selector-id">#div1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">144px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">48%</span> <span class="number">48%</span> <span class="number">50%</span> <span class="number">50%</span> / <span class="number">42%</span> <span class="number">42%</span> <span class="number">54%</span> <span class="number">54%</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="transform-介绍">transform 介绍</h2><p><ahref="https://developer.mozilla.org/en-US/docs/Web/CSS/transform">transform属性</a>也是一个很强大的属性，能够对元素做各种变形。不过我们这里只需要用它来进行平移和旋转的操作。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以用 translate 来实现平移操作 */</span></span><br><span class="line"><span class="comment">/* translate() 的两个参数分别表示水平方向和垂直方向的平移距离 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">12px</span>, <span class="number">50%</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上面这一行与下面的这两行是等价的 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">12px</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">50%</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顺时针旋转20度 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">20deg</span>);</span><br></pre></td></tr></table></figure><h2 id="组合得到最终结果">组合得到最终结果</h2><p>在你已经将琦玉头像进行拆解，把各个部分都用一个<code>div</code>来表示并加上了合适的样式后，就能将它们组合起来了。你可以用<code>transform</code>来调整它们的距离，或者直接用<code>absoulte</code>定位。</p><p>最后就得到了琦玉的头像：</p><p><imgsrc="/asset/images/2017-04-10-one-punch-man-not-completed.png" /></p><p>额，秃子，你谁啊！？</p><p>看来不是所有的光头都叫琦玉，还需要对细节进行一点调整：</p><p><img src="/asset/images/2017-04-10-one-punch-man.png" /></p><p>OK，这样就有点像琦玉老师了。最后，如果你愿意的话，还可以用<code>transition</code>属性来稍微加上点动画效果。</p><p>再放一遍代码地址：</p><blockquote><p><ahref="https://codepen.io/noiron/pen/oZKgMJ">Codepen代码及展示</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇博客的起因是我看了Medium上的这篇文章：&lt;a
href=&quot;https://blog.prototypr.io/how-i-started-drawing-css-images-3fd878675c89&quot;&gt;How
I started drawing CSS
Images&lt;/a&gt;，然后哇哦😦，同样是前端开发，这区别怎么这么大呢？这位作者和我完全点了不同的技能点啊！&lt;/p&gt;
&lt;p&gt;看了几个她在codepen上的作品，比如这个&lt;a
href=&quot;http://codepen.io/sashatran/pen/VmwmJO&quot;&gt;皮卡丘&lt;/a&gt;，发现用到的技术也并不多，于是我也想试试。&lt;/p&gt;
&lt;p&gt;不过有哪个动漫中的人物足够简单，能够用几个基本的几何图形就画出来呢？我想到了一个人，于是我决定画一个《一拳超人》中的&lt;del&gt;卤蛋&lt;/del&gt;，不对，是&lt;del&gt;秃头披风侠&lt;/del&gt;——琦玉老师。&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="http://www.wukai.me/tags/html/"/>
    
      <category term="css" scheme="http://www.wukai.me/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>课程笔记--Building a javascript development environment</title>
    <link href="http://www.wukai.me/2017/03/05/lesson-note-build-a-javascript-development-environment/"/>
    <id>http://www.wukai.me/2017/03/05/lesson-note-build-a-javascript-development-environment/</id>
    <published>2017-03-04T16:00:00.000Z</published>
    <updated>2021-12-21T13:55:03.545Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客是我在学习 <ahref="https://app.pluralsight.com/library/courses/javascript-development-environment/recommended-courses">Pluralsight上的课程：Buildinga JavaScript Development Environment</a>时记下的笔记，仅作个人记录之用。</p><p>这门课程系统地介绍了前端开发中的许多工具和术语，从编辑器的选择到项目的部署都进行了介绍，我在学习了这个课程后感觉将之前零散学习的内容串了起来。</p><p>顺便一说，Pluralsight网站上面有许多不错的课程，不过价格太贵，需每月付29美元😥。但是，你可以用微软账号加入<ahref="https://www.visualstudio.com/zh-hans/dev-essentials/">VisualStudio Dev Essentials 计划</a>，这样就可以免费获得Pluralsight3个月的订阅了😀。</p><hr /><h2 id="course-overview">1. Course Overview</h2><p>编程的时候要做许多选择</p><ul><li>Editor</li><li>Module format</li><li>HTML generation</li><li>Transpiling</li><li>Bundler</li><li>Linting</li><li>Testing</li><li>...</li></ul><p>这门课程介绍了如何在这些选项中做出选择</p><span id="more"></span><h2 id="you-need-a-starter-kit">2. You need a starter kit</h2><h3 id="you-need-a-starter-kit-1">You need a starter kit</h3><p>原因：</p><ul><li>Codifies<ul><li>决定</li><li>最佳实践</li><li>教训</li></ul></li><li>鼓励一致性</li><li>避免忘记重要的细节</li><li>增加质量<ul><li>Doing the "right" thing is the easy thing</li></ul></li><li>避免重复工作</li></ul><h3 id="a-starter-kit-is-an-automated-checklist">A starter kit is anautomated checklist</h3><h3 id="who-is-this-course-for">Who is this course for?</h3><p>Atwood's Law</p><p>JavaScript is Everywhere</p><h3 id="what-belongs-in-your-starter-kit">What Belongs in your starterkit?</h3><ul><li>Package Management</li><li>Bundling</li><li>Minification</li><li>Sourcemaps</li><li>Transpiling</li><li>Dynamic HTML Generation</li><li>Centralized HTTP</li><li>Mock API framework</li><li>Component libraries</li><li>Development Webserver</li><li>Linting</li><li>Automated Testing</li><li>Continuous Integration</li><li>Automated deployment</li><li>Working example app</li></ul><h3 id="agenda">Agenda</h3><p>Rhythm 1. Options 2. Recommendation 3. Implement</p><hr /><h2 id="editors-and-configuration">3. Editors and Configuration</h2><h3 id="what-to-look-for-in-a-javascript-editor">What to look for in aJavaScript Editor</h3><ul><li>Strong ES2015+ support</li><li>framework intelligence</li><li>Built-in terminal</li></ul><p>可选编辑器： - Atom - WebStorm - Brackets - VSCode</p><h3 id="editorconfig">Editorconfig</h3><p>EditorConfig 保证大家的编辑器设置一样。</p><h3 id="demo-editorconfig">Demo: Editorconfig</h3><p>增加 .editorconfig 文件</p><hr /><h2 id="package-management">4. Package Management</h2><h3 id="package-managers">Package Managers</h3><ul><li>Bower</li><li>npm</li><li>JSPM</li><li>...</li></ul><h3 id="demo-install-node-and-npm-packages">Demo: Install Node and npmPackages</h3><h3 id="package-security">Package Security</h3><p>何时 Run Security Check ?</p><p>npm start</p><h3 id="demo-node-security-platform">Demo: Node Security Platform</h3><p>全局安装 nsp</p><pre><code>nsp install -g nspλ nsp check(+) No known vulnerabilities found</code></pre><hr /><h2 id="development-web-server">5. Development Web Server</h2><h3 id="development-web-servers">Development Web Servers</h3><ul><li>http-server</li><li>live-server</li><li>Express</li><li>budo</li><li>Webpack dev server</li><li>Browsersync</li></ul><h3 id="sharing-work-in-progress">Sharing Work-in-progress</h3><h4 id="localtunnel">localtunnel</h4><p>步骤：</p><pre><code>1. npm install localtunnel -g2. start app3. lt --port 3000</code></pre><h4 id="ngrok">ngrok</h4><ol type="1"><li>注册</li><li>安装 ngrok</li><li>安装 authtoken</li><li>start app</li><li>./ngrok http 80</li></ol><h4 id="now">now</h4><h4 id="surge">surge</h4><p>快速将静态文件部署到公开URL上去。</p><ol type="1"><li>npm install -g surge</li><li>surge</li></ol><h2 id="automation">6. Automation</h2><h3 id="automation-options">Automation Options</h3><ul><li>Grunt</li><li>Gulp</li><li>npm scripts</li></ul><h3 id="demo-prepost-hooks">Demo: Pre/Post Hooks</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">    <span class="attr">&quot;prestart&quot;</span>: <span class="string">&quot;node buildScripts/startMessage.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;node buildScripts/srcServer.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;poststart&quot;</span>: <span class="string">&quot;...&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行 <code>npm start</code>时，<code>prestart</code>命令中的内容会自动在其之前运行。</p><h3 id="demo-create-security-check-and-share-scripts">Demo: CreateSecurity Check and Share Scripts</h3><p>在 scripts 项中加入：</p><pre><code>&quot;security-check&quot;: &quot;nsp check&quot;</code></pre><h3 id="demo-concurrent-tasks">Demo: Concurrent Tasks</h3><p>假设在运行server的同时，进行security-check，对start命令进行如下的修改：</p><pre><code>&quot;start&quot;: &quot;npm-run-all --parallel security-check open:src&quot;,&quot;open:src&quot;: &quot;node buildScripts/srcServer.js&quot;,</code></pre><p>其中用 npm-run-all 来代替。</p><p>可以用 npm start -s 减少输出中的噪声。</p><h2 id="transpiling">7. Transpiling</h2><h3 id="javascript-versions">JavaScript Versions</h3><h3 id="transpilers">Transpilers</h3><p>Popular transpilers:</p><ul><li>Babel</li><li>TypeScript</li><li>Elm</li></ul><p>Babel可以将最新版本的JavaScript代码向下转换成ES5，从而可以使用所有的新特性。也是最流行的。</p><p>TypeScript是JavaScript的超集。</p><p>Elm不是JavaScript，可以编译成JS。</p><p>Babel配置风格：</p><ol type="1"><li><p>使用.babelrc文件：不止能用在npm中，独立文件易于阅读</p></li><li><p>package.json：项目中少了一个文件</p></li></ol><p>在文件中加入<code>babel</code>项即可</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-package&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// my babel config here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transpiling-build-scripts">Transpiling Build Scripts</h3><h3 id="demo-set-up-babel">Demo: Set Up Babel</h3><p>加入 .babelrc文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;latest&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在preset命令中用babel-node来代替node，来使用es6语法。这样可以使用import,const 等关键字。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;prestart&quot;</span>: <span class="string">&quot;babel-node buildScripts/startMessage.js&quot;</span>,</span><br></pre></td></tr></table></figure><hr /><h2 id="bundling">8. Bundling</h2><h3 id="intro">Intro</h3><p>CommonJS不能在web浏览器中工作，需要将npmpackage打包成浏览器能够使用的形式。</p><h3 id="module-formats">Module Formats</h3><p>5中模块形式： - IIFE - AMD - CommonJS - UMD - ES6 Modules</p><p>现在应继续使用的两种模块：</p><ul><li><p>CommonJS: node中使用</p><p>var jquery = require('jquery')</p></li><li><p>ES6 Module</p></li></ul><h3 id="why-es6-modules">Why ES6 Modules?</h3><p>原因：</p><ul><li>Standardized</li><li>Statically analyzable<ul><li>Improved autocomplete</li><li>intelligent refactoring</li><li>Fails fast</li><li>Tree shaking</li></ul></li><li>Easy to read<ul><li>Named imports</li><li>Default exports</li></ul></li></ul><h3 id="choosing-a-bundler">Choosing a Bundler</h3><ul><li>require.js: first popular bundler</li><li>Browserify: large plugin ecosystem</li><li>Webpack: bundles more than just JS</li><li>Rollup: tree shaking, fast loading production code, quite new...</li><li>JSPM: load modules at runtime</li></ul><p>Why webpack? - Much more than just js - css - images - fonts - html -Bundle splitting - Hot module reloading - Webpack2 offers treeshaking</p><h3 id="demo-configuring-webpack">Demo: Configuring Webpack</h3><p>在根目录下新建<code>webpack.config.dev.js</code>文件，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">debug</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;inline-source-map&#x27;</span>,</span><br><span class="line">  <span class="attr">noInfo</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">entry</span>: [</span><br><span class="line">    path.resolve(__dirname, <span class="string">&#x27;src/index&#x27;</span>)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;web&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">loaders</span>: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/.js$/</span>, exclude: <span class="regexp">/node_modules/</span>, loaders: [<span class="string">&#x27;babel&#x27;</span>]&#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, loaders: [<span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;css&#x27;</span>]&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note: Webpack won't actually generate any physical files for ourdevelopment build. It will serve our build from memory.</p><h3 id="demo-configure-webpack-with-express">Demo: Configure Webpackwith Express</h3><p>在 <code>buildScripts/srcServer.js</code>中添加下列内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">&#x27;webpack&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;../webpack.config.dev&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-middleware&#x27;</span>)(compiler, &#123;</span><br><span class="line">  <span class="attr">noInfo</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">publicPath</span>: config.output.publicPath</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="demo-create-app-entry-point">Demo: Create app entry point</h3><p>添加<code>index.js</code>文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> numeral <span class="keyword">from</span> <span class="string">&#x27;numeral&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> courseValue = numeral(<span class="number">1000</span>).format(<span class="string">&#x27;$0, 0.00&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`I would pay <span class="subst">$&#123;courseValue&#125;</span> for this awesome course!`</span>);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="demo-handling-css-with-webpack">Demo: Handling css withwebpack</h3><p>在我们的webpack配置文件中已经加入了css的loader的情况下，只需要在index.js引入css文件即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="sourcemaps">Sourcemaps</h3><p>Why: Debug transpiled and bundled code.</p><p>Maps code back to original source</p><h3 id="demo-debugging-via-sourcemaps">Demo: Debugging viasourcemaps</h3><h2 id="linting">9. Linting</h2><h3 id="why-lint">Why Lint?</h3><ul><li>Enforce consistency</li><li>Avoid mistakes</li></ul><h3 id="linters">Linters</h3><p>Linter选择:</p><ul><li>JSLint</li><li>JSHint</li><li><strong>ESLint</strong></li></ul><h3 id="eslint-configuration-decisions-overview">ESLint ConfigurationDecisions Overview</h3><ol type="1"><li>Config format?</li><li>Which built-in rules?</li><li>Warnings or errors?</li><li>Which plugins?</li><li>Use preset instead?</li></ol><h3 id="decision-1-configuration-file-fomat">Decision 1: ConfigurationFile Fomat</h3><p>创建ESLint配置文件，或在<code>package.json</code>文件中加入<code>eslintConfig</code>项。</p><h3 id="decision-2-which-rules">Decision 2: Which rules</h3><h3 id="decision-3-warnings-or-errors">Decision 3: Warnings orerrors</h3><ul><li>Warnings<ul><li>Can continnue development</li><li>Can be ignored</li></ul></li><li>Error<ul><li>Breaks the build</li><li>Cannot be ignored</li></ul></li></ul><h3 id="decision-4-which-plugins">Decision 4: Which plugins</h3><p>React开发推荐：eslint-plugin-react</p><p><a href="https://github.com/dustinspecker/awesome-eslint">AwesomeESLint</a></p><h3 id="decision-5-preset">Decision 5: Preset</h3><ul><li>From scratch</li><li>Recommended</li><li>Presets</li></ul><h3 id="watching-files-with-eslint">Watching Files with ESLint</h3><p>Issue: ESLint doesn't watch files</p><p>解决方案：</p><ul><li>eslint-loader<ul><li>Re-lint all files upon save</li></ul></li><li>eslint-watch<ul><li>ESLint wrapper that adds file watch</li><li>Not tied to webpack</li><li>Better warning/error formatting</li><li>...</li></ul></li></ul><h3 id="linting-experimental-features">Linting ExperimentalFeatures</h3><ul><li>Run ESLint directly<ul><li>Supports ES6 and ES7 natively</li></ul></li><li>Babel-eslint<ul><li>Also lints stage 0-4 features</li></ul></li></ul><p>We'll use plain ESLint and run it via eslint-watch.</p><h3 id="why-lint-via-an-antomated-build">Why Lint Via an antomatedBuild?</h3><ol type="1"><li>One place to check</li><li>Universal Configuration</li><li>Part of continuous integration</li></ol><h3 id="demo-eslint-set-up">Demo: ESLint Set Up</h3><p>ESLint设置：</p><ul><li>ESLint Recommended</li><li>eslint-watch</li></ul><p>添加<code>.eslintrc.json</code>文件，内容如下：</p><p><ahref="https://gist.github.com/coryhouse/61f866c7174220777899bcfff03dab7f">GitHubGist</a></p><p>创建调用<code>eslint-watch</code>的 npm script：</p><pre><code>&quot;lint&quot;: &quot;esw webpack.config.* src buildScripts --color&quot;,</code></pre><p>可以使用注释来排除某一个eslint的规则：</p><pre><code>/* eslint-disable no-console */// eslint-disable-line no-console</code></pre><h3 id="demo-watching-files">Demo: Watching Files</h3><p>在 lint script 下加一句：</p><pre><code>&quot;lint:watch&quot;: &quot;npm run lint -- --watch&quot;,</code></pre><p>加入 start script 中：</p><pre><code>&quot;start&quot;: &quot;npm-run-all --parallel security-check open:src lint:watch&quot;,</code></pre><h2 id="testing-and-continuous-integration">10. Testing and ContinuousIntegration</h2><h3 id="test-decisions-overview">Test Decisions Overview</h3><table><thead><tr class="header"><th>Style</th><th>Focus</th></tr></thead><tbody><tr class="odd"><td>Unit</td><td>Single function or module</td></tr><tr class="even"><td>Integration</td><td>Interations between modules</td></tr><tr class="odd"><td>UI</td><td>Automate interaations with UI</td></tr></tbody></table><h3 id="decision-1-testing-framework">Decision 1: Testing Framework</h3><ul><li><strong>Mocha</strong></li><li>Jasmine</li><li>Tape</li><li>QUnit</li><li>AVA</li><li>Jest</li></ul><p>以上任一皆可。</p><h3 id="decision-2-assertion-libries">Decision 2: Assertion Libries</h3><p>Jasmine and Jest have assertion libries built in.</p><p>Assertion: Declare what you expect</p><pre><code>eg. expect(2 + 2).to.equal(4)</code></pre><ul><li><strong>Chai</strong></li><li>Should.js</li><li>expect</li></ul><h3 id="decision-3-helper-libraries">Decision 3: Helper Libraries</h3><ul><li><p>JSOM: Simulate the browser's DOM</p></li><li><p>Cheerio: jQuery for the server</p></li></ul><h3 id="decision-4-where-to-run-tests">Decision 4: Where to runtests</h3><ul><li>Browser: Karma, Testem</li><li>Headless Browser: PhantomJS</li><li>In-mermory DOM: <strong>JSDOM</strong></li></ul><h3 id="decision-5-where-do-test-files-belong">Decision 5: Where do testfiles belong</h3><ul><li>Centralized: in a folder called 'test'<ul><li>Less "noise" in src folder</li><li>Deployment confusion</li><li>Inertia</li></ul></li><li>Alongside<ul><li>Easy imports</li><li>Clear visibility</li><li>Conventient to open</li><li>...</li></ul></li></ul><h3 id="decision-6-when-should-tests-run">Decision 6: When should testsrun?</h3><ul><li>Unit tests should run when you hit save<ul><li>Rapid feedback</li></ul></li><li>Interation tests often run on demand, or in QA</li></ul><h3 id="demo-testing-setup">Demo: Testing Setup</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** buildScripts/testSetup.js */</span></span><br><span class="line"><span class="comment">// Register babel to transpile before our test run.</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;babel-register&#x27;</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable webpack features that Mocha doesn&#x27;t understand.</span></span><br><span class="line"><span class="built_in">require</span>.extensions[<span class="string">&#x27;.css&#x27;</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add &quot;test&quot; scripts in package.json</span></span><br><span class="line"><span class="string">&quot;test&quot;</span>: <span class="string">&quot;mocha --reporter progress buildScripts/testSetup.js \&quot;src/**/*.test.js\&quot; &quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/index.test.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">&#x27;chai&#x27;</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;Our first test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&#x27;should pass&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(<span class="literal">true</span>).to.equal(<span class="literal">true</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="demo-dom-testing">Demo: DOM Testing</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsdom <span class="keyword">from</span> <span class="string">&#x27;jsdom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;index.html&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&#x27;should say hello&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = fs.readFileSync(<span class="string">&#x27;./src/index.html&#x27;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    jsdom.env(index, <span class="function"><span class="keyword">function</span>(<span class="params">err, <span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> h1 = <span class="built_in">window</span>.document.getElementsByTagName(<span class="string">&#x27;h1&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">      expect(h1.innerHTML).to.equal(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">      done();</span><br><span class="line">      <span class="built_in">window</span>.close();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="demo-watching-tests">Demo: Watching Tests</h3><p>Add this script to <code>package.json</code>:</p><pre><code>&quot;test:watch&quot;: &quot;npm run test -- --watch&quot;</code></pre><p>Then add <code>test:watch</code> to the end of <code>start</code>script:</p><pre><code>&quot;start&quot;: &quot;npm-run-all --parallel security-check open:src lint:watch test:watch&quot;</code></pre><h3 id="why-continuous-integration">Why Continuous Integration?</h3><p>When team commits code, confirm immediately that the commit works asexpected when on another machine.</p><h3 id="what-does-continuous-integration-do">What Does ContinuousIntegration Do?</h3><ul><li>Run automated build</li><li>Run your tests</li><li>Check code coverage</li><li>Automate deployment</li></ul><h3 id="choosing-a-ci-server">Choosing a CI Server</h3><ul><li><strong>Travis</strong>: Linux based</li><li><strong>Appveyor</strong>: Windows based</li><li>Jenkins</li><li>CircleCI</li><li>Semaphore</li><li>SnapCI</li></ul><h3 id="demo-travis-ci">Demo: Travis CI</h3><p>使用GitHub账号登录<a href="https://travis-ci.org/">TravisCI</a>，即可选择你在GitHub上的项目进行持续集成。</p><p>需要在项目中加入travis的配置文件<code>.travis.yml</code>：</p><pre><code>language: node_jsnode_js:  - &quot;6&quot;</code></pre><h3 id="demo-appveyor">Demo: Appveyor</h3><h2 id="http-calls">11. HTTP Calls</h2><h3 id="http-call-approaches">HTTP Call Approaches</h3><ul><li>Node<ul><li>http</li><li>request</li></ul></li><li>Browser<ul><li>XMLHttpRequest</li><li>jQuery</li><li>Framework-based</li><li>Fetch</li></ul></li><li>Node &amp; Browser<ul><li>isomorphic-fetch</li><li>xhr</li><li>superagent</li><li>axios</li></ul></li></ul><h3 id="centralizing-http-requests">Centralizing HTTP Requests</h3><p>Why?</p><ul><li>Configure all calls</li><li>Handle preloader logic</li><li>Handle errors</li><li>Single seam for mocking</li></ul><h3 id="demo-fetch">Demo: Fetch</h3><p>修改 <code>srcServer.js</code> 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/users&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.json([</span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>,<span class="string">&quot;firstName&quot;</span>:<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;lastName&quot;</span>:<span class="string">&quot;Smith&quot;</span>,<span class="string">&quot;email&quot;</span>:<span class="string">&quot;bob@gmail.com&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">2</span>,<span class="string">&quot;firstName&quot;</span>:<span class="string">&quot;Tammy&quot;</span>,<span class="string">&quot;lastName&quot;</span>:<span class="string">&quot;Norton&quot;</span>,<span class="string">&quot;email&quot;</span>:<span class="string">&quot;tnorton@yahoo.com&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">3</span>,<span class="string">&quot;firstName&quot;</span>:<span class="string">&quot;Tina&quot;</span>,<span class="string">&quot;lastName&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;email&quot;</span>:<span class="string">&quot;lee.tina@hotmail.com&quot;</span>&#125;</span><br><span class="line">  ]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>加入 userApi.js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;whatwg-fetch&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(<span class="string">&#x27;users&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(url).then(onSuccess, onError);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onSuccess</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error); <span class="comment">// eslint-disable-line no-console</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时打开<code>localhost:3000/users</code>，能查看API结果。</p><h3 id="selective-polyfilling">Selective Polyfilling</h3><p>Polyfill.io: Only send polyfill to those who need it</p><h3 id="why-mock-http">Why Mock HTTP?</h3><ul><li>Unit Testing</li><li>Instant response</li><li>Keep working when services are down</li><li>Rapid prototyping</li><li>Avoid inter-team bottlenecks</li><li>Work offline</li></ul><h3 id="how-to-mock-http">How to Mock HTTP</h3><ul><li>Nock</li><li>Static JSON</li><li>Create development webserver<ul><li>api-mock</li><li>JSON server</li><li>JSON Schema faker</li><li>Browsersync</li><li>Express, etc</li></ul></li></ul><h3 id="our-plan-for-mocking">Our Plan for Mocking</h3><ol type="1"><li>Declare our schema:<ul><li>JSON Schema Faker</li></ul></li><li>Generate Random Data:<ul><li>faker.js</li><li>chance.js</li><li>randexp.js</li></ul></li><li>Serve Data via API<ul><li>JSON Server</li></ul></li></ol><h3 id="mocking-libraries">Mocking Libraries</h3><p>JSON Schema Faker</p><p>JSON Server</p><h3 id="demo-creating-a-mock-api-data-schema">Demo: Creating a Mock APIData Schema</h3><ul><li>Mock HTTP</li></ul><p>创建文件：<code>buildScripts/mockDataSchema.js</code>文件，内容如下：bit.ly/ps-mock-data-schema</p><h3 id="demo-generating-mock-data">Demo: Generating Mock Data</h3><p>在<code>buildScripts</code>中新建文件<code>generateMockData.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buildScripts/generateMockData.js</span></span><br><span class="line"><span class="keyword">import</span> jsf <span class="keyword">from</span> <span class="string">&#x27;json-schema-faker&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; schema &#125; <span class="keyword">from</span> <span class="string">&#x27;./mockDataSchema&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">&#x27;chalk&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = <span class="built_in">JSON</span>.stringify(jsf(schema));</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">&quot;./src/api/db.json&quot;</span>, json, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(chalk.red(err));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.green(<span class="string">&quot;Mock data generated&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在<code>package.json</code>中加入<code>generate-mock-data</code>script:</p><pre><code>&quot;generate-mock-data&quot;: &quot;babel-node buildScripts/generateMockData&quot;</code></pre><p>运行<code>npm run generate-mock-data</code>，会生成一个<code>db.json</code>文件。</p><h3 id="demo-serving-mock-data-via-json-server">Demo: Serving Mock Datavia JSON Server</h3><p>Add script:</p><pre><code>&quot;start-mockapi&quot;: &quot;json-server --watch src/api/db.json --port 3001&quot;</code></pre><p>json-server会将<code>db.json</code>中的内容生成一个API，如下为运行后输出内容。</p><pre><code>Loading src/api/db.jsonDoneResourceshttp://localhost:3001/usersHomehttp://localhost:3001</code></pre><p>在开发环境中需要将API换成 mock api。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/api</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getBaseUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inDevelopment = <span class="built_in">window</span>.location.hostname === <span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> inDevelopment ? <span class="string">&#x27;http://localhost:3001/&#x27;</span> : <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return fetch(url).then(onSuccess, onError);</span></span><br><span class="line">  <span class="keyword">return</span> fetch(baseUrl + url).then(onSuccess, onError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="demo-manipulating-data-via-json-server">Demo: Manipulating Datavia JSON Server</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/api</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteUser</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> del(<span class="string">`users/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> request = <span class="keyword">new</span> Request(baseUrl + url, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;DELETE&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fetch(request).then(onSuccess, onError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h2 id="project-structure">12. Project Structure</h2><h3 id="why-a-demo-app">Why a Demo App?</h3><p>Examples of: - Directory structure and file naming - Framework usage- Testing - Mock API - Automated deployment</p><h3 id="tip-1-js-belongs-in-a-.js-file">Tip 1: JS Belongs in a .jsFile</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// dont&#x27;t put code here</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="tip-2-consider-organizing-by-feature">Tip 2: Consider Organizingby Feature</h3><h3 id="tip-3-extract-logic-to-pojos">Tip 3: Extract Logic to POJOs</h3><p>POJOs: Plain Old JavaScript Objects, Pure logic, Noframework-specific code</p><h2 id="production-build">13. Production Build</h2><h3 id="minification-and-sourcemaps">Minification and Sourcemaps</h3><h3 id="demo-production-webpack-configuration-with-minification">Demo:Production Webpack Configuration with Minification</h3><p>新建<code>webpack.config.prod.js</code>，相比<code>webpack.config.dev.js</code>加入plugin：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// Eliminate duplicate packages when generating bundle</span></span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.DedupePlugin(),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Minify JS</span></span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>新建<code>buildScripts/build.js</code>文件。</p><h3 id="demo-configure-localdist-server">Demo: Configure Local/distServer</h3><p>新建<code>buildScripts/distServer.js</code>文件，用于 staticfiles。</p><h3 id="demo-toggle-mock-api">Demo: Toggle Mock API</h3><h3 id="demo-production-build-npm-scripts">Demo: Production Build npmScripts</h3><h3 id="dynamic-html-generation">Dynamic HTML Generation</h3><h3 id="bundle-splitting">Bundle Splitting</h3><h3 id="cache-busting">Cache Busting</h3><h3 id="demo-extract-and-minify-css">Demo: Extract and Minify CSS</h3><h3 id="error-logging">Error Logging</h3><h2 id="production-deploy">14. Production Deploy</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客是我在学习 &lt;a
href=&quot;https://app.pluralsight.com/library/courses/javascript-development-environment/recommended-courses&quot;&gt;Pluralsight上的课程：Building
a JavaScript Development Environment&lt;/a&gt;
时记下的笔记，仅作个人记录之用。&lt;/p&gt;
&lt;p&gt;这门课程系统地介绍了前端开发中的许多工具和术语，从编辑器的选择到项目的部署都进行了介绍，我在学习了这个课程后感觉将之前零散学习的内容串了起来。&lt;/p&gt;
&lt;p&gt;顺便一说，Pluralsight网站上面有许多不错的课程，不过价格太贵，需每月付29美元😥。但是，你可以用微软账号加入&lt;a
href=&quot;https://www.visualstudio.com/zh-hans/dev-essentials/&quot;&gt;Visual
Studio Dev Essentials 计划&lt;/a&gt;，这样就可以免费获得Pluralsight
3个月的订阅了😀。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;course-overview&quot;&gt;1. Course Overview&lt;/h2&gt;
&lt;p&gt;编程的时候要做许多选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Editor&lt;/li&gt;
&lt;li&gt;Module format&lt;/li&gt;
&lt;li&gt;HTML generation&lt;/li&gt;
&lt;li&gt;Transpiling&lt;/li&gt;
&lt;li&gt;Bundler&lt;/li&gt;
&lt;li&gt;Linting&lt;/li&gt;
&lt;li&gt;Testing&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这门课程介绍了如何在这些选项中做出选择&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.wukai.me/tags/javascript/"/>
    
      <category term="webpack" scheme="http://www.wukai.me/tags/webpack/"/>
    
      <category term="npm" scheme="http://www.wukai.me/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>从头创建一个基于 React, webpack, babel 的模板项目</title>
    <link href="http://www.wukai.me/2016/09/14/create-a-react-webpack-es6-project/"/>
    <id>http://www.wukai.me/2016/09/14/create-a-react-webpack-es6-project/</id>
    <published>2016-09-13T16:00:00.000Z</published>
    <updated>2022-02-16T13:57:16.004Z</updated>
    
    <content type="html"><![CDATA[<p>如果是一个刚接触 React 的新手，当学完了 React的各种基本概念和语法之后，准备开始实际的开发工作时，他又会碰到各种新颖的名词：npm,webpack, babel, flux, es2015……如果以前接触过这些工具还好，否则为了建立一个简单的项目，还需要学习这一整套的流程，而在这中间又会碰上各种坑，这个过程将会非常痛苦。一个解决方案是去GitHub 上寻找各种模板项目，用 React + webpack + ...作为关键字搜索可以发现许多别人创建的空项目，你可以在其基础上稍作修改然后开始开发。我在学习的过程中就是这么做的，但之后对其中的一些配置项仍是一知半解。</p><p>我在这里从头开始创建一个模板项目，并将过程记录下来，一方面希望能给看到这篇文章的人以帮助，另一方面也是加深我自己的理解。</p><p>最后完成的项目见这个项目：<ahref="https://github.com/noiron/react-webpack-babel-boilerplate">react-webpack-babel-boilerplate</a>，在建立这个项目过程中的步骤可见另一个项目：<ahref="https://github.com/noiron/create-react-boilerplate-steps">create-react-boilerplate-steps</a>，过程被分到了多个文件夹中。</p><h2 id="项目结构">项目结构</h2><p>在开始之前先看看项目的文件结构：</p><pre><code>- src  - index.js  - App.js- .babelrc- index.html- package.json- server.js- webpack.config.js</code></pre><p>以上就是我们的项目需要的全部文件了。</p><p>接下来我会将这个项目的构建过程分解成几个步骤，你只要按照这些步骤依次进行即可。</p><span id="more"></span><h2 id="初始化项目">初始化项目</h2><p>首先我们新建一个名为 react-webpack-boilerplate的文件夹，然后需要在命令行下对项目进行初始化。</p><p>你需要到 Node.js 的官网上下载 node.js 并安装，如果你已经对 NPM有了基本的了解，可以在命令行下进入项目目录运行：</p><pre><code>npm init</code></pre><p>之后你需要按照提示输入你的项目的基本信息，这里也可以一直回车，则选择默认选项，或者运行：</p><pre><code>npm init -y    // 所有信息都按照默认设置</code></pre><p><code>npm init</code>命令的作用就是初始化一个项目，你可以发现项目文件夹内多出了一个<code>package.json</code> 文件，它的内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照默认设置生成的 package.json 文件</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;react-webpack-boilerplate&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目的运行需要依赖各种 npm 包，需要在文件的 "dependencies" 或"devDependencies" 项下写明 npm包的名称及版本。现在这个项目还是空的，所以这里还没有这两项。</p><p>由于直接用 npm 安装的速度很慢，我们可以考虑用 cnpm install 命令来代替npm install 命令。</p><p>CNPM 是淘宝建立的一个 NPM镜像，由于服务器在国内，速度自然也就快多了。</p><pre><code>// 安装 cnpm$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>完成后，你就可以用 cnpm install 来安装所需的 npm 包了。</p><blockquote><p><a href="https://npm.taobao.org/">淘宝 NPM 镜像</a></p></blockquote><h2 id="安装及配置-webpack">安装及配置 webpack</h2><h3 id="webpack-是什么">webpack 是什么？</h3><p>webpack 是一个打包工具，它能够将各种资源如js、css、图片作为模块载入并进行打包。你可以从<ahref="https://github.com/petehunt/webpack-howto">GitHub上这个教程</a>开始学习 webpack 的基本用法。</p><h3 id="webpack-的安装">webpack 的安装</h3><p>在命令行下面运行：</p><pre><code>$ npm install webpack --save-dev</code></pre><p>这一句的作用的是给项目安装webpack，现在查看项目文件夹，会发现多出了一个 <code>node_modules</code>文件夹，这里就是存放项目所依赖的 npm 包的地方。</p><p>上面的这条命令后面跟着的 <code>--save-dev</code>，表示将会把 webpack的名称写入 <code>package.json</code> 文件中。我们打开<code>package.json</code> 文件，发现文件中多了一项：</p><pre><code>&quot;devDependencies&quot;: &#123;    &quot;webpack&quot;: &quot;^1.13.2&quot;&#125;</code></pre><p><code>--save-dev</code> 表示会写入 "devDependencies" 项中，而<code>--save</code> 写入的是 "dependencies" 项。</p><h3 id="webpack-的测试">webpack 的测试</h3><p>你可以选择将 webpack安装在全局中，或者安装在这一个项目中。全局安装时需要在命令后面加上<code>-global</code> 或 <code>-g</code>参数，这样你可以直接在命令行中使用 webpack 命令了。</p><p>选择全局安装：</p><pre><code>$ cnpm install webpack -g </code></pre><p>既然我们已经将 webpack安装在了全局，那就先在命令行下测试一下它的打包功能。</p><p>新建 <code>index.js</code> 文件，里面只有一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;This is a javascript file for test.&#x27;</span>);</span><br></pre></td></tr></table></figure><p>运行一个最简单的 webpack 命令：</p><pre><code>$ webpack index.js bundle.js</code></pre><p>它的意思是将 <code>index.js</code> 文件打包成名为<code>bundle.js</code> 的文件，后一个参数是你想要生成的文件名称。</p><p>运行之后会发现多出了一个 <code>bundle.js</code> 文件，用 node运行该文件测试一下：</p><pre><code>$ node bundle.jsThis is a javascript file for test.    // 输出了正确的结果</code></pre><p>可以新建一个 html 文件，引入 <code>bundle.js</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>react webpack boilerplate<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开<code>index.html</code>，你可以在浏览器的控制台中看到输出结果。</p><h3 id="webpack-的配置文件">webpack 的配置文件</h3><p>我们可以在命令行下完成各种复杂的 webpack操作，不过更方便的方法是利用配置文件。</p><p>新建 <code>webpack.config.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的 webpack.config.js 文件</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// webpack 进行打包的入口文件，这里 webpack 从根目录下的 index.js 开始进行打包</span></span><br><span class="line">  <span class="attr">entry</span>: [</span><br><span class="line">    <span class="string">&#x27;./index&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// webpack 打包后的输出文件的路径</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 文件放至当前路径下的 dist 文件夹</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,  <span class="comment">// 将打包后的输出文件命名为 bundle.js</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>html 文件的引用路径相应地改成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再将 webpack 安装在本地：</p><pre><code>$ npm install webpack --save-dev</code></pre><p>现在你可以运行 <code>webpack</code> 看看效果了。</p><p>我们在上面的过程虽然称之为打包，但是我们只不过将一个<code>index.js</code> 文件变成了 <code>bundle.js</code>文件，文件的体积甚至还变大了。那看一下如果我们有两个 js文件是如何处理的。</p><p>新建 <code>a.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = a;</span><br></pre></td></tr></table></figure><p>在 index.js 中加入下列语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span>, a);</span><br></pre></td></tr></table></figure><p>再次用 <code>webpack</code> 命令打包，生成了新的<code>bundle.js</code> 文件。好了，现在我们不需要用 <code>script</code>标签分别来引入 <code>index.js</code> 和 <code>a.js</code>两个文件了，直接引入 <code>bundle.js</code>这一个就行了。如果我们有许多引用的资源，经过这样的打包过程，自然就方便多了。</p><p>以上的步骤可以在 step1 文件夹内查看。</p><h3 id="安装-web-dev-server并用其开启一个服务器">安装web-dev-server，并用其开启一个服务器</h3><p>首先运行如下命令，安装 web-dev-server：</p><pre><code>$ npm i webpack-dev-server --save-dev</code></pre><p>添加如下的 server.js 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> WebpackDevServer = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-server&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> WebpackDevServer(webpack(config));</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="string">&#x27;localhost&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;listening at locahost:3000...&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> WebpackDevServer(webpack(config));</span><br></pre></td></tr></table></figure><p>这一句创建了一个 webpack dev server，这是一个 node.js express服务器，关于它的用法可以见<ahref="https://webpack.github.io/docs/webpack-dev-server.html">这里的文档</a>。</p><p>在 webpack.config.js 的 output 这一项中加上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publicPath: <span class="string">&#x27;/static/&#x27;</span></span><br></pre></td></tr></table></figure><p>server.js 修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> WebpackDevServer(webpack(config), &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: config.output.publicPath</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>好了，现在你可以运行：</p><pre><code>$ node server.js</code></pre><p>然后打开浏览器进入 http://localhost:3000查看效果了（当然，现在除了在控制台输出了信息之外什么都没干）</p><p>在 <code>package.json</code> 文件内加上这么一项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;node server.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>你可以用 <code>npm start</code> 来代替上面的<code>node server.js</code> 了，这两者是等价的。</p><p>上述步骤可以到 step2 文件夹中查看，运行下列命令：</p><pre><code>$ npm i$ npm start</code></pre><blockquote><p>webpack 的参考资料：https://webpack.github.io/docs/tutorials/getting-started/https://medium.com/<span class="citation"data-cites="rajaraodv/webpack-the-confusing-parts-58712f8fcad9">@rajaraodv/webpack-the-confusing-parts-58712f8fcad9</span>#.81jvwhvmohttp://www.cnblogs.com/skylar/p/webpack-module-bundler.html</p></blockquote><h2 id="关于-babel">关于 Babel</h2><h3 id="babel-是什么">Babel 是什么？</h3><p>因为在 React 的项目中会用到 ES6(即ES2015) 的语法，而 ES6还没有得到广泛的支持，所以我们需要借用 Babel 这个工具将我们使用了 ES6语法的代码转换成 ES5 的语法，从而可以在更广泛的环境下运行。</p><blockquote><p><a href="https://babeljs.io/">Babel 的官方网站</a></p></blockquote><h3 id="怎么安装-babel">怎么安装 Babel？</h3><p>在我们的项目中，需要安装这样的几个 package：</p><pre><code>$ npm install --save-dev babel-loader babel-core</code></pre><p>在 Babel 6.x 之前的版本中，Babel 会执行一些默认的转换规则，而在 6.x之后的版本，你需要显示地告诉 babel你想执行什么转换。最简单的方法就是使用 preset，比如说 ES2015Preset。</p><pre><code>$ npm install babel-preset-es2015 --save-dev</code></pre><blockquote><p>Presets are sharable .babelrc configs or simply an array of babelplugins.</p></blockquote><p>我们这里还需要另一个名为 stage-0 的 Preset：</p><pre><code>$ npm install babel-preset-es2015 --save-dev</code></pre><blockquote><p>参考文档： <ahref="https://babeljs.io/docs/setup/#installation">Babel 的安装</a> <ahref="https://babeljs.io/docs/plugins/#presets">Presets</a></p></blockquote><p>现在只要添加一个 .babelrc 文件即可，<ahref="https://babeljs.io/docs/usage/babelrc/">babelrc</a> 是 Babel的配置文件，你可以在<ahref="http://babeljs.io/docs/usage/options/">这个页面</a>找到你可以加入文件中的各种选项。</p><p>这里只需在 .babelrc 中写入如下内容即可：</p><pre><code>&#123;  &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-0&quot;]&#125;</code></pre><p>将 webpack.config.js 文件做如下的修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">loaders</span>: [&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loaders: [<span class="string">&#x27;babel&#x27;</span>],</span><br><span class="line">    <span class="attr">include</span>: path.join(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">stats</span>: <span class="string">&#x27;errors-only&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以在我们的项目使用 babel 来进行转码了。</p><p>这一步可在 step 3 中查看。</p><h2 id="安装-react">安装 React</h2><p>既然你在看这篇文章，相信你已经对 React 有了一定的了解，React是做什么的就不用再多介绍了。</p><p>安装 React 的 package 十分简单：</p><pre><code>$ npm install react react-dom --save</code></pre><p>为了能够让 babel 对 react 进行处理，再安装一个 babel-preset-react</p><pre><code>$ npm install babel-preset-react</code></pre><p>同时在 .babelrc 文件中也加入这一项：</p><pre><code>&quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-0&quot;, &quot;react&quot;]</code></pre><p>新建一个基本的 React 组件试试看：</p><p>首先在 index.html 中加上这样的一个元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React 元素将在上面渲染。</p><p>在 src 文件夹下新建两个文件 App.js index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./src/index.js</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./src/App.js</span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;%c%s&#x27;</span>, <span class="string">&#x27;font-size:20px;color:red&#x27;</span>, <span class="string">&#x27;Something happened.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>This is a react boilerplate project with webpack and es6.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你可以 npm start 看看效果了。</p><p>以上内容可以在 step4 文件夹中查看。</p><h2 id="安装-react-hot-loader">安装 react-hot-loader</h2><p>其实到上一步为止，我们已经完成了一个完整的 react模板项目，不过还缺一点，就是当我们在编辑器中修改了文件的时候，需要在浏览器里手动刷新，才能看到结果。我们可以利用一个名为react-hot-loader 的工具来帮助我们实现浏览器自动刷新的效果。</p><p>首先安装 react-hot-loader:</p><pre><code>npm install react-hot-loader@^1.3.0 --save-dev</code></pre><p>这里加上了版本号是因为默认安装最新的 react-hot-loader v3.0.0-beta版本，设置会和下面的有所区别。</p><p>在 server.js 中加一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> WebpackDevServer(webpack(config), &#123;</span><br><span class="line">  <span class="attr">stats</span>: config.devServer.stats,</span><br><span class="line">  <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">publicPath</span>: config.output.publicPath</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对 webpack.config.js 做如下修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">entry: [</span><br><span class="line">  <span class="string">&#x27;webpack-dev-server/client?http://localhost:3000&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;webpack/hot/only-dev-server&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;./src/index&#x27;</span></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="attr">loaders</span>: [&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  loaders: [<span class="string">&#x27;react-hot&#x27;</span>, <span class="string">&#x27;babel&#x27;</span>],</span><br><span class="line">  <span class="attr">include</span>: path.join(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>并加入一个插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这一步的内容可以查看 step5 文件夹。</p><hr /><p>到此我们的这个模板项目就完成了。你可以在<ahref="https://github.com/noiron/react-webpack-babel-boilerplate">GitHub上的这个项目中</a>看到完整的项目代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果是一个刚接触 React 的新手，当学完了 React
的各种基本概念和语法之后，准备开始实际的开发工作时，他又会碰到各种新颖的名词：npm,
webpack, babel, flux, es2015……
如果以前接触过这些工具还好，否则为了建立一个简单的项目，还需要学习这一整套的流程，而在这中间又会碰上各种坑，这个过程将会非常痛苦。一个解决方案是去
GitHub 上寻找各种模板项目，用 React + webpack + ...
作为关键字搜索可以发现许多别人创建的空项目，你可以在其基础上稍作修改然后开始开发。我在学习的过程中就是这么做的，但之后对其中的一些配置项仍是一知半解。&lt;/p&gt;
&lt;p&gt;我在这里从头开始创建一个模板项目，并将过程记录下来，一方面希望能给看到这篇文章的人以帮助，另一方面也是加深我自己的理解。&lt;/p&gt;
&lt;p&gt;最后完成的项目见这个项目：&lt;a
href=&quot;https://github.com/noiron/react-webpack-babel-boilerplate&quot;&gt;react-webpack-babel-boilerplate&lt;/a&gt;，在建立这个项目过程中的步骤可见另一个项目：&lt;a
href=&quot;https://github.com/noiron/create-react-boilerplate-steps&quot;&gt;create-react-boilerplate-steps&lt;/a&gt;，过程被分到了多个文件夹中。&lt;/p&gt;
&lt;h2 id=&quot;项目结构&quot;&gt;项目结构&lt;/h2&gt;
&lt;p&gt;在开始之前先看看项目的文件结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- src
  - index.js
  - App.js
- .babelrc
- index.html
- package.json
- server.js
- webpack.config.js&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上就是我们的项目需要的全部文件了。&lt;/p&gt;
&lt;p&gt;接下来我会将这个项目的构建过程分解成几个步骤，你只要按照这些步骤依次进行即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://www.wukai.me/tags/webpack/"/>
    
      <category term="react" scheme="http://www.wukai.me/tags/react/"/>
    
      <category term="es6" scheme="http://www.wukai.me/tags/es6/"/>
    
  </entry>
  
</feed>
